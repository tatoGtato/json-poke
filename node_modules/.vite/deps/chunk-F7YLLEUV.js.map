{
  "version": 3,
  "sources": ["../../rxjs/src/internal/util/isFunction.ts", "../../rxjs/src/internal/util/UnsubscriptionError.ts", "../../rxjs/src/internal/Subscription.ts", "../../rxjs/src/internal/config.ts", "../../rxjs/src/internal/scheduler/timeoutProvider.ts", "../../rxjs/src/internal/util/reportUnhandledError.ts", "../../rxjs/src/internal/NotificationFactories.ts", "../../rxjs/src/internal/Subscriber.ts", "../../rxjs/src/internal/symbol/observable.ts", "../../rxjs/src/internal/util/identity.ts", "../../rxjs/src/internal/util/pipe.ts", "../../rxjs/src/internal/Observable.ts", "../../rxjs/src/internal/scheduler/performanceTimestampProvider.ts", "../../rxjs/src/internal/scheduler/animationFrameProvider.ts", "../../rxjs/src/internal/observable/dom/animationFrames.ts", "../../rxjs/src/internal/Subject.ts", "../../rxjs/src/internal/scheduler/dateTimestampProvider.ts", "../../rxjs/src/internal/ReplaySubject.ts", "../../rxjs/src/internal/scheduler/Action.ts", "../../rxjs/src/internal/scheduler/intervalProvider.ts", "../../rxjs/src/internal/util/arrRemove.ts", "../../rxjs/src/internal/scheduler/AsyncAction.ts", "../../rxjs/src/internal/util/Immediate.ts", "../../rxjs/src/internal/scheduler/immediateProvider.ts", "../../rxjs/src/internal/scheduler/AsapAction.ts", "../../rxjs/src/internal/Scheduler.ts", "../../rxjs/src/internal/scheduler/AsyncScheduler.ts", "../../rxjs/src/internal/scheduler/AsapScheduler.ts", "../../rxjs/src/internal/scheduler/asap.ts", "../../rxjs/src/internal/scheduler/async.ts", "../../rxjs/src/internal/scheduler/QueueAction.ts", "../../rxjs/src/internal/scheduler/QueueScheduler.ts", "../../rxjs/src/internal/scheduler/queue.ts", "../../rxjs/src/internal/scheduler/AnimationFrameAction.ts", "../../rxjs/src/internal/scheduler/AnimationFrameScheduler.ts", "../../rxjs/src/internal/scheduler/animationFrame.ts", "../../rxjs/src/internal/util/isArrayLike.ts", "../../rxjs/src/internal/util/isPromise.ts", "../../rxjs/src/internal/util/isInteropObservable.ts", "../../rxjs/src/internal/util/isAsyncIterable.ts", "../../rxjs/src/internal/util/throwUnobservableError.ts", "../../rxjs/src/internal/symbol/iterator.ts", "../../rxjs/src/internal/util/isIterable.ts", "../../rxjs/src/internal/util/isReadableStreamLike.ts", "../../rxjs/src/internal/observable/from.ts", "../../rxjs/src/internal/util/noop.ts", "../../rxjs/src/internal/util/executeSchedule.ts", "../../rxjs/src/internal/util/isScheduler.ts", "../../rxjs/src/internal/operators/subscribeOn.ts", "../../rxjs/src/internal/operators/map.ts", "../../rxjs/src/internal/util/mapOneOrManyArgs.ts", "../../rxjs/src/internal/operators/observeOn.ts", "../../rxjs/src/internal/util/argsArgArrayOrObject.ts", "../../rxjs/src/internal/observable/empty.ts", "../../rxjs/src/internal/operators/mergeInternals.ts", "../../rxjs/src/internal/operators/mergeMap.ts", "../../rxjs/src/internal/operators/mergeAll.ts", "../../rxjs/src/internal/util/args.ts", "../../rxjs/src/internal/scheduled/scheduleObservable.ts", "../../rxjs/src/internal/scheduled/schedulePromise.ts", "../../rxjs/src/internal/scheduled/scheduleArray.ts", "../../rxjs/src/internal/scheduled/scheduleIterable.ts", "../../rxjs/src/internal/scheduled/scheduleAsyncIterable.ts", "../../rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts", "../../rxjs/src/internal/scheduled/scheduled.ts", "../../rxjs/src/internal/observable/fromEvent.ts", "../../rxjs/src/internal/observable/merge.ts", "../../rxjs/src/internal/util/argsOrArgArray.ts", "../../rxjs/src/internal/operators/filter.ts", "../../rxjs/src/internal/observable/never.ts", "../../rxjs/src/internal/operators/distinctUntilChanged.ts", "../../rxjs/src/internal/operators/startWith.ts", "../../@open-cells/core/src/external/event-emitter.js", "../../@open-cells/core/src/manager/events.js", "../../@open-cells/core/src/state/channel.js", "../../@open-cells/core/src/constants.js", "../../@open-cells/core/src/state/subscriptor.js", "../../@open-cells/core/src/utils.js", "../../@open-cells/core/src/adapter/element-adapter.js", "../../@open-cells/core/src/manager/channel-manager.js", "../../@open-cells/core/src/component-connector.js", "../../@open-cells/core/src/route.js", "../../@open-cells/core/src/navigation-stack.js", "../../@open-cells/core/src/router.js", "../../@open-cells/core/src/template.js", "../../@open-cells/core/src/manager/template.js", "../../@open-cells/core/src/manager/bridge-channels.js", "../../@open-cells/core/src/manager/action-channels.js", "../../@open-cells/core/src/manager/post-message.js", "../../@open-cells/core/src/manager/storage.js", "../../@open-cells/core/src/manager/application-config.js", "../../@open-cells/core/src/manager/application-state.js", "../../@open-cells/core/src/bridge.js"],
  "sourcesContent": ["/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n", "/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  constructor(public errors: any[]) {\n    super(\n      errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : ''\n    );\n    this.name = 'UnsubscriptionError';\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n */\nexport class Subscription implements SubscriptionLike {\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Set<Exclude<TeardownLogic, void>> | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors.push(...err.errors);\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown && 'add' in teardown) {\n          // If teardown is a subscription, we can make sure that if it\n          // unsubscribes first, it removes itself from this subscription.\n          teardown.add(() => {\n            this.remove(teardown);\n          });\n        }\n\n        this._finalizers ??= new Set();\n        this._finalizers.add(teardown);\n      }\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * TIP: In instances you're adding and removing _Subscriptions from other Subscriptions_, you should\n   * be sure to unsubscribe or otherwise get rid of the child subscription reference as soon as you remove it.\n   * The child subscription has a reference to the parent it was added to via closure. In most cases, this\n   * a non-issue, as child subscriptions are rarely long-lived.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    this._finalizers?.delete(teardown);\n  }\n}\n\n// Even though Subscription only conditionally implements `Symbol.dispose`\n// if it's available, we still need to declare it here so that TypeScript\n// knows that it exists on the prototype when it is available.\nexport interface Subscription {\n  [Symbol.dispose](): void;\n}\n\nif (typeof Symbol.dispose === 'symbol') {\n  Subscription.prototype[Symbol.dispose] = Subscription.prototype.unsubscribe;\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n\n// Ensure that `Symbol.dispose` is defined in TypeScript\ndeclare global {\n  interface SymbolConstructor {\n    readonly dispose: unique symbol;\n  }\n}\n", "import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n", "import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\nexport function createNotification<T>(kind: 'N', value: T, error: undefined): { kind: 'N'; value: T; error: undefined };\nexport function createNotification<T>(kind: 'E', value: undefined, error: any): { kind: 'E'; value: undefined; error: any };\nexport function createNotification<T>(kind: 'C', value: undefined, error: undefined): { kind: 'C'; value: undefined; error: undefined };\nexport function createNotification<T>(\n  kind: 'N' | 'E' | 'C',\n  value: T | undefined,\n  error: any\n): { kind: 'N' | 'E' | 'C'; value: T | undefined; error: any };\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification<T>(kind: 'N' | 'E' | 'C', value: T | undefined, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n", "import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\n\nexport interface SubscriberOverrides<T> {\n  /**\n   * If provided, this function will be called whenever the {@link Subscriber}'s\n   * `next` method is called, with the value that was passed to that call. If\n   * an error is thrown within this function, it will be handled and passed to\n   * the destination's `error` method.\n   * @param value The value that is being observed from the source.\n   */\n  next?: (value: T) => void;\n  /**\n   * If provided, this function will be called whenever the {@link Subscriber}'s\n   * `error` method is called, with the error that was passed to that call. If\n   * an error is thrown within this function, it will be handled and passed to\n   * the destination's `error` method.\n   * @param err An error that has been thrown by the source observable.\n   */\n  error?: (err: any) => void;\n  /**\n   * If provided, this function will be called whenever the {@link Subscriber}'s\n   * `complete` method is called. If an error is thrown within this function, it\n   * will be handled and passed to the destination's `error` method.\n   */\n  complete?: () => void;\n  /**\n   * If provided, this function will be called after all teardown has occurred\n   * for this {@link Subscriber}. This is generally used for cleanup purposes\n   * during operator development.\n   */\n  finalize?: () => void;\n}\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /** @internal */\n  protected isStopped: boolean = false;\n  /** @internal */\n  protected destination: Observer<T>;\n\n  /** @internal */\n  protected readonly _nextOverride: ((value: T) => void) | null = null;\n  /** @internal */\n  protected readonly _errorOverride: ((err: any) => void) | null = null;\n  /** @internal */\n  protected readonly _completeOverride: (() => void) | null = null;\n  /** @internal */\n  protected readonly _onFinalize: (() => void) | null = null;\n\n  /**\n   * @deprecated Do not create instances of `Subscriber` directly. Use {@link operate} instead.\n   */\n  constructor(destination?: Subscriber<T> | Partial<Observer<T>> | ((value: T) => void) | null);\n\n  /**\n   * @internal\n   */\n  constructor(destination: Subscriber<any> | Partial<Observer<any>> | ((value: any) => void) | null, overrides: SubscriberOverrides<T>);\n\n  /**\n   * Creates an instance of an RxJS Subscriber. This is the workhorse of the library.\n   *\n   * If another instance of Subscriber is passed in, it will automatically wire up unsubscription\n   * between this instance and the passed in instance.\n   *\n   * If a partial or full observer is passed in, it will be wrapped and appropriate safeguards will be applied.\n   *\n   * If a next-handler function is passed in, it will be wrapped and appropriate safeguards will be applied.\n   *\n   * @param destination A subscriber, partial observer, or function that receives the next value.\n   * @deprecated Do not create instances of `Subscriber` directly. Use {@link operate} instead.\n   */\n  constructor(destination?: Subscriber<T> | Partial<Observer<T>> | ((value: T) => void) | null, overrides?: SubscriberOverrides<T>) {\n    super();\n\n    // The only way we know that error reporting safety has been applied is if we own it.\n    this.destination = destination instanceof Subscriber ? destination : createSafeObserver(destination);\n\n    this._nextOverride = overrides?.next ?? null;\n    this._errorOverride = overrides?.error ?? null;\n    this._completeOverride = overrides?.complete ?? null;\n    this._onFinalize = overrides?.finalize ?? null;\n\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all Subscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    this._next = this._nextOverride ? overrideNext : this._next;\n    this._error = this._errorOverride ? overrideError : this._error;\n    this._complete = this._completeOverride ? overrideComplete : this._complete;\n\n    // Automatically chain subscriptions together here.\n    // if destination appears to be one of our subscriptions, we'll chain it.\n    if (hasAddAndUnsubscribe(destination)) {\n      destination.add(this);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param value The `next` value.\n   */\n  next(value: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param err The `error` exception.\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this._onFinalize?.();\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\nfunction overrideNext<T>(this: Subscriber<T>, value: T): void {\n  try {\n    this._nextOverride!(value);\n  } catch (error) {\n    this.destination.error(error);\n  }\n}\n\nfunction overrideError(this: Subscriber<unknown>, err: any): void {\n  try {\n    this._errorOverride!(err);\n  } catch (error) {\n    this.destination.error(error);\n  } finally {\n    this.unsubscribe();\n  }\n}\n\nfunction overrideComplete(this: Subscriber<unknown>): void {\n  try {\n    this._completeOverride!();\n  } catch (error) {\n    this.destination.error(error);\n  } finally {\n    this.unsubscribe();\n  }\n}\n\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        reportUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        reportUnhandledError(error);\n      }\n    } else {\n      reportUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        reportUnhandledError(error);\n      }\n    }\n  }\n}\n\nfunction createSafeObserver<T>(observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null): Observer<T> {\n  return new ConsumerObserver(!observerOrNext || isFunction(observerOrNext) ? { next: observerOrNext ?? undefined } : observerOrNext);\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent.\n * @param subscriber The stopped subscriber.\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\nfunction hasAddAndUnsubscribe(value: any): value is Subscription {\n  return value && isFunction(value.unsubscribe) && isFunction(value.add);\n}\n\nexport interface OperateConfig<In, Out> extends SubscriberOverrides<In> {\n  /**\n   * The destination subscriber to forward notifications to. This is also the\n   * subscriber that will receive unhandled errors if your `next`, `error`, or `complete`\n   * overrides throw.\n   */\n  destination: Subscriber<Out>;\n}\n\n/**\n * Creates a new {@link Subscriber} instance that passes notifications on to the\n * supplied `destination`. The overrides provided in the `config` argument for\n * `next`, `error`, and `complete` will be called in such a way that any\n * errors are caught and forwarded to the destination's `error` handler. The returned\n * `Subscriber` will be \"chained\" to the `destination` such that when `unsubscribe` is\n * called on the `destination`, the returned `Subscriber` will also be unsubscribed.\n *\n * Advanced: This ensures that subscriptions are properly wired up prior to starting the\n * subcription logic. This prevents \"synchronous firehose\" scenarios where an\n * inner observable from a flattening operation cannot be stopped by a downstream\n * terminal operator like `take`.\n *\n * This is a utility designed to be used to create new operators for observables.\n *\n * For examples, please see our code base.\n *\n * @param config The configuration for creating a new subscriber for an operator.\n * @returns A new subscriber that is chained to the destination.\n */\nexport function operate<In, Out>({ destination, ...subscriberOverrides }: OperateConfig<In, Out>) {\n  return new Subscriber(destination, subscriberOverrides);\n}\n", "/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n", "/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n", "import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.\n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray(fns: UnaryFunction<unknown, unknown>[]): UnaryFunction<unknown, unknown> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input) {\n    return fns.reduce((prev, fn) => fn(prev), input);\n  };\n}\n", "import { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, UnaryFunction, Subscribable, Observer, OperatorFunction } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @param subscribe The function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param observerOrNext Either an {@link Observer} with some or all callback methods,\n   * or the `next` handler that is called for each value emitted from the subscribed Observable.\n   * @return A subscription reference to the registered handlers.\n   */\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null): Subscription {\n    const subscriber = observerOrNext instanceof Subscriber ? observerOrNext : new Subscriber(observerOrNext);\n    subscriber.add(this._trySubscribe(subscriber));\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next A handler for each value emitted by the observable.\n   * @return A promise that either resolves on observable completion or\n   * rejects with the handled error.\n   */\n  forEach(next: (value: T) => void): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      const subscriber = new Subscriber({\n        next: (value: T) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _subscribe(_subscriber: Subscriber<any>): TeardownLogic {\n    return;\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @return This instance of the observable.\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: UnaryFunction<Observable<T>, A>): A;\n  pipe<A, B>(op1: UnaryFunction<Observable<T>, A>, op2: UnaryFunction<A, B>): B;\n  pipe<A, B, C>(op1: UnaryFunction<Observable<T>, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): C;\n  pipe<A, B, C, D>(op1: UnaryFunction<Observable<T>, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): D;\n  pipe<A, B, C, D, E>(\n    op1: UnaryFunction<Observable<T>, A>,\n    op2: UnaryFunction<A, B>,\n    op3: UnaryFunction<B, C>,\n    op4: UnaryFunction<C, D>,\n    op5: UnaryFunction<D, E>\n  ): E;\n  pipe<A, B, C, D, E, F>(\n    op1: UnaryFunction<Observable<T>, A>,\n    op2: UnaryFunction<A, B>,\n    op3: UnaryFunction<B, C>,\n    op4: UnaryFunction<C, D>,\n    op5: UnaryFunction<D, E>,\n    op6: UnaryFunction<E, F>\n  ): F;\n  pipe<A, B, C, D, E, F, G>(\n    op1: UnaryFunction<Observable<T>, A>,\n    op2: UnaryFunction<A, B>,\n    op3: UnaryFunction<B, C>,\n    op4: UnaryFunction<C, D>,\n    op5: UnaryFunction<D, E>,\n    op6: UnaryFunction<E, F>,\n    op7: UnaryFunction<F, G>\n  ): G;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: UnaryFunction<Observable<T>, A>,\n    op2: UnaryFunction<A, B>,\n    op3: UnaryFunction<B, C>,\n    op4: UnaryFunction<C, D>,\n    op5: UnaryFunction<D, E>,\n    op6: UnaryFunction<E, F>,\n    op7: UnaryFunction<F, G>,\n    op8: UnaryFunction<G, H>\n  ): H;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: UnaryFunction<Observable<T>, A>,\n    op2: UnaryFunction<A, B>,\n    op3: UnaryFunction<B, C>,\n    op4: UnaryFunction<C, D>,\n    op5: UnaryFunction<D, E>,\n    op6: UnaryFunction<E, F>,\n    op7: UnaryFunction<F, G>,\n    op8: UnaryFunction<G, H>,\n    op9: UnaryFunction<H, I>\n  ): I;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: UnaryFunction<Observable<T>, A>,\n    op2: UnaryFunction<A, B>,\n    op3: UnaryFunction<B, C>,\n    op4: UnaryFunction<C, D>,\n    op5: UnaryFunction<D, E>,\n    op6: UnaryFunction<E, F>,\n    op7: UnaryFunction<F, G>,\n    op8: UnaryFunction<G, H>,\n    op9: UnaryFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: UnaryFunction<Observable<T>, A>,\n    op2: UnaryFunction<A, B>,\n    op3: UnaryFunction<B, C>,\n    op4: UnaryFunction<C, D>,\n    op5: UnaryFunction<D, E>,\n    op6: UnaryFunction<E, F>,\n    op7: UnaryFunction<F, G>,\n    op8: UnaryFunction<G, H>,\n    op9: UnaryFunction<H, I>,\n    ...operations: UnaryFunction<any, any>[]\n  ): unknown;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   *\n   * @return The Observable result of all the operators having been called\n   * in the order they were passed in.\n   */\n  pipe(...operations: UnaryFunction<any, any>[]): unknown {\n    return pipeFromArray(operations)(this);\n  }\n\n  /**\n   * Observable is async iterable, so it can be used in `for await` loop. This method\n   * of subscription is cancellable by breaking the for await loop. Although it's not\n   * recommended to use Observable's AsyncIterable contract outside of `for await`, if\n   * you're consuming the Observable as an AsyncIterable, and you're _not_ using `for await`,\n   * you can use the `throw` or `return` methods on the `AsyncGenerator` we return to\n   * cancel the subscription. Note that the subscription to the observable does not start\n   * until the first value is requested from the AsyncIterable.\n   *\n   * Functionally, this is equivalent to using a {@link concatMap} with an `async` function.\n   * That means that while the body of the `for await` loop is executing, any values that arrive\n   * from the observable source will be queued up, so they can be processed by the `for await`\n   * loop in order. So, like {@link concatMap} it's important to understand the speed your\n   * source emits at, and the speed of the body of your `for await` loop.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * async function main() {\n   *  // Subscribe to the observable using for await.\n   *  for await (const value of interval(1000)) {\n   *    console.log(value);\n   *\n   *    if (value > 5) {\n   *      // Unsubscribe from the interval if we get a value greater than 5\n   *      break;\n   *    }\n   *  }\n   * }\n   *\n   * main();\n   * ```\n   */\n  [Symbol.asyncIterator](): AsyncGenerator<T, void, void> {\n    let subscription: Subscription | undefined;\n    let hasError = false;\n    let error: unknown;\n    let completed = false;\n    const values: T[] = [];\n    const deferreds: [(value: IteratorResult<T>) => void, (reason: unknown) => void][] = [];\n\n    const handleError = (err: unknown) => {\n      hasError = true;\n      error = err;\n      while (deferreds.length) {\n        const [_, reject] = deferreds.shift()!;\n        reject(err);\n      }\n    };\n\n    const handleComplete = () => {\n      completed = true;\n      while (deferreds.length) {\n        const [resolve] = deferreds.shift()!;\n        resolve({ value: undefined, done: true });\n      }\n    };\n\n    return {\n      next: (): Promise<IteratorResult<T>> => {\n        if (!subscription) {\n          // We only want to start the subscription when the user starts iterating.\n          subscription = this.subscribe({\n            next: (value) => {\n              if (deferreds.length) {\n                const [resolve] = deferreds.shift()!;\n                resolve({ value, done: false });\n              } else {\n                values.push(value);\n              }\n            },\n            error: handleError,\n            complete: handleComplete,\n          });\n        }\n\n        // If we already have some values in our buffer, we'll return the next one.\n        if (values.length) {\n          return Promise.resolve({ value: values.shift()!, done: false });\n        }\n\n        // This was already completed, so we're just going to return a done result.\n        if (completed) {\n          return Promise.resolve({ value: undefined, done: true });\n        }\n\n        // There was an error, so we're going to return an error result.\n        if (hasError) {\n          return Promise.reject(error);\n        }\n\n        // Otherwise, we need to make them wait for a value.\n        return new Promise((resolve, reject) => {\n          deferreds.push([resolve, reject]);\n        });\n      },\n      throw: (err): Promise<IteratorResult<T>> => {\n        subscription?.unsubscribe();\n        // NOTE: I did some research on this, and as of Feb 2023, Chrome doesn't seem to do\n        // anything with pending promises returned from `next()` when `throw()` is called.\n        // However, for consumption of observables, I don't want RxJS taking the heat for that\n        // quirk/leak of the type. So we're going to reject all pending promises we've nexted out here.\n        handleError(err);\n        return Promise.reject(err);\n      },\n      return: (): Promise<IteratorResult<T>> => {\n        subscription?.unsubscribe();\n        // NOTE: I did some research on this, and as of Feb 2023, Chrome doesn't seem to do\n        // anything with pending promises returned from `next()` when `throw()` is called.\n        // However, for consumption of observables, I don't want RxJS taking the heat for that\n        // quirk/leak of the type. So we're going to resolve all pending promises we've nexted out here.\n        handleComplete();\n        return Promise.resolve({ value: undefined, done: true });\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n    };\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n", "import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n", "import { Observable } from '../../Observable';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n\n    let id = 0;\n    const run = () => {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\n          id = 0;\n          // Use the provider's timestamp to calculate the elapsed time. Note that\n          // this means - if the caller hasn't passed a provider - that\n          // performance.now() will be used instead of the timestamp that was\n          // passed to the run callback. The reason for this is that the timestamp\n          // passed to the callback can be earlier than the start time, as it\n          // represents the time at which the browser decided it would render any\n          // queued frames - and that time can be earlier the captured start time.\n          const now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start,\n          });\n          run();\n        });\n      }\n    };\n\n    run();\n\n    return () => {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n", "import { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike } from './types';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  /** @internal */\n  _closed = false;\n\n  /**\n   * Will return true if this subject has been closed and is no longer accepting new values.\n   */\n  get closed() {\n    return this._closed;\n  }\n\n  private _observerCounter = 0;\n  private currentObservers = new Map<number, Observer<T>>();\n\n  /**\n   * This is used to track a known array of observers, so we don't have to\n   * clone them while iterating to prevent reentrant behaviors.\n   * (for example, what if the subject is subscribed to when nexting to an observer)\n   */\n  private observerSnapshot: Observer<T>[] | undefined;\n\n  /** @internal */\n  get observers(): Observer<T>[] {\n    return (this.observerSnapshot ??= Array.from(this.currentObservers.values()));\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  protected _clearObservers() {\n    this.currentObservers.clear();\n    this.observerSnapshot = undefined;\n  }\n\n  next(value: T) {\n    if (!this._closed) {\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (!this._closed) {\n      this.hasError = this._closed = true;\n      this.thrownError = err;\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].error(err);\n      }\n      this._clearObservers();\n    }\n  }\n\n  complete() {\n    if (!this._closed) {\n      this._closed = true;\n      const { observers } = this;\n      const len = observers.length;\n      for (let i = 0; i < len; i++) {\n        observers[i].complete();\n      }\n      this._clearObservers();\n    }\n  }\n\n  unsubscribe() {\n    this._closed = true;\n    this._clearObservers();\n  }\n\n  get observed() {\n    return this.currentObservers.size > 0;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    if (this.hasError || this._closed) {\n      return Subscription.EMPTY;\n    }\n    const { currentObservers } = this;\n\n    const observerId = this._observerCounter++;\n    currentObservers.set(observerId, subscriber);\n    this.observerSnapshot = undefined;\n    subscriber.add(() => {\n      currentObservers.delete(observerId);\n      this.observerSnapshot = undefined;\n    });\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, _closed } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (_closed) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return Observable that this Subject casts to.\n   */\n  asObservable(): Observable<T> {\n    return new Observable((subscriber) => this.subscribe(subscriber));\n  }\n}\n\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    /** @internal */\n    protected _source?: Observable<T>\n  ) {\n    super();\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this._source?.subscribe(subscriber) ?? Subscription.EMPTY;\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n", "import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param _bufferSize The size of the buffer to replay on subscription\n   * @param _windowTime The amount of time the buffered items will stay buffered\n   * @param _timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { _closed, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!_closed) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param state Some contextual data that the `work` function uses when called by the\n   * Scheduler.\n   * @param delay Time to wait before executing the work, where the time unit is implicit\n   * and defined by the Scheduler.\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n", "/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n", "import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n", "let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n", "import { Immediate } from '../util/Immediate';\nimport type { TimerHandle } from './timerHandle';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param work A function representing a task, or some unit of work to be\n   * executed by the Scheduler.\n   * @param delay Time to wait before executing the work, where the time unit is\n   * implicit and defined by the Scheduler itself.\n   * @param state Some contextual data that the `work` function uses when called\n   * by the Scheduler.\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asapScheduler` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asapScheduler` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asapScheduler` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asapScheduler` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asapScheduler` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `asyncScheduler` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n\n    // Otherwise flush the scheduler starting with this action.\n    scheduler.flush(this);\n\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\n    // `TimerHandle`, and generally the return value here isn't really used. So the\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\n    return 0;\n  }\n}\n", "import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n", "import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queueScheduler` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queueScheduler` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n", "import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      animationFrameProvider.cancelAnimationFrame(id as number);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrameScheduler` scheduler is used with delay, it will fall back to {@link asyncScheduler}\n * scheduler behaviour.\n *\n * Without delay, `animationFrameScheduler` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n", "export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');", "import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n", "import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n", "import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n", "/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n", "export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n", "import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n", "import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n", "import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from, take } from 'rxjs';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n * @see {@link scheduled}\n *\n * @param input A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, async iterable, or an array-like object to be converted.\n */\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function from<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nfunction fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    subscribeToArray(array, subscriber);\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nfunction fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nfunction fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nfunction fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n * @param subscriber\n */\nexport function subscribeToArray<T>(array: ArrayLike<T>, subscriber: Subscriber<T>) {\n  // Loop over the array and emit each value. Note two things here:\n  // 1. We're making sure that the subscriber is not closed on each loop.\n  //    This is so we don't continue looping over a very large array after\n  //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n  //    has already unsubscribed.\n  // 2. In this form, reentrant code can alter that array we're looping over.\n  //    This is a known issue, but considered an edge case. The alternative would\n  //    be to copy the array before executing the loop, but this has\n  //    performance implications.\n  const length = array.length;\n  for (let i = 0; i < length; i++) {\n    if (subscriber.closed) {\n      return;\n    }\n    subscriber.next(array[i]);\n  }\n  subscriber.complete();\n}\n", "/* tslint:disable:no-empty */\nexport function noop() { }\n", "import { Subscription } from '../Subscription';\nimport { SchedulerAction, SchedulerLike } from '../types';\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay: number,\n  repeat: true\n): void;\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay?: number,\n  repeat?: false\n): Subscription;\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay = 0,\n  repeat = false\n): Subscription | void {\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n\n  parentSubscription.add(scheduleSubscription);\n\n  if (!repeat) {\n    // Because user-land scheduler implementations are unlikely to properly reuse\n    // Actions for repeat scheduling, we can't trust that the returned subscription\n    // will control repeat subscription scenarios. So we're trying to avoid using them\n    // incorrectly within this library.\n    return scheduleSubscription;\n  }\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n", "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return (source) =>\n    new Observable((subscriber) => {\n      subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n    });\n}\n", "import { OperatorFunction } from '../types';\nimport { Observable } from '../Observable';\nimport { operate } from '../Subscriber';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n *\n * Map every click to the `clientX` position of that click\n *\n * ```ts\n * import { fromEvent, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n *\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n *\n * @param project The function to apply to each `value` emitted by the source\n * Observable. The `index` parameter is the number `i` for the i-th emission\n * that has happened since the subscription, starting from the number `0`.\n * @return A function that returns an Observable that emits the values from the\n * source Observable transformed by the given `project` function.\n */\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R> {\n  return (source) =>\n    new Observable((destination) => {\n      // The index of the value from the source. Used with projection.\n      let index = 0;\n      // Subscribe to the source, all errors and completions are sent along\n      // to the consumer.\n      source.subscribe(\n        operate({\n          destination,\n          next: (value: T) => {\n            // Call the projection function with the appropriate this context,\n            // and send the resulting value to the consumer.\n            destination.next(project(value, index++));\n          },\n        })\n      );\n    });\n}\n", "import { OperatorFunction } from \"../types\";\nimport { map } from \"../operators/map\";\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\n    return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Used in several -- mostly deprecated -- situations where we need to \n * apply a list of arguments or a single argument to a result selector.\n */\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\n    return map(args => callOrApply(fn, args))\n}", "/** @prettier */\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { Observable } from '../Observable';\nimport { operate } from '../Subscriber';\n\n/**\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n *\n * Ensure values in subscribe are called just before browser repaint\n *\n * ```ts\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\n *\n * const someDiv = document.createElement('div');\n * someDiv.style.cssText = 'width: 200px;background: #09c';\n * document.body.appendChild(someDiv);\n * const intervals = interval(10);      // Intervals are scheduled\n *                                      // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrameScheduler\n * )                                    // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return A function that returns an Observable that emits the same\n * notifications as the source Observable, but with provided scheduler.\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\n  return (source) =>\n    new Observable((destination) => {\n      source.subscribe(\n        operate({\n          destination,\n          next: (value) => executeSchedule(destination, scheduler, () => destination.next(value), delay),\n          error: (err) => executeSchedule(destination, scheduler, () => destination.error(err), delay),\n          complete: () => executeSchedule(destination, scheduler, () => destination.complete(), delay),\n        })\n      );\n    });\n}\n", "const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    const result = arrayOrObject(first);\n    if (result) {\n      return result;\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nexport function arrayOrObject<T, O extends Record<string, T>>(first: T | T[] | O) {\n  if (isArray(first)) {\n    return { args: first, keys: null };\n  }\n  if (isPOJO(first)) {\n    const keys = getKeys(first);\n    return {\n      args: keys.map((key) => first[key]),\n      keys,\n    };\n  }\n  return null;\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n", "import { Observable } from '../Observable';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n", "import { Observable } from '../Observable';\nimport { from } from '../observable/from';\nimport { Subscriber, operate } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param destination The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  destination: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      destination.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && destination.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    from(project(value, index++)).subscribe(\n      operate({\n        destination,\n        next: (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            destination.next(innerValue);\n          }\n        },\n        complete: () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        finalize: () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(destination, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              destination.error(err);\n            }\n          }\n        },\n      })\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    operate({\n      destination,\n      next: outerNext,\n      complete: () => {\n        // Outer completed, make a note of it, and check to see if we can complete everything.\n        isComplete = true;\n        checkComplete();\n      },\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n", "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { Observable } from '../Observable';\nimport { mergeInternals } from './mergeInternals';\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n *\n * Map and flatten each letter to an Observable ticking every 1 second\n *\n * ```ts\n * import { of, mergeMap, interval, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\n * );\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a, b, c every second with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @param concurrent Maximum number of `ObservableInput`s being subscribed to concurrently.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function to each item emitted by the source Observable\n * and merging the results of the Observables obtained from this transformation.\n */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O>> {\n  return (source) => new Observable((subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n", "import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n *\n * ```ts\n * import { fromEvent, map, interval, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map(() => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n *\n * ```ts\n * import { fromEvent, map, interval, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(10)))\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param concurrent Maximum number of inner Observables being subscribed to\n * concurrently.\n * @return A function that returns an Observable that emits values coming from\n * all the inner Observables emitted by the source Observable.\n */\nexport function mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeMap(identity, concurrent);\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n", "import { from } from '../observable/from';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { InteropObservable, SchedulerLike } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return from(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { from } from '../observable/from';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { SchedulerLike } from '../types';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return from(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    // The current array index.\n    let i = 0;\n    // Start iterating over the array like on a schedule.\n    return scheduler.schedule(function () {\n      if (i === input.length) {\n        // If we have hit the end of the array like in the\n        // previous job, we can complete.\n        subscriber.complete();\n      } else {\n        // Otherwise let's next the value at the current index,\n        // then increment our index.\n        subscriber.next(input[i++]);\n        // If the last emission didn't cause us to close the subscriber\n        // (via take or some side effect), reschedule the job and we'll\n        // make another pass.\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * Used in {@link scheduled} to create an observable from an Iterable.\n * @param input The iterable to create an observable from\n * @param scheduler The scheduler to use\n */\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    let iterator: Iterator<T, T>;\n\n    // Schedule the initial creation of the iterator from\n    // the iterable. This is so the code in the iterable is\n    // not called until the scheduled job fires.\n    executeSchedule(subscriber, scheduler, () => {\n      // Create the iterator.\n      iterator = (input as any)[Symbol_iterator]();\n\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          let value: T;\n          let done: boolean | undefined;\n          try {\n            // Pull the value out of the iterator\n            ({ value, done } = iterator.next());\n          } catch (err) {\n            // We got an error while pulling from the iterator\n            subscriber.error(err);\n            return;\n          }\n\n          if (done) {\n            // If it is \"done\" we just complete. This mimics the\n            // behavior of JavaScript's `for..of` consumption of\n            // iterables, which will not emit the value from an iterator\n            // result of `{ done: true: value: 'here' }`.\n            subscriber.complete();\n          } else {\n            // The iterable is not done, emit the value.\n            subscriber.next(value);\n          }\n        },\n        0,\n        true\n      );\n    });\n\n    // During finalization, if we see this iterator has a `return` method,\n    // then we know it is a Generator, and not just an Iterator. So we call\n    // the `return()` function. This will ensure that any `finally { }` blocks\n    // inside of the generator we can hit will be hit properly.\n    return () => isFunction(iterator?.return) && iterator.return();\n  });\n}\n", "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator = input[Symbol.asyncIterator]();\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          iterator.next().then((result) => {\n            if (result.done) {\n              // This will remove the subscriptions from\n              // the parent subscription.\n              subscriber.complete();\n            } else {\n              subscriber.next(result.value);\n            }\n          });\n        },\n        0,\n        true\n      );\n    });\n  });\n}\n", "import { SchedulerLike, ReadableStreamLike } from '../types';\nimport { Observable } from '../Observable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\n\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n", "import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see {@link from}\n * @see {@link of}\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    }\n    if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }\n    if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    }\n    if (isAsyncIterable(input)) {\n      return scheduleAsyncIterable(input, scheduler);\n    }\n    if (isIterable(input)) {\n      return scheduleIterable(input, scheduler);\n    }\n    if (isReadableStreamLike(input)) {\n      return scheduleReadableStreamLike(input, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input);\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n// These constants are used to create handler registry functions using array mapping below.\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\nconst jqueryMethods = ['on', 'off'] as const;\n\nexport interface NodeStyleEventEmitter {\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\n}\n\n// Use handler types like those in @types/jquery. See:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\nexport interface JQueryStyleEventEmitter<TContext, T> {\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n}\n\nexport interface EventListenerObject<E> {\n  handleEvent(evt: E): void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: EventListenerOptions | boolean\n  ): void;\n}\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  resultSelector: (event: T) => R\n): Observable<R>;\nexport function fromEvent<T>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (event: T) => R\n): Observable<R>;\n\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string\n): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent<T>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string,\n  resultSelector: (value: T, ...args: any[]) => R\n): Observable<R>;\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n *\n * Emit clicks happening on the DOM document\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * Use `addEventListener` with capture option\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * // note optional configuration parameter which will be passed to addEventListener\n * const clicksInDocument = fromEvent(document, 'click', { capture: true });\n * const clicksInDiv = fromEvent(div, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param target The DOM EventTarget, Node.js EventEmitter, JQuery-like event target,\n * NodeList or HTMLCollection to attach the event handler to.\n * @param eventName The event name of interest, being emitted by the `target`.\n * @param options Options to pass through to the underlying `addListener`,\n * `addEventListener` or `on` functions.\n * @param resultSelector A mapping function used to transform events. It takes the\n * arguments from the event handler and should return a single value.\n * @return An Observable emitting events registered through `target`'s\n * listener handlers.\n */\nexport function fromEvent<T>(\n  target: any,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: (...args: any[]) => T\n): Observable<T> {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n\n  if (resultSelector) {\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  const isValidTarget = isNodeStyleEventEmitter(target) || isJQueryStyleEventEmitter(target) || isEventTarget(target);\n\n  if (!isValidTarget && !isArrayLike(target)) {\n    throw new TypeError('Invalid event target');\n  }\n\n  return new Observable<T>((subscriber) => {\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\n    if (isValidTarget) {\n      // Valid event targets, even if they have a `length` property\n      // will be subscribed to as a single item.\n      doSubscribe(handler, subscriber, target, eventName, options);\n    } else {\n      // If it wasn't a valid event target, it must be an array-like.\n      // Subscribe to each item in the array-like.\n      for (let i = 0; i < target.length && !subscriber.closed; i++) {\n        const subTarget = target[i];\n        doSubscribe(handler, subscriber, subTarget, eventName, options);\n      }\n    }\n  });\n}\n\nfunction doSubscribe(handler: (...args: any[]) => void, subscriber: Subscriber<any>, subTarget: any, eventName: string, options: any) {\n  const [addMethod, removeMethod] = getRegistryMethodNames(subTarget);\n  if (!addMethod || !removeMethod) {\n    throw new TypeError('Invalid event target');\n  }\n  subTarget[addMethod](eventName, handler, options);\n  subscriber.add(() => subTarget[removeMethod](eventName, handler, options));\n}\n\nfunction getRegistryMethodNames(target: any) {\n  // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\n  return isEventTarget(target)\n    ? eventTargetMethods\n    : // In all other cases, the call pattern is identical with the exception of the method names.\n    isNodeStyleEventEmitter(target)\n    ? nodeEventEmitterMethods\n    : isJQueryStyleEventEmitter(target)\n    ? jqueryMethods\n    : [];\n}\n\n/**\n * Checks to see if the target implements the required node-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\n  return isFunction(target.addListener) && isFunction(target.removeListener);\n}\n\n/**\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\n  return isFunction(target.on) && isFunction(target.off);\n}\n\n/**\n * Checks to see if the target implements the required EventTarget methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\nimport { mergeAll } from '../operators/mergeAll';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { scheduled } from '../scheduled/scheduled';\nimport { from } from './from';\n\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\n): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\n): Observable<A[number]>;\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Merge together two Observables: 1s interval and clicks\n *\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * Merge together 3 Observables, but run only 2 concurrently\n *\n * ```ts\n * import { interval, take, merge } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits its max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits its max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param args `ObservableInput`s to merge together. If the last parameter\n * is of type number, `merge` will use it to limit number of concurrently\n * subscribed `ObservableInput`s.\n * @return An Observable that emits items that are the result of every input Observable.\n */\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  const sources = args as ObservableInput<unknown>[];\n  return !sources.length\n    ? // No source provided\n      EMPTY\n    : sources.length === 1\n    ? // One source? Just return it.\n      from(sources[0])\n    : // Merge all sources\n      mergeAll(concurrent)(scheduler ? scheduled(sources, scheduler) : from(sources));\n}\n", "const { isArray } = Array;\n\n/**\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\n * as a single argument.\n */\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\n}\n", "import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { Observable } from '../Observable';\nimport { operate } from '../Subscriber';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n *\n * Emit only click events whose target was a DIV element\n *\n * ```ts\n * import { fromEvent, filter } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param thisArg An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits items from the\n * source Observable that satisfy the specified `predicate`.\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> {\n  return (source) =>\n    new Observable((destination) => {\n      // An index passed to our predicate function on each call.\n      let index = 0;\n\n      // Subscribe to the source, all errors and completions are\n      // forwarded to the consumer.\n      source.subscribe(\n        // Call the predicate with the appropriate `this` context,\n        // if the predicate returns `true`, then send the value\n        // to the consumer.\n        operate({ destination, next: (value) => predicate.call(thisArg, value, index++) && destination.next(value) })\n      );\n    });\n}\n", "import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n", "import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { Observable } from '../Observable';\nimport { operate } from '../Subscriber';\n\nexport function distinctUntilChanged<T>(comparator?: (previous: T, current: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(\n  comparator: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a result {@link Observable} that emits all values pushed by the source observable if they\n * are distinct in comparison to the last value the result observable emitted.\n *\n * When provided without parameters or with the first parameter (`{@link distinctUntilChanged#comparator comparator}`),\n * it behaves like this:\n *\n * 1. It will always emit the first value from the source.\n * 2. For all subsequent values pushed by the source, they will be compared to the previously emitted values\n *    using the provided `comparator` or an `===` equality check.\n * 3. If the value pushed by the source is determined to be unequal by this check, that value is emitted and\n *    becomes the new \"previously emitted value\" internally.\n *\n * When the second parameter (`{@link distinctUntilChanged#keySelector keySelector}`) is provided, the behavior\n * changes:\n *\n * 1. It will always emit the first value from the source.\n * 2. The `keySelector` will be run against all values, including the first value.\n * 3. For all values after the first, the selected key will be compared against the key selected from\n *    the previously emitted value using the `comparator`.\n * 4. If the keys are determined to be unequal by this check, the value (not the key), is emitted\n *    and the selected key from that value is saved for future comparisons against other keys.\n *\n * ## Examples\n *\n * A very basic example with no `{@link distinctUntilChanged#comparator comparator}`. Note that `1` is emitted more than once,\n * because it's distinct in comparison to the _previously emitted_ value,\n * not in comparison to _all other emitted values_.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * of(1, 1, 1, 2, 2, 2, 1, 1, 3, 3)\n *   .pipe(distinctUntilChanged())\n *   .subscribe(console.log);\n * // Logs: 1, 2, 1, 3\n * ```\n *\n * With a `{@link distinctUntilChanged#comparator comparator}`, you can do custom comparisons. Let's say\n * you only want to emit a value when all of its components have\n * changed:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const totallyDifferentBuilds$ = of(\n *   { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },\n *   { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },\n *   { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ).pipe(\n *   distinctUntilChanged((prev, curr) => {\n *     return (\n *       prev.engineVersion === curr.engineVersion ||\n *       prev.transmissionVersion === curr.transmissionVersion\n *     );\n *   })\n * );\n *\n * totallyDifferentBuilds$.subscribe(console.log);\n *\n * // Logs:\n * // { engineVersion: '1.1.0', transmissionVersion: '1.2.0' }\n * // { engineVersion: '1.3.0', transmissionVersion: '1.4.0' }\n * // { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ```\n *\n * You can also provide a custom `{@link distinctUntilChanged#comparator comparator}` to check that emitted\n * changes are only in one direction. Let's say you only want to get\n * the next record temperature:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const temps$ = of(30, 31, 20, 34, 33, 29, 35, 20);\n *\n * const recordHighs$ = temps$.pipe(\n *   distinctUntilChanged((prevHigh, temp) => {\n *     // If the current temp is less than\n *     // or the same as the previous record,\n *     // the record hasn't changed.\n *     return temp <= prevHigh;\n *   })\n * );\n *\n * recordHighs$.subscribe(console.log);\n * // Logs: 30, 31, 34, 35\n * ```\n *\n * Selecting update events only when the `updatedBy` field shows\n * the account changed hands.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * // A stream of updates to a given account\n * const accountUpdates$ = of(\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'blesh', data: [] }\n * );\n *\n * // We only want the events where it changed hands\n * const changedHands$ = accountUpdates$.pipe(\n *   distinctUntilChanged(undefined, update => update.updatedBy)\n * );\n *\n * changedHands$.subscribe(console.log);\n * // Logs:\n * // { updatedBy: 'blesh', data: Array[0] }\n * // { updatedBy: 'ncjamieson', data: Array[0] }\n * // { updatedBy: 'blesh', data: Array[0] }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param comparator A function used to compare the previous and current keys for\n * equality. Defaults to a `===` check.\n * @param keySelector Used to select a key value to be passed to the `comparator`.\n *\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values.\n */\nexport function distinctUntilChanged<T, K>(\n  comparator?: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K = identity as (value: T) => K\n): MonoTypeOperatorFunction<T> {\n  // We've been allowing `null` do be passed as the `compare`, so we can't do\n  // a default value for the parameter, because that will only work\n  // for `undefined`.\n  comparator = comparator ?? defaultCompare;\n\n  return (source) =>\n    new Observable((destination) => {\n      // The previous key, used to compare against keys selected\n      // from new arrivals to determine \"distinctiveness\".\n      let previousKey: K;\n      // Whether or not this is the first value we've gotten.\n      let first = true;\n\n      source.subscribe(\n        operate({\n          destination,\n          next: (value) => {\n            // We always call the key selector.\n            const currentKey = keySelector(value);\n\n            // If it's the first value, we always emit it.\n            // Otherwise, we compare this key to the previous key, and\n            // if the comparer returns false, we emit.\n            if (first || !comparator!(previousKey, currentKey)) {\n              // Update our state *before* we emit the value\n              // as emission can be the source of re-entrant code\n              // in functional libraries like this. We only really\n              // need to do this if it's the first value, or if the\n              // key we're tracking in previous needs to change.\n              first = false;\n              previousKey = currentKey;\n\n              // Emit the value!\n              destination.next(value);\n            }\n          },\n        })\n      );\n    });\n}\n\nfunction defaultCompare(a: any, b: any) {\n  return a === b;\n}\n", "import { Observable } from '../Observable';\nimport { subscribeToArray } from '../observable/from';\nimport { operate } from '../Subscriber';\nimport { OperatorFunction, ValueFromArray } from '../types';\n\nexport function startWith<T>(value: null): OperatorFunction<T, T | null>;\nexport function startWith<T>(value: undefined): OperatorFunction<T, T | undefined>;\nexport function startWith<T, A extends readonly unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\n\n/**\n * Returns an observable that, at the moment of subscription, will synchronously emit all\n * values provided to this operator, then subscribe to the source and mirror all of its emissions\n * to subscribers.\n *\n * This is a useful way to know when subscription has occurred on an existing observable.\n *\n * <span class=\"informal\">First emits its arguments in order, and then any\n * emissions from the source.</span>\n *\n * ![](startWith.png)\n *\n * ## Examples\n *\n * Emit a value when a timer starts.\n *\n * ```ts\n * import { timer, map, startWith } from 'rxjs';\n *\n * timer(1000)\n *   .pipe(\n *     map(() => 'timer emit'),\n *     startWith('timer start')\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // results:\n * // 'timer start'\n * // 'timer emit'\n * ```\n *\n * @param values Items you want the modified Observable to emit first.\n * @return A function that returns an Observable that synchronously emits\n * provided values before subscribing to the source Observable.\n *\n * @see {@link endWith}\n * @see {@link finalize}\n * @see {@link concat}\n */\nexport function startWith<T, D>(...values: D[]): OperatorFunction<T, T | D> {\n  return (source) =>\n    new Observable((destination) => {\n      subscribeToArray(values, operate({ destination, complete: () => source.subscribe(destination) }));\n    });\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// @ts-nocheck\n\n// the next line ask to ignore this file for coverage\n/* c8 ignore next 500 */\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply =\n  R && typeof R.apply === 'function'\n    ? R.apply\n    : function ReflectApply(target, receiver, args) {\n        return Function.prototype.apply.call(target, receiver, args);\n      };\n\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN =\n  Number.isNaN ||\n  function NumberIsNaN(value) {\n    return value !== value;\n  };\n\nexport function EventEmitter() {\n  EventEmitter.init.call(this);\n}\n\n// module.exports = EventEmitter;\n// module.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError(\n      'The \"listener\" argument must be of type Function. Received type ' + typeof listener,\n    );\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function () {\n    return defaultMaxListeners;\n  },\n  set: function (arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError(\n        'The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' +\n          arg +\n          '.',\n      );\n    }\n    defaultMaxListeners = arg;\n  },\n});\n\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError(\n      'The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.',\n    );\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = type === 'error';\n\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;\n  else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error(\n        'Possible EventEmitter memory leak detected. ' +\n          existing.length +\n          ' ' +\n          String(type) +\n          ' listeners ' +\n          'added. Use emitter.setMaxListeners() to ' +\n          'increase limit',\n      );\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n\n  checkListener(listener);\n\n  events = this._events;\n  if (events === undefined) return this;\n\n  list = events[type];\n  if (list === undefined) return this;\n\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);\n    else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (position === 0) list.shift();\n    else {\n      spliceOne(list, position);\n    }\n\n    if (list.length === 1) events[type] = list[0];\n\n    if (events.removeListener !== undefined)\n      this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);\n      else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined) return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nexport function once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError(\n      'The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter,\n    );\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EventEmitter } from '../external/event-emitter';\n\n/**\n * @typedef {import('../../types').WCNode} WCNode\n *\n * @typedef {import('../../types').WCEvent} WCEvent\n *\n * @typedef {import('../../types').AugmentedFunction} AugmentedFunction\n */\n\n/** @type {number} */\nconst MAX_NUM_LISTENERS = 20;\n\n/** Custom event emitter class that extends EventEmitter. */\nclass CustomEventEmitter extends EventEmitter {\n  constructor(maxNumListeners = 10) {\n    super();\n    this.setMaxListeners(maxNumListeners);\n  }\n  /**\n   * Listens to an event on a given node and executes the callback function once.\n   *\n   * @param {WCNode} node - The node to listen to the event on.\n   * @param {string} name - The name of the event to listen for.\n   * @param {Function} callback - The callback function to execute when the event is triggered.\n   */\n  listenToOnce(node, name, callback) {\n    node.addEventListener(name, function cb(event) {\n      callback();\n      event.currentTarget?.removeEventListener(event.type, cb);\n    });\n  }\n\n  /**\n   * Creates an event.\n   *\n   * @param {string} name - The name of the event.\n   * @param {any} value - The value of the event.\n   * @returns {WCEvent} The created event.\n   */\n  createEvent(name, value) {\n    /** @type {WCEvent} */\n    let evt = new Event(name);\n    evt.detail = { value };\n    return evt;\n  }\n}\n\nexport const eventManager = new CustomEventEmitter(MAX_NUM_LISTENERS);\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ReplaySubject } from 'rxjs';\n\n/** @typedef {import('../../types').PublishableValue} PublishableValue */\n\n/**\n * Generate a UUID.\n *\n * @returns {String} The generated UUID.\n */\nexport function generateUUID() {\n  let d = new Date().getTime();\n  let uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = (d + Math.random() * 16) % 16 | 0;\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n  return uuid;\n}\n\n/** @extends ReplaySubject<PublishableValue> */\n// @ts-ignore\nexport class Channel extends ReplaySubject {\n  /**\n   * Creates a channel for sending values, errors, and completion signals.\n   *\n   * @param {string} name - The name of the channel.\n   */\n  constructor(name) {\n    super(1);\n    this.name = name;\n  }\n\n  /**\n   * Sends the next value to the channel. If the value does not have a UUID, it generates one. If\n   * the value does not have a time, it sets the current time.\n   *\n   * @param {PublishableValue} value - The value to be sent to the channel.\n   * @returns {void}\n   */\n  next(value) {\n    if (!value.uuid) {\n      value.uuid = generateUUID();\n    }\n    if (!value.time) {\n      value.time = new Date().getTime();\n    }\n    super.next(value);\n  }\n\n  /**\n   * Checks if the channel has any observers.\n   *\n   * @returns {boolean} True if the channel has observers, false otherwise.\n   * @throws {Error} If the channel is closed.\n   */\n  hasObservers() {\n    if (this.closed) {\n      throw new Error();\n    }\n\n    return this.observed;\n  }\n\n  // /**\n  //  * Unsubscribes an observer from the channel.\n  //  *\n  //  * @param {number} index - The index of the observer to unsubscribe.\n  //  * @returns {void}\n  //  */\n  // unsubscribeObserver(index) {\n  //   this.observers?.splice(index, 1);\n  //   if (this.observers?.length === 0) {\n  //     this.unsubscribe();\n  //   }\n  // }\n\n  /**\n   * Unsubscribes all observers from the channel.\n   *\n   * @returns {void}\n   */\n  unsubscribeAllObservers() {\n    this.unsubscribe();\n  }\n\n  /**\n   * Cleans the channel by resetting the buffer and observers.\n   *\n   * @memberof Channel\n   * @function\n   * @returns {void}\n   * @name clean\n   * @instance\n   */\n  clean() {\n    /** @type {any[]} */\n    // @ts-ignore\n    this._buffer = [];\n    /** @type {any[]} */\n    // this.observers = [];\n    this._clearObservers();\n  }\n\n  get buffer() {\n    // @ts-ignore\n    return this._buffer;\n  }\n\n  set buffer(value) {\n    // @ts-ignore\n    this._buffer = value;\n  }\n\n  // /**\n  //  * Disposes the channel by unsubscribing from it.\n  //  *\n  //  * @memberof Channel\n  //  * @function\n  //  * @returns {void}\n  //  * @instance\n  //  */\n  // dispose() {\n  //   this.unsubscribeAllObsrvers();\n  // }\n}\n\n/**\n * Creates a channel for sending values, errors, and completion signals.\n *\n * @param {string} name - The name of the channel.\n * @returns {Channel} The created channel.\n */\nexport const createChannel = name => {\n  return new Channel(name);\n};\n\n/**\n * Creates a channel for sending values, errors, and completion signals.\n *\n * @returns {Channel} The created channel.\n */\n// export const createChannel = () => {\n//   const channel = new ReplaySubject(1);\n\n//   const _nextFromSuperClass = channel.next.bind(channel);\n\n//   /**\n//    * Send the next value on the channel.\n//    * @param {PublishedValue} value The value to send.\n//    */\n//   channel.next = function (value) {\n//     if (!value.uuid) {\n//       value.uuid = generateUUID();\n//     }\n//     if (!value.time) {\n//       value.time = new Date().getTime();\n//     }\n//     _nextFromSuperClass(value);\n//   };\n//   /**\n//    * Check if the channel has observers.\n//    * @returns  {boolean} True if the channel has observers, false otherwise.\n//    */\n//   channel.hasObservers = function () {\n//     if (this.closed) {\n//       throw new Error();\n//     }\n\n//     return this.observers.length > 0;\n//   };\n\n//   channel.complete = function () {};\n//   /**\n//    * Send an error on the channel.\n//    * @param  {any} error The error to send.\n//    */\n//   channel.error = function (error) {\n//     this.observers.forEach(function (o) {\n//       o.isStopped = false;\n//       o.onError(error);\n//     });\n//   };\n\n//   /**\n//    * Unsubscribe an observer from the channel.\n//    * @param  {Number} index The index of the observer to unsubscribe.\n//    */\n//   channel.unsubscribe = function (index) {\n//     this.observers.splice(index, 1);\n//   };\n\n//   /**\n//    * Unsubscribe all observers from the channel.\n//    */\n//   channel.unsubscribeAll = function () {\n//     this.observers.splice(0, this.observers.length);\n//   };\n\n//   /**\n//    * Clean the channel.\n//    */\n//   channel.clean = function () {\n//     this._buffer = [];\n//     this.observers = [];\n//   };\n\n//   /**\n//    * Dispose the channel.\n//    */\n//   channel.dispose = function () {\n//     this.unsubscribe();\n//   };\n\n//   return channel;\n// };\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst externalEventsCodes = {\n  PARSE_ROUTE: 'parse-route',\n  AFTER_PUBLISH: 'after-publish',\n  NAV_REQUEST: 'nav-request',\n  TEMPLATE_TRANSITION_END: 'template-transition-end',\n  TRACK_EVENT: 'track-event',\n  TEMPLATE_REGISTERED: 'template-registered',\n  ROUTER_BACKSTEP: 'router-backstep',\n  LOG_EVENT: 'log-event',\n};\n\nconst externalEvents = Object.values(externalEventsCodes);\n\n// initialTemplate\n\nconst initialTemplate = 'login';\n\n// pagesPath\n\nconst pagesPath = './pages/';\n\n// render engines\n\nconst renderEngines = {\n  LIT_ELEMENT: 'litElement',\n};\n\nexport const BRIDGE_CHANNEL_PREFIX = '__oc';\n\nexport const Constants = {\n  bridgeChannelPrefix: BRIDGE_CHANNEL_PREFIX,\n  externalEvents,\n  externalEventsCodes,\n  initialTemplate,\n  pagesPath,\n  renderEngines,\n};\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Subscription } from 'rxjs';\nimport { BRIDGE_CHANNEL_PREFIX } from '../constants';\n\n/**\n * @typedef {import('../../types').WCNode} WCNode\n *\n * @typedef {import('../../types').WCSubscription} WCSubscription\n *\n * @typedef {import('../../types').NodeChannelRecord} NodeChannelRecord\n *\n * @typedef {import('./channel').Channel} Channel\n *\n * @typedef {import('../../types').WrappedEventForPublication} WrappedEventForPublication\n *\n * @typedef {import('../../types').WCSubscriptionDetail} WCSubscriptionDetail\n *\n * @typedef {import('../../types').AugmentedFunction} AugmentedFunction\n *\n * @typedef {import('../../types').Binding} Binding\n */\n\n/** @class Subscriptor */\nexport class Subscriptor {\n  /** @param {WCNode} node */\n  constructor(node) {\n    this.node = node;\n    /** @type {WCSubscriptionDetail[]} */\n    this.subscriptions = [];\n    /** @type {WCSubscription} */\n    this.publications = new Subscription();\n    /** @type {NodeChannelRecord} */\n    this.nodeChannelData = {};\n  }\n\n  /**\n   * Indicates if the node has a subscription to a channel.\n   *\n   * @param {Channel} channel - Channel to check\n   * @returns {boolean} True if the node has a subscription to the channel, false otherwise.\n   */\n  hasSubscription(channel) {\n    return this.subscriptions.filter(d => d.channel === channel).length > 0;\n  }\n\n  /**\n   * Publish an event.\n   *\n   * @param {WrappedEventForPublication} WrappedEvent\n   */\n  publish(WrappedEvent) {\n    this.publications.add(WrappedEvent);\n  }\n\n  /**\n   * Retrieves the time interval from the specified channel name.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @returns {number | null} The time interval of the channel.\n   */\n  getTimeFromNode(channelName) {\n    return this.nodeChannelData[channelName].interval;\n  }\n\n  /**\n   * Sets the time interval for a specific channel.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @param {number} time - The time interval to set.\n   */\n  setTimeForNode(channelName, time) {\n    this.nodeChannelData[channelName].interval = time;\n  }\n\n  /**\n   * Returns the time from the given channel.\n   *\n   * @param {Channel} channel - The channel object.\n   * @returns {number} The time from the channel.\n   */\n  getTimeFromChannel(channel) {\n    if (channel?.buffer?.length && channel.buffer.length > 0) {\n      return channel.buffer[0].time;\n    } else {\n      return 1;\n    }\n  }\n\n  /**\n   * Obtiene el ID asociado a un nombre de canal.\n   *\n   * @param {string} channelName - El nombre del canal.\n   * @returns {string | null} - El ID asociado al nombre del canal.\n   */\n  getIdFromNode(channelName) {\n    return this.nodeChannelData[channelName].id;\n  }\n\n  /**\n   * Sets the ID for a specific channel node.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @param {string} id - The ID to set for the channel node.\n   */\n  setIdForNode(channelName, id) {\n    this.nodeChannelData[channelName].id = id;\n  }\n\n  /**\n   * Retrieves the ID from the given channel.\n   *\n   * @param {Object} channel - The channel object.\n   * @returns {string | null} The ID of the channel, or null if the channel is empty.\n   */\n  getIdFromChannel(channel) {\n    // @ts-ignore\n    if (channel.buffer?.length && channel.buffer?.length > 0) {\n      // @ts-ignore\n      return channel.buffer[0].uuid;\n    } else {\n      return null;\n    }\n    // return channel._buffer?.length > 0 ? channel._buffer[0].uuid : null;\n  }\n\n  /**\n   * @param {Channel} channel\n   * @param {AugmentedFunction} fn Callback function to run when a value from a channel changed\n   * @returns {AugmentedFunction}\n   */\n  makeCallbackWithNoReplay(channel, fn) {\n    if (!this.nodeChannelData[channel.name]) {\n      this.nodeChannelData[channel.name] = { interval: null, id: null };\n    }\n\n    const self = this;\n    /**\n     * A function that only runs if the last interval from the channel is more recent than the\n     * node's interval, or if the intervals are the same but the IDs are different or if the node\n     * has no interval.\n     *\n     * @type {AugmentedFunction}\n     */\n    const fnReplayOff = function () {\n      let lastInterval = self.getTimeFromChannel(channel);\n      let nodeInterval = self.getTimeFromNode(channel.name);\n      let lastId = self.getIdFromChannel(channel);\n      let nodeId = self.getIdFromNode(channel.name);\n      if (\n        !nodeInterval ||\n        nodeInterval < lastInterval ||\n        (nodeInterval === lastInterval && nodeId != lastId)\n      ) {\n        self.setTimeForNode(channel.name, lastInterval);\n        if (lastId) {\n          self.setIdForNode(channel.name, lastId);\n        }\n        return fn.apply(/** @type {any} */ self, arguments);\n      }\n      self.setTimeForNode(channel.name, lastInterval);\n    }.bind(self);\n\n    return fnReplayOff;\n  }\n\n  /**\n   * Subscribe to a channel.\n   *\n   * @param {Channel} channel - Channel to subscribe\n   * @param {AugmentedFunction} fn - Callback function to run when a value from a channel changed\n   * @param {boolean} previousState\n   * @param {Binding} bind\n   */\n  subscribe(channel, fn, previousState, bind) {\n    if (!this.hasSubscription(channel)) {\n      let callback = fn;\n      /** @type {WCSubscription} */\n      let subscription;\n      if (previousState === false) {\n        callback = this.makeCallbackWithNoReplay(channel, fn);\n      }\n\n      let pos = this._firstInstanceOfObserver(this.node, channel);\n      if (pos === -1) {\n        /** @type {WCSubscription} */\n        subscription = channel.subscribe(callback);\n      } else {\n        subscription = this.subscriptions[pos].subscription;\n      }\n\n      const subscriptionDetail = {\n        channel,\n        bind,\n        node: this.node,\n        subscription: subscription,\n      };\n\n      this.subscriptions.push(subscriptionDetail);\n    }\n  }\n\n  /**\n   * Remove all active subscriptions.\n   *\n   * @param {Boolean} cleanPrivateChannels\n   */\n  unsubscribe(cleanPrivateChannels) {\n    this.subscriptions.forEach(({ channel, subscription }) => {\n      if (\n        cleanPrivateChannels === true ||\n        !channel.name.match(new RegExp(`\\\\b${BRIDGE_CHANNEL_PREFIX}`))\n      ) {\n        //if (cleanPrivateChannels === true || !channel.name.match(/\\b__bridge_/)) {\n        subscription.unsubscribe();\n      }\n      //}\n    });\n\n    this.publications.unsubscribe();\n  }\n\n  /**\n   * Returns the position of the first occurrence of the observer's node in the channel. If the node\n   * has none observer registered to the channel, it returns -1.\n   *\n   * @param {WCNode} node\n   * @param {Channel} channel\n   * @returns {number}\n   */\n  _firstInstanceOfObserver(node, channel) {\n    return this.subscriptions.findIndex(\n      subscriptionDetail =>\n        channel === subscriptionDetail.channel && node === subscriptionDetail.subscription.node,\n    );\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Taken from string.js npm package\n// https://github.com/jprichardson/string.js\n\n/**\n * Converts a string to dasherized format.\n *\n * @param {string} str - The input string.\n * @returns {string} - The dasherized string.\n */\nexport const dasherize = str =>\n  str\n    .trim()\n    .replace(/[_\\s]+/g, '-')\n    .replace(/([A-Z])/g, '-$1')\n    .replace(/-+/g, '-')\n    .toLowerCase();\n\n/**\n * Converts a string to camelized format.\n *\n * @param {string} str - The input string.\n * @returns {string} - The camelized string.\n */\nexport const camelize = str =>\n  str.trim().replace(/(-|_|\\s)+(.)?/g, (mathc, sep, c) => (c ? c.toUpperCase() : ''));\n\n/**\n * Checks if an object is a plain object.\n *\n * @param {any} obj - The object to check.\n * @returns {boolean} - True if the object is a plain object, false otherwise.\n */\nexport const isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]';\n\n/**\n * Finds a property in an array of objects.\n *\n * @param {string} prop - The property to find.\n * @returns {function(any[]): any[]} - A function that takes an array and returns an array of values\n *   for the given property.\n */\nexport const findPropertyInArray =\n  /** @type {function(string): function(any[]): any[]} */\n  prop => arr => arr.map(findProperty(prop)).flat();\n\n/**\n * Finds a property in an object or nested objects.\n *\n * @param {string} prop - The property to find.\n * @returns {function(Object): any[]} - A function that takes an object and returns an array of\n *   values for the given property.\n */\nexport const findPropertyInObject =\n  /** @type {function(string): function(Object): any[]} */\n  prop => collection =>\n    Object.entries(collection)\n      .map(([k, v]) => (k === prop ? [v] : findProperty(prop)(v)))\n      .flat();\n\n/**\n * Finds a property in an object or nested objects.\n *\n * @param {string} prop - The property to find.\n * @returns {function( any ): any[]} - A function that takes a value and returns an array of values\n *   for the given property.\n */\nexport const findProperty =\n  /** @type {function(string): function( any ): any[]} */\n  prop => v =>\n    isPlainObject(v)\n      ? findPropertyInObject(prop)(v)\n      : Array.isArray(v)\n        ? findPropertyInArray(prop)(v)\n        : [];\n\n/**\n * List of attribute names that are allowed.\n *\n * @type {string[]}\n */\nexport const attributeWhiteList = ['ambient', 'variant', 'disabled'];\n\n/**\n * Sets an attribute on a DOM node.\n *\n * @param {HTMLElement} node - The DOM node.\n * @param {string} attr - The attribute name.\n * @param {string | boolean} value - The attribute value.\n * @returns {void}\n */\nexport const setAttribute = (node, attr, value) => {\n  if (typeof value === 'boolean') {\n    if (value) {\n      node.setAttribute(attr, '');\n    } else {\n      node.removeAttribute(attr);\n    }\n  } else {\n    node.setAttribute(attr, value);\n  }\n};\n\nexport const Utils = {\n  dasherize,\n  camelize,\n  findProperty,\n  attributeWhiteList,\n  setAttribute,\n};\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { attributeWhiteList, setAttribute } from '../utils.js';\n\n/**\n * @typedef {import('../../types/index.js').IndexableHTMLElement} IndexableHTMLElement\n *\n * @typedef {import('../../types/index.js').WCEvent} WCEvent\n *\n * @typedef {import('../component-connector.js').ComponentConnector} ComponentConnector\n */\n\n/**\n * Converts a dash-separated string to camel case.\n *\n * @param {string} input - The input string to convert.\n * @returns {string} The converted camel case string.\n */\nconst _dashToCamelCase = input => {\n  return input.toLowerCase().replace(/-(.)/g, function (match, group1) {\n    return group1.toUpperCase();\n  });\n};\n\n/** Represents a adapter for LitElement components. */\nexport class ElementAdapter {\n  /**\n   * Creates a new instance of LitElementAdapter.\n   *\n   * @param {ComponentConnector} componentConnector - The component connector.\n   */\n  constructor(componentConnector) {\n    this.componentConnector = componentConnector;\n  }\n\n  /**\n   * Checks if the given node is unresolved.\n   *\n   * @param {HTMLElement} node - The node to check.\n   * @returns {boolean} - True if the node is unresolved, false otherwise.\n   */\n  isUnresolved(node) {\n    const isCustomElement = node.tagName.includes('-');\n    const resolved = !!window.customElements.get(node.tagName.toLowerCase());\n\n    return isCustomElement && !resolved;\n  }\n\n  /**\n   * Checks if the given node is an instance of a web component.\n   *\n   * @param {HTMLElement} node - The node to check.\n   * @returns {boolean} - True if the node is an instance, false otherwise.\n   */\n  isInstance(node) {\n    const isCustomElement = node.tagName.includes('-');\n    return isCustomElement && !this.isUnresolved(node);\n  }\n\n  /**\n   * Returns true if the event has reached the node that is listening the event.\n   *\n   * @param {WCEvent} event - The event to check.\n   * @returns {boolean} - True if the event is at the target, false otherwise.\n   */\n  isEventAtTarget(event) {\n    const AT_TARGET_VALUE = Event.AT_TARGET || Event.prototype.AT_TARGET;\n    return event.eventPhase === AT_TARGET_VALUE;\n  }\n\n  /**\n   * Dispatches an action function.\n   *\n   * @param {WCEvent} evt - The event.\n   * @param {IndexableHTMLElement} target - The target object.\n   * @param {Function | string} method - The method to call.\n   */\n  dispatchActionFunction(evt, target, method) {\n    const payload = evt.detail;\n\n    if (typeof method === 'function') {\n      method(payload);\n    } else {\n      if (target[method] && typeof target[method] === 'function') {\n        target[method](payload);\n      }\n    }\n  }\n\n  /**\n   * Dispatches an action property.\n   *\n   * @param {WCEvent} evt - The event.\n   * @param {IndexableHTMLElement} target - The target object.\n   * @param {string} property - The property to set.\n   */\n  dispatchActionProperty(evt, target, property) {\n    const data = this._parseActionInEvent(evt, property, target);\n\n    if (!attributeWhiteList.includes(property) && target[property]) {\n      target[property] = data.value;\n    } else {\n      setAttribute(target, property, data.value);\n    }\n  }\n\n  /**\n   * Gets the property changed name.\n   *\n   * @private\n   * @param {string} name - The name.\n   * @returns {string | undefined} - The property changed name.\n   */\n  _getPropertyChangedName(name) {\n    let propertyName;\n    const EVENT_CHANGED = '-changed';\n\n    if (name.indexOf(EVENT_CHANGED, name.length - EVENT_CHANGED.length) !== -1) {\n      propertyName = name.slice(0, -EVENT_CHANGED.length);\n      propertyName = _dashToCamelCase(propertyName);\n    }\n\n    return propertyName;\n  }\n\n  /**\n   * @typedef {Object} ActionDetail\n   * @property {string} path - The path of the action.\n   * @property {any} value - The value of the action.\n   * @property {string} property - The property of the action.\n   */\n\n  /**\n   * Parses the action in the event.\n   *\n   * @private\n   * @param {WCEvent} evt - The event.\n   * @param {string} targetPath - The target path.\n   * @param {HTMLElement} target - The target object.\n   * @returns {ActionDetail} - The parsed action.\n   */\n  _parseActionInEvent = (evt, targetPath, target) => {\n    // Check if event is because of property changed.\n    let propertyName = this._getPropertyChangedName(evt.type);\n    let value;\n    let path;\n\n    if (propertyName && evt.detail && Object.prototype.hasOwnProperty.call(evt.detail, 'value')) {\n      value = evt.detail.value;\n      targetPath = targetPath || propertyName;\n\n      if (evt.detail.path) {\n        path = evt.detail.path.replace(propertyName, targetPath);\n      } else {\n        path = targetPath;\n      }\n    } else {\n      path = targetPath;\n      value = evt.detail;\n    }\n\n    return {\n      path: path,\n      value: value,\n      property: targetPath,\n    };\n  };\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createChannel } from '../state/index.js';\n\n/** @typedef {import('../../types').Channel} Channel */\n\n/**\n * Represents a Channel Manager that manages channels.\n *\n * @class ChannelManager\n */\nexport class ChannelManager {\n  /** Constructs a new ChannelManager. */\n  constructor() {\n    /**\n     * The collection of channels.\n     *\n     * @type {Object<string, Channel>}\n     */\n    this.channels = {};\n  }\n\n  /**\n   * Gets a channel by name.\n   *\n   * @param {string} name - The name of the channel.\n   * @returns {Channel} The channel with the specified name.\n   */\n  get(name) {\n    var channel = this.channels[name];\n\n    if (!channel) {\n      channel = this.create(name);\n    }\n\n    return channel;\n  }\n\n  /**\n   * Gets a channel by name.\n   *\n   * @param {string} name - The name of the channel.\n   * @returns {Channel} The channel with the specified name.\n   */\n  getUnsafe(name) {\n    return this.channels[name];\n  }\n\n  /**\n   * Creates a channel.\n   *\n   * @param {string} name - The name of the channel.\n   * @returns {Channel} The newly created channel.\n   */\n  create(name) {\n    const channel = createChannel(name);\n    this.channels[name] = channel;\n    return channel;\n  }\n\n  /**\n   * Removes a channel from the collection.\n   *\n   * @param {string} name - The name of the channel to remove.\n   */\n  remove(name) {\n    delete this.channels[name];\n  }\n\n  /**\n   * Gets all channels.\n   *\n   * @returns {Object<string, Channel>} The channels.\n   */\n  getChannels() {\n    return this.channels;\n  }\n\n  /**\n   * Sets all channels.\n   *\n   * @param {Object<string, Channel>} channels - The channels.\n   */\n  setChannels(channels) {\n    this.channels = channels;\n  }\n\n  /** Cleans all channels. */\n  cleanAllChannels() {\n    for (let channelName in this.channels) {\n      if (this.channels.hasOwnProperty(channelName)) {\n        this.channels[channelName].clean();\n      }\n    }\n  }\n\n  /** Removes all channels from the collection. */\n  removeAllChannels() {\n    for (let channelName in this.channels) {\n      if (this.channels.hasOwnProperty(channelName)) {\n        delete this.channels[channelName];\n      }\n    }\n  }\n\n  /**\n   * Checks if a channel with the given name exists.\n   *\n   * @param {string} name - The name of the channel.\n   * @returns {boolean} True if a channel with the given name exists, false otherwise.\n   */\n  has(name) {\n    return this.channels[name] != null;\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fromEvent } from 'rxjs';\nimport { eventManager } from './manager/events.js';\nimport { Subscriptor } from './state/index.js';\nimport { Constants } from './constants.js';\nimport { ElementAdapter } from './adapter/element-adapter.js';\nimport { ChannelManager } from './manager/channel-manager.js';\nimport { BRIDGE_CHANNEL_PREFIX } from './constants.js';\n\n/**\n * @typedef {import('rxjs').Subscription} Subscription;\n *\n * @typedef {import('../types').WCEvent} WCEvent\n *\n * @typedef {import('../types').IndexableHTMLElement} IndexableHTMLElement\n *\n * @typedef {import('rxjs').Observable<WCEvent>} ObservableWCEvent;\n *\n * @typedef {import('../types').AugmentedFunction} AugmentedFunction\n *\n * @typedef {import('../types').Binding} Binding\n *\n * @typedef {import('../types').Channel} Channel\n *\n * @typedef {import('../types').WCNode} WCNode\n *\n * @typedef {import('../types').Connection} Connection\n *\n * @typedef {import('../types').WCSubscription} WCSubscription\n *\n * @typedef {import('../types').WCSubscriptionDetail} WCSubscriptionDetail\n */\n\n/** @constant externalEventsCodes */\nconst { externalEventsCodes } = Constants;\n\n/**\n * Represents a Component Connector that manages subscriptions and publications between components.\n *\n * @class ComponentConnector\n */\nexport class ComponentConnector {\n  /** Creates a new instance of ComponentConnector. */\n  constructor() {\n    /**\n     * The adapter for element.\n     *\n     * @type {ElementAdapter}\n     */\n    this.adapter = new ElementAdapter(this);\n\n    /**\n     * The channel manager used to manage channels.\n     *\n     * @type {ChannelManager}\n     */\n    this.manager = new ChannelManager();\n\n    /**\n     * The map of subscriptors.\n     *\n     * @type {Map<WCNode, Subscriptor>}\n     */\n    this.subscriptors = new Map();\n\n    /**\n     * The regular expression pattern to match bridge channels prefix.\n     *\n     * @type {RegExp}\n     */\n    //this.bridgeChannelsPrefix = /__bridge_(?!ch)/;\n    this.bridgeChannelsPrefix = new RegExp(`${BRIDGE_CHANNEL_PREFIX}_(?!ch)`);\n  }\n\n  /**\n   * Get a subscriptor for the given node. If the subscriptor does not exist, a new one will be\n   * created.\n   *\n   * @param {WCNode} node - The node to get the subscriptor for.\n   * @returns {Subscriptor} The subscriptor for the given node.\n   */\n  getSubscriptor(node) {\n    let subscriptor = this.subscriptors.get(node);\n\n    if (!subscriptor) {\n      subscriptor = new Subscriptor(node);\n      this.subscriptors.set(node, subscriptor);\n    }\n\n    return subscriptor;\n  }\n\n  /**\n   * Add a subscription to a node with a channel.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @param {WCNode} node - The node to add the subscription to.\n   * @param {Binding} bind - The bind object.\n   * @param {boolean} [previousState=false] - The previous state flag. Default is `false`\n   */\n  addSubscription(channelName, node, bind, previousState = false) {\n    const callback = this._wrapCallbackWithNode(node, bind);\n    const channel = this.manager.get(channelName);\n\n    if (channel) {\n      const subscriptor = this.getSubscriptor(node);\n      subscriptor.subscribe(channel, callback, previousState, bind);\n    }\n  }\n\n  /**\n   * Get a channel by name.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @returns {Channel} The channel.\n   */\n  getChannel(channelName) {\n    return this.manager.get(channelName);\n  }\n\n  /**\n   * Get all channels.\n   *\n   * @returns {Object<string, Channel>} The channels.\n   */\n  getChannels() {\n    return this.manager.getChannels();\n  }\n\n  /**\n   * Set the channels.\n   *\n   * @param {Object<string, Channel>} channels - The channels.\n   */\n  setChannels(channels) {\n    this.manager.setChannels(channels);\n  }\n\n  /** Clean all channels. */\n  cleanAllChannels() {\n    this.manager.cleanAllChannels();\n  }\n\n  /**\n   * Update a subscription to a node with a channel.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @param {WCNode} node - The node to update the subscription for.\n   * @param {Binding} bind - The bind object.\n   * @param {boolean} [previousState=false] - The previous state flag. Default is `false`\n   */\n  updateSubscription(channelName, node, bind, previousState = false) {\n    const subscriptor = this.getSubscriptor(node);\n\n    if (\n      this.isActiveBridgeChannel(channelName) ||\n      (!this.isActiveBridgeChannel(channelName) && !this.hasSubscriptions(subscriptor, channelName))\n    ) {\n      const channel = this.manager.get(channelName);\n      const callback = this._wrapCallbackWithNode(node, bind);\n\n      subscriptor.subscribe(channel, callback, previousState, bind);\n    }\n  }\n\n  /**\n   * Wrap a callback function with the given node and bind name.\n   *\n   * @param {WCNode} node - The node to wrap the callback with.\n   * @param {Binding} bindName - The bind name.\n   * @returns {AugmentedFunction} The wrapped callback function.\n   */\n  _wrapCallbackWithNode(node, bindName) {\n    //let cb = this.wrapCallback(node, bindName);\n    //cb.node = node;\n    //return cb;\n    return this.wrapCallback(node, bindName);\n  }\n\n  /**\n   * Wrap a callback function with the given node and bind name.\n   *\n   * @param {IndexableHTMLElement} node - The node to wrap the callback with.\n   * @param {Binding} bindName - The bind name.\n   * @returns {AugmentedFunction} The wrapped callback function. re t urns {function(Event): void} -\n   *   The wrapped callback function that expects an Event parameter and returns void.\n   */\n  wrapCallback(node, bindName) {\n    const _idleCallback = (/** @type IdleRequestCallback */ fn) => {\n      setTimeout(function () {\n        if ('requestIdleCallback' in window) {\n          window.requestIdleCallback(fn);\n        } else {\n          setTimeout(fn, 1);\n        }\n      }, 100);\n    };\n\n    /**\n     * @param {WCEvent} evt - The event.\n     * @returns {void}\n     */\n    const wrappedCallback = evt => {\n      /**\n       * @param {MutationRecord[]} mutationsList - The mutations that were observed.\n       * @param {MutationObserver} observerObject - The MutationObserver instance.\n       * @returns {void}\n       */\n      const checkComponentResolution = (mutationsList, observerObject) => {\n        if (!this.adapter.isUnresolved(node)) {\n          checkDispatchActionType();\n\n          if (observerObject) {\n            observerObject.disconnect();\n          }\n        } else {\n          _idleCallback(checkDispatchActionType);\n        }\n      };\n\n      const checkDispatchActionType = () => {\n        if (typeof bindName === 'function' || typeof node[bindName] === 'function') {\n          this.adapter.dispatchActionFunction(evt, node, bindName);\n        } else {\n          this.adapter.dispatchActionProperty(evt, node, bindName);\n        }\n      };\n\n      if (this.adapter.isUnresolved(node)) {\n        var observer = new MutationObserver(checkComponentResolution);\n        var config = { attributes: false, childList: true, characterData: true };\n        observer.observe(node, config);\n        _idleCallback(checkDispatchActionType);\n      } else {\n        checkDispatchActionType();\n      }\n    };\n\n    // REVIEW: check if this does not override the node property set in the subscribe method\n    Object.defineProperty(wrappedCallback, /** @type {WCNode} */ 'node', {\n      writable: true,\n      configurable: true,\n      enumerable: true,\n    });\n    return wrappedCallback;\n  }\n\n  /**\n   * Check if a node has a publisher for the given channel and bind name.\n   *\n   * @param {Subscriptor} subscriptor - The subscriptor to check.\n   * @param {WCNode} node - The node to check.\n   * @param {string} channelName - The name of the channel.\n   * @param {string} bindName - The bind name.\n   * @returns {boolean} True if the node has a publisher, false otherwise.\n   */\n  _hasPublisher({ publications }, node, channelName, bindName) {\n    return Boolean(\n      (publications._subscriptions || []).find(\n        publication =>\n          publication.node === node &&\n          publication.channelName === channelName &&\n          publication.eventName === bindName,\n      ),\n    );\n  }\n\n  /**\n   * Add a publicator to a node.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @param {WCNode} node - The node to add the publicator to.\n   * @param {string} bindName - The bind name.\n   * @param {Connection | undefined} outConnectionDefinition - The out connection definition.\n   */\n  addPublication(channelName, node, bindName, outConnectionDefinition) {\n    if (this.isBridgeChannel(channelName)) {\n      console.warn(\n        `Forbidden operation. You are trying to write to a private channel (${channelName}).`,\n      );\n    } else {\n      let subscriptor = this.getSubscriptor(node);\n      let hasPublisher = this._hasPublisher(subscriptor, node, channelName, bindName);\n\n      if (!hasPublisher) {\n        let channel = this.manager.get(channelName);\n        subscriptor.publish(this._wrapEvent(node, bindName, channel, outConnectionDefinition));\n      }\n    }\n  }\n\n  /**\n   * Publish a value to the given channel.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @param {Object} value - The value to publish.\n   */\n  publish(channelName, value) {\n    if (this.isBridgeChannel(channelName)) {\n      console.warn(\n        `Forbidden operation. You are trying to write to a private channel (${channelName}).`,\n      );\n    } else {\n      const channel = this.manager.get(channelName);\n      const customEventName = `${channelName}-publish`;\n\n      channel.next(new CustomEvent(customEventName, { detail: value }));\n    }\n  }\n\n  /**\n   * Unsubscribe a node from the given channels.\n   *\n   * @param {string | string[]} channels - The channels to unsubscribe from.\n   * @param {WCNode} node - The node to unsubscribe.\n   */\n  unsubscribe(channels, node) {\n    if (!channels || !node) {\n      return;\n    }\n\n    const normalizedChannels = Array.isArray(channels) ? channels : [channels];\n    const subscriptor = this.subscriptors.get(node);\n    const byChannelName = (/** @type {WCSubscriptionDetail} */ subscription) =>\n      subscription.channel?.name && normalizedChannels.includes(subscription.channel?.name);\n    const filterAndRemove = (/** @type {WCSubscriptionDetail} */ sub) => {\n      if (byChannelName(sub)) {\n        sub.subscription.unsubscribe();\n        return false;\n      }\n      return true;\n    };\n\n    if (!subscriptor) {\n      return;\n    }\n    subscriptor.subscriptions = subscriptor.subscriptions?.filter(filterAndRemove);\n  }\n\n  /**\n   * Unregister a node from pubsub.\n   *\n   * @param {WCNode | undefined} node - The node to unregister.\n   * @param {boolean} cleanPrivateChannels - The private channels to clean.\n   */\n  unregisterComponent(node, cleanPrivateChannels) {\n    if (!node) {\n      return;\n    }\n\n    const subscriptor = this.subscriptors.get(node);\n\n    if (subscriptor) {\n      subscriptor.unsubscribe(cleanPrivateChannels);\n      this.subscriptors.delete(node);\n    }\n  }\n\n  /**\n   * Unregister all subscriptors and clean private channels.\n   *\n   * @param {boolean} cleanPrivateChannels - The private channels to clean.\n   */\n  unregisterAllSubscriptors(cleanPrivateChannels) {\n    this.subscriptors.forEach(s => s.unsubscribe(cleanPrivateChannels));\n\n    this.subscriptors = new Map();\n  }\n\n  /**\n   * Wrap an event with the given node, event name, channel, and connection.\n   *\n   * @param {WCNode} node - The node to wrap the event with.\n   * @param {string} eventName - The event name.\n   * @param {Channel} channel - The channel.\n   * @param {Connection | undefined} connection - The connection definition.\n   * @returns {WCSubscription} The wrapped event function.\n   */\n  _wrapEvent(node, eventName, channel, connection) {\n    const { AFTER_PUBLISH, NAV_REQUEST, ROUTER_BACKSTEP, TRACK_EVENT, LOG_EVENT } =\n      externalEventsCodes;\n\n    /** @type {ObservableWCEvent} */\n    const source = fromEvent(node, eventName);\n\n    /** @type {Subscription} */\n    const wrappedListener = source.subscribe((/** @type {WCEvent} */ event) => {\n      if (!this.adapter.isEventAtTarget(event)) {\n        // If the event bubbles up from a child element:\n        return;\n      }\n\n      channel.next(event);\n      eventManager.emit(AFTER_PUBLISH, event);\n\n      if (connection && connection.link) {\n        const linkObject = Object.assign({}, connection.link);\n\n        if (connection.link.page) {\n          if (connection.link.page.hasOwnProperty('bind')) {\n            linkObject.page = event.detail[connection.link.page.bind];\n          }\n        }\n\n        if (connection.link.cleanUntil) {\n          if (connection.link.cleanUntil.hasOwnProperty('bind')) {\n            linkObject.cleanUntil = event.detail[connection.link.cleanUntil.bind];\n          }\n        }\n\n        eventManager.emit(NAV_REQUEST, {\n          event: event,\n          detail: linkObject,\n        });\n      }\n\n      if (connection && connection.backStep) {\n        eventManager.emit(ROUTER_BACKSTEP, {\n          event: event,\n          detail: {},\n        });\n      }\n\n      if (connection && connection.analytics) {\n        eventManager.emit(TRACK_EVENT, {\n          event: event,\n          detail: connection.analytics,\n        });\n      }\n\n      if (connection && connection.log) {\n        eventManager.emit(LOG_EVENT, {\n          event: event,\n          detail: connection.log,\n        });\n      }\n    });\n\n    Object.defineProperty(wrappedListener, /** @type {WCNode} */ 'node', {\n      value: node,\n      writable: true,\n      configurable: true,\n      enumerable: true,\n    });\n\n    Object.defineProperty(wrappedListener, /** @type {string} */ 'eventName', {\n      value: eventName,\n      writable: true,\n      configurable: true,\n      enumerable: true,\n    });\n\n    Object.defineProperty(wrappedListener, /** @type {string} */ 'channelName', {\n      value: channel.name,\n      writable: true,\n      configurable: true,\n      enumerable: true,\n    });\n\n    Object.defineProperty(wrappedListener, /** @type {Connection} */ 'options', {\n      value: connection,\n      writable: true,\n      configurable: true,\n      enumerable: true,\n    });\n\n    return wrappedListener;\n  }\n\n  /**\n   * Create a new event with the given name and value.\n   *\n   * @param {string} name - The name of the event.\n   * @param {Object} value - The value of the event.\n   * @returns {WCEvent} The created event.\n   */\n  createEvent(name, value) {\n    /** @type {WCEvent} */\n    const evt = new Event(name);\n    evt.detail = { value };\n    return evt;\n  }\n\n  /**\n   * Check if a channel with the given name is an active bridge channel.\n   *\n   * @param {string} name - The name of the channel.\n   * @returns {boolean} True if the channel is an active bridge channel, false otherwise.\n   */\n  isActiveBridgeChannel(name) {\n    if (this.manager.getUnsafe(name)) {\n      return this.isBridgeChannel(name);\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Check if a channel with the given name is a bridge channel.\n   *\n   * @param {string} name - The name of the channel.\n   * @returns {boolean} True if the channel is a bridge channel, false otherwise.\n   */\n  isBridgeChannel(name) {\n    return this.bridgeChannelsPrefix.test(name);\n  }\n\n  /**\n   * Check if the given subscriptor has subscriptions to the given channel.\n   *\n   * @param {Subscriptor} subscriptor - The subscriptor to check.\n   * @param {string} channelName - The name of the channel.\n   * @returns {boolean} True if the subscriptor has subscriptions, false otherwise.\n   */\n  hasSubscriptions(subscriptor, channelName) {\n    return Boolean(subscriptor.subscriptions.find(d => d.channel.name === channelName));\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @typedef {import('../types').QueryParams} QueryParams */\n\n/**\n * Represents a route in a web application.\n *\n * @class Route\n */\nexport class Route {\n  /**\n   * Regular expression to match route parameters in a route pattern.\n   *\n   * @type {RegExp}\n   */\n  static PARAM = /(?::([^/]+))/g;\n  /**\n   * Regular expression to match trailing slashes in a route pattern.\n   *\n   * @type {RegExp}\n   */\n  static TRAILING_SLASHES = /\\/*$/;\n\n  /**\n   * The name of the route.\n   *\n   * @type {string}\n   */\n  name = '';\n  /**\n   * The parameters of the route.\n   *\n   * @type {QueryParams}\n   * @t ype {{ [key: string]: string | number }}\n   */\n  params = {};\n  /**\n   * The patterns of the route.\n   *\n   * @type {string[]}\n   */\n  patterns = [''];\n  /**\n   * The regular expressions derived from the route patterns.\n   *\n   * @type {RegExp[]}\n   */\n  regexps;\n  /**\n   * The page to redirect to.\n   *\n   * @type {string | null}\n   */\n  redirectPage = null;\n  /**\n   * Indicates whether the route is accessible.\n   *\n   * @type {boolean}\n   */\n  isAccessible = true;\n  /**\n   * Indicates whether the route is wildcarded.\n   *\n   * @type {boolean}\n   */\n  isWildcarded = false;\n\n  /**\n   * Creates a new Route instance.\n   *\n   * @param {string} name - The name of the route.\n   * @param {string | string[]} pattern - The pattern(s) of the route.\n   * @param {Function} action - The action to be performed when the route is matched.\n   * @param {boolean} [notFound=false] - Indicates whether the route represents the 404 page.\n   * @param {string | undefined} component - The name of component.\n   *   Default is `false`\n   */\n  constructor(name, pattern, action, notFound = false, component = undefined) {\n    this.name = name;\n    this.patterns = typeof pattern === 'string' ? [pattern] : pattern;\n    this.action = action;\n    this.notFound = notFound;\n    this.component = component;\n    this.regexps = this.patterns.map(p => this._getRegExp(p));\n  }\n\n  /**\n   * Sanitizes a route pattern and returns a regular expression for matching the route.\n   *\n   * @param {string} p - The route pattern.\n   * @returns {RegExp} - The regular expression for matching the route.\n   */\n  _getRegExp(p) {\n    let urlPattern = p;\n    let regex;\n    let trailingSlashesReplacement = '/*';\n    let regExEnding = '$';\n\n    const indexOfWildcard = urlPattern.indexOf('*');\n    if (indexOfWildcard >= 0) {\n      this.isWildcarded = true;\n      urlPattern = urlPattern.substring(0, indexOfWildcard);\n      trailingSlashesReplacement = '/+';\n      regExEnding = '';\n    }\n    let regexpStr = urlPattern\n      .replace(Route.PARAM, '([^/]+)')\n      .replace(Route.TRAILING_SLASHES, trailingSlashesReplacement);\n    return new RegExp('^' + regexpStr + regExEnding);\n  }\n\n  /**\n   * Generates a path for the route using the specified parameters.\n   *\n   * @param {QueryParams | undefined} params - The parameters for generating the path.\n   * @returns {string} - The generated path.\n   */\n  path(params) {\n    params = params || {};\n    this.params = {};\n    /** @type {RegExpExecArray | null} */\n    let parts;\n    let path = this.patterns[0];\n    while ((parts = Route.PARAM.exec(this.patterns[0])) !== null) {\n      path = path.replace(parts[0], '' + params[parts[1]]);\n      this.params[parts[1]] = params[parts[1]];\n    }\n    const queryParams = [];\n    for (let param in params) {\n      if (!this.params.hasOwnProperty(param)) {\n        queryParams.push(param + '=' + encodeURIComponent(params[param]));\n      }\n    }\n    if (queryParams.length) {\n      path += '?' + queryParams.join('&');\n    }\n    return path;\n  }\n\n  /**\n   * Matches the specified path against the route patterns and returns the matching information.\n   *\n   * @param {string} path - The path to match.\n   * @returns {?{\n   *   index: number;\n   *   parts: RegExpExecArray;\n   *   pattern: string;\n   *   regex: RegExp;\n   * }}\n   *   - The matching information, or null if no match is found.\n   */\n  matchPath(path) {\n    let match = null;\n    this.regexps.forEach((re, i) => {\n      let result = path.match(re);\n      if (result) {\n        match = {\n          index: i,\n          regex: this.regexps[i],\n          pattern: this.patterns[i],\n          parts: result,\n        };\n      }\n    });\n    return match;\n  }\n\n  /**\n   * Parses the specified path and extracts the route parameters.\n   *\n   * @param {string} path - The path to parse.\n   */\n  parsePath(path) {\n    let match = this.matchPath(path);\n    this.params = {};\n    this.subroute = undefined;\n    if (match) {\n      let i = 1;\n      let parts;\n      if (match.parts[0] !== match.parts.input) {\n        this.subroute = match.parts.input.substring(match.parts[0].length - 1);\n      }\n      while ((parts = Route.PARAM.exec(match.pattern)) !== null) {\n        this.params[parts[1]] = this._parseParam(match.parts[i]);\n        i++;\n      }\n    }\n  }\n\n  /**\n   * Parses the specified query string and adds the parameters to the route.\n   *\n   * @param {any} query - The query string or object.\n   */\n  parseQuery(query) {\n    this.query = query;\n    for (let queryParam in this.query) {\n      if (this.query.hasOwnProperty(queryParam)) {\n        this.params[queryParam] = this.query[queryParam];\n      }\n    }\n  }\n\n  /**\n   * Checks if the route represents the 404 page.\n   *\n   * @returns {boolean} - True if the route represents the 404 page, false otherwise.\n   */\n  is404() {\n    return this.notFound === true;\n  }\n\n  /**\n   * Checks if a value is a number.\n   *\n   * @private\n   * @param {string} value - The value to check.\n   * @returns {boolean} - True if the value is a number, false otherwise.\n   */\n  _isNumber(value) {\n    return parseInt(value) + '' === value || parseFloat(value) + '' === value;\n  }\n\n  /**\n   * Parses a route parameter and returns it as a string or number.\n   *\n   * @private\n   * @param {string} param - The route parameter to parse.\n   * @returns {string | number} - The parsed route parameter.\n   */\n  _parseParam(param) {\n    return this._isNumber(param) ? +param : param;\n  }\n\n  /** Placeholder method for handling the current route. */\n  handler() {\n    // Overwrite to perform actions with the current route\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @typedef {import('../types').Navigation} Navigation\n *\n * @typedef {import('../types').QueryParams} QueryParams\n *\n * @typedef {import('../types').RoutePage} RoutePage\n */\n\n/** Represents a navigation stack that manages the history of routes/pages. */\nexport class NavigationStack {\n  /** Constructs a new NavigationStack object. */\n  constructor() {\n    /** @type {RoutePage[]} */\n    this.navStack = [];\n    /** @type {{ [key: string]: boolean }} */\n    this.skipNav = {};\n  }\n\n  /**\n   * Gets the length of the navigation stack.\n   *\n   * @returns {number} The length of the navigation stack.\n   */\n  get length() {\n    return this.navStack.length;\n  }\n\n  /**\n   * Adds a skip navigation entry to the navigation stack.\n   *\n   * @param {Navigation} nav - The navigation object.\n   */\n  addSkipNavigation(nav) {\n    if (nav.skipHistory === true || nav.skipHistory === false) {\n      this.skipNav[`${nav.from}:${nav.to}`] = nav.skipHistory;\n    }\n  }\n\n  /**\n   * Reverses a navigation object.\n   *\n   * @param {Navigation} nav - The navigation object to reverse.\n   * @returns {Navigation} The reversed navigation object.\n   */\n  _reverseNavigation(nav) {\n    return {\n      from: nav.to,\n      to: nav.from,\n    };\n  }\n\n  /**\n   * Checks if a navigation is marked as skip navigation.\n   *\n   * @param {Navigation} nav - The navigation object to check.\n   * @returns {boolean} True if the navigation is marked as skip navigation, false otherwise.\n   */\n  isSkipNavigation(nav) {\n    return this.skipNav[`${nav.from}:${nav.to}`] === true;\n  }\n\n  /**\n   * Gets the last navigation object in the navigation stack.\n   *\n   * @returns {Navigation} The last navigation object.\n   */\n  lastNavigation() {\n    const navCount = this.navStack.length;\n    let from;\n    let to;\n    if (navCount === 1) {\n      to = this.navStack[0];\n    } else if (navCount > 1) {\n      to = this.navStack[navCount - 1];\n      from = this.navStack[navCount - 2];\n    }\n    return this.createNavigation(from, to);\n  }\n\n  /**\n   * Creates a route object.\n   *\n   * @param {string} page - The page name.\n   * @param {QueryParams} params - The route parameters.\n   * @returns {RoutePage} The created route object.\n   */\n  createRoute(page, params = {}) {\n    return {\n      page,\n      params,\n    };\n  }\n\n  /**\n   * Creates a navigation object.\n   *\n   * @param {RoutePage | undefined} routeFrom - The route object representing the starting page.\n   * @param {RoutePage | undefined} routeTo - The route object representing the destination page.\n   * @returns {Navigation} The created navigation object.\n   */\n  createNavigation(routeFrom, routeTo) {\n    return {\n      from: routeFrom ? routeFrom.page : undefined,\n      to: routeTo ? routeTo.page : undefined,\n    };\n  }\n\n  /**\n   * Pushes a route object to the navigation stack.\n   *\n   * @param {RoutePage} route - The route object to push.\n   */\n  push(route) {\n    if (!this.top() || this.top()?.page !== route.page) {\n      this.navStack.push(route);\n    }\n  }\n\n  /**\n   * Replaces the top route object in the navigation stack with a new route object.\n   *\n   * @param {RoutePage} route - The new route object.\n   */\n  replace(route) {\n    if (!this.top() || this.top()?.page !== route.page) {\n      this.navStack[this.navStack.length - 1] = route;\n    }\n  }\n\n  /**\n   * Removes and returns the top route object from the navigation stack.\n   *\n   * @returns {RoutePage | undefined} The top route object, or undefined if the navigation stack is\n   *   empty.\n   */\n  pop() {\n    return this.navStack.pop();\n  }\n\n  /**\n   * Returns the top route object from the navigation stack without removing it.\n   *\n   * @returns {RoutePage | undefined} The top route object, or undefined if the navigation stack is\n   *   empty.\n   */\n  top() {\n    return this.navStack.length > 0 ? this.navStack[this.navStack.length - 1] : undefined;\n  }\n\n  /**\n   * Checks if a navigation is a backward navigation.\n   *\n   * @param {Navigation} newNav - The new navigation object.\n   * @returns {boolean} True if the navigation is a backward navigation, false otherwise.\n   */\n  isBackwardNavigation(newNav) {\n    const lastNav = this.lastNavigation();\n    return lastNav && newNav.from === lastNav.to && newNav.to === lastNav.from;\n  }\n\n  /**\n   * Updates the navigation stack based on the given route objects.\n   *\n   * @param {RoutePage} routeFrom - The route object representing the starting page.\n   * @param {RoutePage} routeTo - The route object representing the destination page.\n   * @returns {RoutePage | undefined} The top route object after the update.\n   */\n  update(routeFrom, routeTo) {\n    const nav = this.createNavigation(routeFrom, routeTo);\n    if (this.isBackwardNavigation(nav)) {\n      while (this.isSkipNavigation(this._reverseNavigation(this.lastNavigation()))) {\n        this.pop();\n      }\n      this.pop();\n    } else {\n      this.push(routeTo);\n    }\n    return this.top();\n  }\n\n  /** Clears the navigation stack. */\n  clear() {\n    this.navStack = [];\n  }\n\n  /**\n   * Replaces the top route object in the navigation stack with a new route object, or pushes the\n   * new route object if the navigation stack is empty.\n   *\n   * @param {RoutePage} route - The new route object.\n   */\n  replaceRoute(route) {\n    if (this.navStack.length > 0) {\n      this.navStack[this.navStack.length - 1] = route;\n    } else {\n      this.push(route);\n    }\n  }\n\n  /**\n   * Clears the navigation stack until the specified page is found.\n   *\n   * @param {string} targetPage - The page name to clear until.\n   */\n  clearUntil(targetPage) {\n    if (this.navStack.find(route => route.page === targetPage)) {\n      let currentRoute = null;\n      do {\n        currentRoute = this.navStack.pop();\n      } while (currentRoute && currentRoute.page != targetPage);\n    }\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Route } from './route';\nimport { Subscription, fromEvent, merge } from 'rxjs';\nimport { distinctUntilChanged, map, startWith, filter } from 'rxjs/operators';\nimport { eventManager } from './manager/events';\nimport { NavigationStack } from './navigation-stack';\nimport { Constants } from './constants';\n\n/**\n * @typedef {import('../types').Navigation} Navigation\n *\n * @typedef {import('../types').QueryParams} QueryParams\n *\n * @typedef {import('../types').ParsedRoute} ParsedRoute\n *\n * @typedef {import('../types').RoutePage} RoutePage\n *\n * @typedef {import('./manager/bridge-channels').BridgeChannelManager} BridgeChannelManager\n *\n * @typedef {import('../types').NavigationWithParams} NavigationWithParams\n *\n * @typedef {import('../types').WCEvent} WCEvent\n *\n * @typedef {import('rxjs').TeardownLogic} TeardownLogic;\n *\n * @typedef {import('rxjs').Observable<String>} ObservableString;\n */\n\n/**\n * @constant\n * @type {Subscription}\n */\nconst EMPTY = Subscription.EMPTY;\n/**\n * @constant\n * @type {Constants}\n */\nconst { externalEventsCodes } = Constants;\n\n/** @type {Router | null} */\nlet instance = null;\n/** @type {boolean} */\nlet _useHistory = false;\n/** @type {{} | { [key: string]: Route }} */\nlet _routes = {};\n/** @type {Subscription | null} */\nlet _disposables;\n/** @type {Route} */\nlet _currentRoute;\n/** @type {Route | null} */\nlet _404Route;\n\n/**\n * @class SerialSubscription Mimics behavior of SerialDisposable in RxJS v4, allows to add only\n *   single subscription. If new subscription's added, existing subscription will be unsubscribed.\n *\n *   By design of RxJS v5 it is no longer recommended to manage subscription imperatively vis various\n *   kind of subscription, reason it only have single kind of composite subscription. This\n *   implementation is for interop between existing codebase.\n * @extends {Subscription}\n */\nclass SerialSubscription extends Subscription {\n  constructor() {\n    super();\n    this._currentSubscription = EMPTY;\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this Subscription.\n   *\n   * If there's existing subscription, it'll be unsubscribed and removed.\n   *\n   * @param {() => void} teardown The additional logic to execute on teardown.\n   */\n  add(teardown) {\n    if (this.closed) return;\n    // let newSubscription;\n    // if (typeof teardown === 'function') {\n    //   newSubscription = new Subscription(teardown);\n    // } else {\n    //   newSubscription = new Subscription();\n    // }\n    const newSubscription = new Subscription(teardown);\n\n    if (this._currentSubscription) {\n      this.remove(this._currentSubscription);\n      this._currentSubscription.unsubscribe();\n      this._currentSubscription = EMPTY;\n    }\n\n    this._currentSubscription = newSubscription;\n    super.add(teardown);\n  }\n\n  // add(teardown) {\n  //   if (this.closed) return;\n  //   if (typeof teardown === 'function') teardown = new Subscription(teardown);\n\n  //   if (this._currentSubscription) {\n  //     this.remove(this._currentSubscription);\n  //     this._currentSubscription.unsubscribe();\n  //     this._currentSubscription = null;\n  //   }\n\n  //   super.add((this._currentSubscription = teardown));\n  // }\n}\n\n/**\n * Represents a router that handles navigation and routing in the application. The Router class\n * provides methods for adding routes, matching routes, and handling navigation events. It also\n * supports history API and hash-based navigation.\n *\n * @class Router\n */\nexport class Router {\n  /**\n   * Indicates whether the browser supports the History API.\n   *\n   * @type {boolean}\n   */\n  static SUPPORTS_HISTORY_API = window.history && 'pushState' in window.history;\n  /**\n   * Regular expression pattern used to match and capture route parameters.\n   *\n   * @type {RegExp}\n   */\n  static PARAM = /(?::([^/]+))/g;\n  /**\n   * Regular expression pattern used to match and remove leading slashes from a string.\n   *\n   * @type {RegExp}\n   */\n  static LTRIM_SLASH = /^\\/(\\b)/;\n\n  /**\n   * Regular expression pattern representing an empty string.\n   *\n   * @type {RegExp}\n   */\n  static EMPTY = /^$/;\n\n  /**\n   * Regular expression pattern used to match and remove hash prefixes.\n   *\n   * @type {RegExp}\n   */\n  static HASH_PREFIX = /^#!?\\/*/;\n  /**\n   * Regular expression pattern used to match and remove leading slashes from a path.\n   *\n   * @type {RegExp}\n   */\n  static PATH_PREFIX = /^\\/*/;\n  /**\n   * Indicates whether a navigation is currently in progress.\n   *\n   * @type {boolean}\n   */\n  static isNavigationInProgress = false;\n  /**\n   * Represents the status of a cancelled navigation.\n   *\n   * @type {string}\n   */\n  static cancelledNavigation;\n  /**\n   * Indicates whether the hash is dirty or not.\n   *\n   * @type {boolean}\n   */\n  static hashIsDirty = false;\n  /**\n   * Represents the navigation stack.\n   *\n   * @type {NavigationStack}\n   */\n  navigationStack;\n  /**\n   * The channel manager handles the communication channels in the router. It is responsible for\n   * managing the creation, deletion, and routing of channels.\n   *\n   * @type {BridgeChannelManager | null}\n   */\n  _channelManager = null;\n  /**\n   * The context object for interceptors.\n   *\n   * @type {Object}\n   */\n  interceptorContext = {};\n\n  /**\n   * Represents the constructor of the Router class.\n   *\n   * @class\n   */\n  constructor() {\n    const { TEMPLATE_TRANSITION_END } = externalEventsCodes;\n\n    if (!instance) {\n      instance = this;\n    }\n\n    this.navigationStack = this._createNavigationStack();\n\n    eventManager.on(TEMPLATE_TRANSITION_END, () => {\n      this.isNavigationInProgress = false;\n    });\n\n    return instance;\n  }\n\n  /**\n   * Creates a new navigation stack.\n   *\n   * @returns {NavigationStack} The newly created navigation stack.\n   */\n  _createNavigationStack() {\n    return new NavigationStack();\n  }\n\n  /**\n   * Setter for the useHistory property.\n   *\n   * @param {boolean} value - The value to set for useHistory.\n   */\n  set useHistory(value) {\n    /* istanbul ignore else */\n    if (Router.SUPPORTS_HISTORY_API) {\n      _useHistory = value;\n    }\n  }\n\n  /**\n   * Getter for the useHistory property.\n   *\n   * @returns {boolean} The useHistory object.\n   */\n  get useHistory() {\n    return _useHistory;\n  }\n\n  /**\n   * Setter for the channelManager property.\n   *\n   * @param {BridgeChannelManager} channelManager - The channel manager to be set.\n   */\n  set channelManager(channelManager) {\n    this._channelManager = channelManager;\n  }\n\n  /**\n   * Getter for the channelManager property.\n   *\n   * @returns {BridgeChannelManager | null} The channel manager.\n   */\n  get channelManager() {\n    return this._channelManager;\n  }\n  /**\n   * Setter for the routes property.\n   *\n   * @param {{ [key: string]: Route }} routes - The routes to be set.\n   */\n  set routes(routes) {\n    _routes = routes;\n  }\n\n  /**\n   * Get the routes.\n   *\n   * @returns {{ [key: string]: Route }} The routes.\n   */\n  get routes() {\n    return _routes;\n  }\n\n  /**\n   * Gets the current route.\n   *\n   * @returns {Route} The current route.\n   */\n  get currentRoute() {\n    return _currentRoute;\n  }\n\n  /**\n   * Sets the current route.\n   *\n   * @param {Route} route - The current route.\n   */\n  set currentRoute(route) {\n    _currentRoute = route;\n  }\n\n  /** @param {Route} route */\n  // eslint-disable-next-line no-unused-vars\n  handler(route) {\n    // Overwrite to make something after all matched routes\n  }\n\n  /**\n   * Adds a route to the router.\n   *\n   * @param {string} name - The name of the route.\n   * @param {string | string[]} patterns - The patterns associated with the route.\n   * @param {Function} action - The action to be executed when the route is matched.\n   * @param {boolean} notFound - Indicates whether the route is the 404 page. Default is `false`.\n   * @param {string | undefined} component - The name of component.\n   * @returns {Route} - The newly added route.\n   */\n  addRoute(name, patterns, action, notFound, component) {\n    this.routes[name] = new Route(name, patterns, action, notFound, component);\n    return this.routes[name];\n  }\n\n  /**\n   * Adds routes to the router.\n   *\n   * @param {ParsedRoute | undefined} routes\n   */\n  addRoutes(routes) {\n    if (!routes) {\n      throw new Error('Routes must be defined');\n    }\n    for (let routeName in routes) {\n      if (routes.hasOwnProperty(routeName)) {\n        const { path, action, notFound, component } = routes[routeName];\n        this.addRoute(routeName, path, action, notFound, component);\n      }\n    }\n  }\n\n  /**\n   * Adds skip navigations to the router.\n   *\n   * @param {Navigation[]} skipNavs - The skip navigations to be added.\n   */\n  addSkipNavigations(skipNavs) {\n    for (let i = 0; i < skipNavs.length; i++) {\n      this.navigationStack.addSkipNavigation(skipNavs[i]);\n    }\n  }\n\n  /**\n   * Returns the hash path by replacing the hash prefix and empty values.\n   *\n   * @returns {string} The hash path.\n   */\n  _getHashPath() {\n    return location.hash.replace(Router.HASH_PREFIX, '/').replace(Router.EMPTY, '/');\n  }\n\n  /**\n   * Observes the hash change event and returns an observable that emits the hash path.\n   *\n   * @returns {ObservableString} An observable that emits the hash path.\n   */\n  _observeHashChange() {\n    return fromEvent(window, 'hashchange').pipe(\n      map(this._getHashPath),\n      startWith(this._getHashPath()),\n    );\n  }\n\n  /**\n   * Returns the URL path by replacing the Router.PATH_PREFIX with a forward slash.\n   *\n   * @returns {string} The URL path.\n   */\n  _getURLPath() {\n    return location.pathname.replace(Router.PATH_PREFIX, '/');\n  }\n\n  /**\n   * Observes changes in the browser's state (popstate and pushstate events) and returns an\n   * Observable that emits the URL path whenever a state change occurs.\n   *\n   * @returns {ObservableString} An Observable that emits the URL path on state changes.\n   */\n  _observeStateChange() {\n    return merge(fromEvent(window, 'popstate'), fromEvent(window, 'pushstate')).pipe(\n      map(this._getURLPath),\n      startWith(this._getURLPath()),\n    );\n  }\n\n  /**\n   * Matches the given full path against the defined routes and returns the matching route.\n   *\n   * @param {string} fullPath - The full path to match against the routes.\n   * @returns {Route | undefined} - The matching route object, or undefined if no match is found.\n   */\n  matchRoute(fullPath) {\n    const [path, query] = fullPath.split('?');\n    const queryObject = this._parseQuery(query);\n    for (let routeName in this.routes) {\n      if (this.routes.hasOwnProperty(routeName)) {\n        const route = this.routes[routeName];\n        if ((!route.is404() || route.isAccessible) && route.matchPath(path)) {\n          if (route.isWildcarded) {\n            route.parsePath(fullPath);\n          } else {\n            route.parsePath(path);\n            route.parseQuery(queryObject);\n          }\n          return route;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Parses a query string and returns an object containing key-value pairs.\n   *\n   * @param {string} queryStr - The query string to be parsed.\n   * @returns {QueryParams} - An object containing the parsed key-value pairs.\n   */\n  _parseQuery(queryStr) {\n    /** @type {{ [key: string]: string }} */\n    const params = {};\n    if (queryStr) {\n      // Split into key/value pairs\n      const queries = queryStr.split('&');\n      if (queries) {\n        // Convert the array of strings into an object\n        let key,\n          value,\n          i,\n          len = queries.length;\n        for (i = 0; i < len; i++) {\n          [key, value] = queries[i].split('=');\n          params[key] = decodeURIComponent(value);\n        }\n      }\n    }\n    return params;\n  }\n\n  /**\n   * Sets up the 404 route.\n   *\n   * @returns {Route | null} The 404 route object.\n   */\n  _setup404() {\n    const route404 = Object.values(this.routes).find(route => route.is404()) || null;\n\n    // We check if 404 route have a pattern...\n    if (route404 && route404.patterns.length === 1) {\n      const routeWithSamePattern = this.getRouteWithPattern(route404.patterns[0]);\n\n      route404.redirectPage = route404.name;\n      route404.isAccessible = true;\n    }\n\n    return route404;\n  }\n\n  /**\n   * Returns the route that matches the given pattern.\n   *\n   * @param {string} patternToMatch - The pattern to match against the routes.\n   * @returns {Route | null} - The matching route, or null if no match is found.\n   */\n  getRouteWithPattern(patternToMatch) {\n    for (let routeName in this.routes) {\n      if (this.routes.hasOwnProperty(routeName)) {\n        let route = this.routes[routeName];\n\n        // we only take care about routes with same patterns that aren't the same\n        if (!route.is404() && route.patterns.includes(patternToMatch)) {\n          return route;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Interceptor function that is called during navigation.\n   *\n   * @param {NavigationWithParams} navigation - The navigation object.\n   * @param {Object} context - The context object.\n   * @returns {{ intercept: boolean }} - An object with an 'intercept' property indicating whether\n   *   the navigation should be intercepted.\n   */\n  interceptor(navigation, context) {\n    return { intercept: false };\n  }\n\n  /**\n   * Intercepts the navigation from one route to another.\n   *\n   * @param {RoutePage} routeFrom - The route object representing the current route.\n   * @param {Route} routeTo - The route object representing the target route.\n   * @returns {{\n   *   from: RoutePage;\n   *   to: RoutePage;\n   *   [redirect: string];\n   *   intercept: boolean;\n   * }}\n   *   - The intercepted navigation object.\n   */\n  intercept(routeFrom, routeTo) {\n    const navigation = {\n      from: {\n        page: routeFrom.page,\n        params: routeFrom.params,\n      },\n      to: {\n        page: routeTo.name,\n        path: routeTo.patterns[0],\n        params: routeTo.params,\n      },\n    };\n    return { ...this.interceptor(navigation, this.interceptorContext), ...navigation };\n  }\n\n  /**\n   * Updates the interceptor context with the provided values.\n   *\n   * @param {Object} ctx - The new values to be merged into the interceptor context.\n   */\n  updateInterceptorContext(ctx) {\n    this.interceptorContext = Object.assign({}, this.interceptorContext, ctx);\n  }\n\n  /**\n   * Sets the interceptor context.\n   *\n   * @param {Object} ctx - The context object.\n   */\n  setInterceptorContext(ctx) {\n    this.interceptorContext = Object.assign({}, ctx);\n  }\n\n  /**\n   * Returns the interceptor context.\n   *\n   * @returns {Object} The interceptor context.\n   */\n  getInterceptorContext() {\n    return Object.assign({}, this.interceptorContext);\n  }\n\n  /**\n   * Starts the router and initializes the necessary subscriptions and event listeners.\n   *\n   * @returns {Subscription} The subscription object that can be used to unsubscribe from the\n   *   router.\n   */\n  start() {\n    /* istanbul ignore else */\n    if (!_disposables) {\n      const active = new SerialSubscription();\n\n      _404Route = this._setup404();\n\n      const source = this.useHistory ? this._observeStateChange() : this._observeHashChange();\n\n      const subscription = source.pipe(\n        distinctUntilChanged(),\n        map(this.matchRoute.bind(this)),\n        filter(r => {\n          if (r && r.name === this.cancelledNavigation) {\n            this.cancelledNavigation = undefined;\n            this.isNavigationInProgress = false;\n            if (this.currentRoute.name !== this.navigationStack.top()?.page) {\n              this.navigationStack.push({\n                page: this.currentRoute.name,\n                params: this.currentRoute.params,\n              });\n            }\n            return false;\n          } else return true;\n        }),\n      );\n\n      subscription.forEach(route => {\n        if (!this.hashIsDirty) {\n          if (route) {\n            // const currentRouteName = this.currentRoute ? this.currentRoute.name : undefined;\n            // const currentRouteParams = this.currentRoute ? this.currentRoute.params : undefined;\n            const currentRouteName = this.currentRoute?.name;\n            const currentRouteParams = this.currentRoute?.params;\n            const routeFrom = this.navigationStack.createRoute(\n              currentRouteName,\n              currentRouteParams,\n            );\n            const routeTo = this.navigationStack.createRoute(route.name, route.params);\n            const interceptorResult = this.intercept(routeFrom, route);\n            if (interceptorResult.intercept) {\n              this.isNavigationInProgress = false;\n              if (interceptorResult.redirect) {\n                this.goReplacing(\n                  interceptorResult.redirect.page,\n                  interceptorResult.redirect.params,\n                );\n              } else {\n                this.go(currentRouteName, currentRouteParams, false);\n                this.cancelledNavigation = currentRouteName;\n              }\n              if (this.channelManager) {\n                setTimeout(() => {\n                  const interceptedNavigation = {\n                    from: interceptorResult.from.page,\n                    to: interceptorResult.to.page,\n                  };\n                  this.channelManager?.publishInterceptedNavigation(interceptedNavigation);\n                }, 0);\n              }\n              return;\n            } else {\n              // NavigationStack computes the effective new current based on the skip navigation list\n              // so it can be that the newRoute is different to the route from window.location\n              const newRouteName = this.navigationStack.update(routeFrom, routeTo)?.page;\n              if (newRouteName && newRouteName !== routeTo.page) {\n                this.go(newRouteName, undefined, false);\n                return;\n              }\n            }\n            _currentRoute = route;\n            const disposable = new Subscription(() => this.currentRoute);\n            /** @type {() => void} */\n            const dispose = () => disposable.unsubscribe();\n            active.add(dispose);\n            this.currentRoute.handler();\n            this.handler(this.currentRoute);\n          } else if (_404Route?.redirectPage) {\n            this.goReplacing(_404Route.redirectPage);\n          }\n        } else {\n          this.hashIsDirty = false;\n        }\n      });\n\n      // _disposables = new Subscription(subscription, active);\n      _disposables = active;\n    }\n\n    return _disposables;\n  }\n\n  /** Stops the router and cleans up any resources. */\n  stop() {\n    if (_disposables) {\n      _disposables.unsubscribe();\n      _disposables = null;\n    }\n    this.isNavigationInProgress = false;\n    this.hashIsDirty = false;\n  }\n\n  /** Destroys the router by stopping it and clearing the routes. */\n  destroy() {\n    this.stop();\n    this.routes = {};\n  }\n\n  /**\n   * Returns the resolved path for a given route name and parameters.\n   *\n   * @param {string} routeName - The name of the route.\n   * @param {QueryParams | undefined} params - The parameters for the route.\n   * @returns {string | undefined} The resolved path.\n   */\n  getPath(routeName, params) {\n    const route = this.routes[routeName];\n\n    if (route) {\n      let resolvedPath;\n      const routeWithParams = route.path(params);\n      const idxQueryParams = routeWithParams.indexOf('?');\n      if (idxQueryParams > -1) {\n        const path = routeWithParams.substring(0, idxQueryParams);\n        const queryParams = routeWithParams.substring(idxQueryParams);\n        resolvedPath = path.replace(/\\*/g, '') + queryParams;\n      } else {\n        resolvedPath = routeWithParams.replace(/\\*/g, '');\n      }\n      return resolvedPath;\n    } else {\n      console.error(\n        'Wrong route name: %s, valid route names: %s',\n        routeName,\n        Object.keys(this.routes).join(', '),\n      );\n      return undefined;\n    }\n  }\n\n  /**\n   * Creates a new navigation object.\n   *\n   * @param {string} name - The name of the route to navigate to.\n   * @returns {Navigation} - The navigation object with 'from' and 'to' properties.\n   */\n  newNavigation(name) {\n    return {\n      from: this.currentRoute ? this.currentRoute.name : undefined,\n      to: name,\n    };\n  }\n\n  /**\n   * Reverses the navigation object by swapping the 'from' and 'to' properties.\n   *\n   * @param {Navigation} nav - The navigation object.\n   * @returns {Navigation} - The reversed navigation object.\n   */\n  reverseNavigation(nav) {\n    return {\n      from: nav.to,\n      to: nav.from,\n    };\n  }\n\n  /**\n   * Navigates to a specified route.\n   *\n   * @param {string} name - The name of the route.\n   * @param {QueryParams | undefined} params - The parameters for the route.\n   * @param {boolean} [replace=false] - Whether to replace the current history entry. Default is\n   *   `false`\n   * @param {boolean} [skipHistory=false] - Whether to skip adding the navigation to the history.\n   *   Default is `false`\n   */\n  go(name, params = undefined, replace = false, skipHistory = false) {\n    if (this.isNavigationInProgress) {\n      return;\n    }\n\n    if (skipHistory !== undefined) {\n      const newNav = this.newNavigation(name);\n      const reverseNav = this.reverseNavigation(newNav);\n      reverseNav.skipHistory = skipHistory;\n      this.navigationStack.addSkipNavigation(reverseNav);\n    }\n\n    const sanitizedName = name.replace(Router.LTRIM_SLASH, '');\n    const path = this.getPath(sanitizedName, params);\n    if (path && path !== this._getHashPath()) {\n      this.isNavigationInProgress = true;\n      this.updatePathInBrowser(path, replace);\n    }\n  }\n\n  /**\n   * Navigates back to the previous route in the navigation stack.\n   *\n   * @returns {NavigationWithParams} The navigation object containing the 'from' and 'to' routes.\n   * @throws {Error} If there is no page to go back to.\n   */\n  back() {\n    const navigation = {};\n    if (this.navigationStack.length > 1) {\n      let fromRoute = this.navigationStack.pop();\n      let auxFromRoute = fromRoute;\n      let backRoute = this.getLastRoute();\n\n      while (\n        this.navigationStack.isSkipNavigation({ from: auxFromRoute?.page, to: backRoute?.page }) &&\n        this.navigationStack.length > 1\n      ) {\n        auxFromRoute = this.navigationStack.pop();\n        if (this.navigationStack.length > 0) {\n          backRoute = this.getLastRoute();\n        }\n      }\n\n      const page = backRoute?.page;\n      const params = backRoute?.params;\n\n      navigation.from = fromRoute;\n      navigation.to = backRoute;\n\n      if (page) {\n        this.go(page, params);\n      } else {\n        throw new Error('No page to go back to');\n      }\n    } else {\n      navigation.from = this.getLastRoute();\n      navigation.to = this.getLastRoute();\n    }\n    return navigation;\n  }\n\n  /**\n   * Updates the path in the browser's address bar.\n   *\n   * @param {string} path - The new path to be set in the address bar.\n   * @param {boolean} replace - Indicates whether to replace the current history state or push a new\n   *   one.\n   */\n  updatePathInBrowser(path, replace) {\n    if (this.useHistory) {\n      if (replace) {\n        this.historyReplaceState(path);\n      } else {\n        this.historyPushState(path);\n      }\n    } else {\n      if (replace) {\n        this.locationReplace(path);\n      } else {\n        this.locationHash(path);\n      }\n    }\n  }\n\n  /**\n   * Updates the subroute in the browser.\n   *\n   * @param {string} subroute - The subroute to be added to the current route. It must start with a\n   *   slash (/)\n   */\n  updateSubrouteInBrowser(subroute) {\n    const currentRoute = this.currentRoute;\n    let pathWithSubroute = this.getPath(currentRoute.name, currentRoute.params);\n    if (pathWithSubroute) {\n      if (subroute) {\n        if (pathWithSubroute?.endsWith('/')) {\n          pathWithSubroute = pathWithSubroute.substring(0, pathWithSubroute.length - 1);\n        }\n        pathWithSubroute = pathWithSubroute + subroute;\n      }\n      this.updatePathInBrowser(pathWithSubroute, true);\n      this.hashIsDirty = true;\n    }\n  }\n\n  /**\n   * Replaces the current route with a new route using the specified name and parameters.\n   *\n   * @param {string} name - The name of the route to navigate to.\n   * @param {QueryParams} [params] - The parameters to pass to the new route.\n   */\n  goReplacing(name, params = undefined) {\n    this.go(name, params, true);\n  }\n\n  /**\n   * Reemplaza el estado actual del historial del navegador con una nueva URL.\n   *\n   * @param {string} path - La nueva URL a reemplazar en el historial del navegador.\n   */\n  historyReplaceState(path) {\n    history.replaceState(null, '', path);\n  }\n\n  /**\n   * Pushes a new state to the browser history.\n   *\n   * @param {string} path - The path to push to the history.\n   */\n  historyPushState(path) {\n    history.pushState(null, '', path);\n  }\n\n  /**\n   * Replaces the current location with the specified path.\n   *\n   * @param {string} path - The path to replace the current location with.\n   */\n  locationReplace(path) {\n    location.replace('#!' + path);\n  }\n\n  /**\n   * Sets the location hash with the specified path.\n   *\n   * @param {string} path - The path to set as the location hash.\n   */\n  locationHash(path) {\n    location.hash = '#!' + path;\n  }\n\n  /**\n   * Get last route from stack.\n   *\n   * @returns {RoutePage | undefined} Last route from stack.\n   */\n  getLastRoute() {\n    return this.navigationStack.top();\n  }\n\n  /** Initialize router stack. */\n  init() {\n    this._clearStack();\n  }\n\n  /** Clear the router stack. */\n  _clearStack() {\n    this.navigationStack.clear();\n  }\n\n  /**\n   * Clear the router stack until given page is found on router stack.\n   *\n   * @param {string} targetPage\n   */\n  clearStackUntil(targetPage) {\n    this.navigationStack.clearUntil(targetPage);\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @typedef {import('../types').TemplateSpec} TemplateSpec\n *\n * @typedef {import('../types').TemplateConfig} TemplateConfig\n *\n * @typedef {import('../types').WCNode} WCNode\n *\n * @typedef {import('../types').TemplateNode} TemplateNode\n */\n\n/**\n * @class Template\n *\n *   Represents a template component. A template is a reusable component that can contain other\n *   components.\n */\nexport class Template {\n  /**\n   * Type\n   *\n   * Indicates the type of this component\n   *\n   * @type {String}\n   */\n  type = 'TEMPLATE';\n\n  /**\n   * Creates a new Template instance.\n   *\n   * @param {TemplateSpec} spec - The specification object for the Template.\n   */\n  constructor(spec) {\n    if (spec.node) {\n      /** @type {TemplateNode} */\n      this.node = spec.node;\n    } else if (spec.tagName) {\n      /** @type {TemplateNode} */\n      this.node = document.createElement(spec.tagName);\n    } else {\n      throw new Error('Template must have a node or a tagName');\n    }\n    this.name = '';\n    // /** @type {TemplateNode} */\n    // this.node = spec.node ? spec.node : document.createElement(spec.tagName);\n  }\n\n  /**\n   * Returns the zone node in the template identified by the id.\n   *\n   * @param {String} zoneId - The ID of the zone.\n   * @returns {TemplateNode} - The zone node.\n   */\n  getZone(zoneId) {\n    const curTemplateNode = this.node;\n    /** @type {TemplateNode | null} */\n    let node;\n    if (!zoneId) {\n      node = curTemplateNode;\n    } else {\n      node = curTemplateNode.querySelector('#' + zoneId);\n    }\n    return node || curTemplateNode;\n  }\n\n  /**\n   * Sets the attribute cache in the template node to 'cached' for not loading the template again\n   * the next time the template is used.\n   */\n  cache() {\n    this._setAttribute('state', 'cached');\n  }\n\n  /**\n   * Sets the attribute cache in the template node to 'active' so you can know which of the\n   * templates in html is the actual one.\n   */\n  activate() {\n    this._setAttribute('state', 'active');\n  }\n\n  /**\n   * Sets the attribute cache in the template node to 'inactive' so you can know which of the\n   * templates in html are not the actual one.\n   */\n  deactivate() {\n    this._setAttribute('state', 'inactive');\n  }\n\n  /**\n   * Set given value to corresponding attribute name of current template.\n   *\n   * @private\n   * @param {String} name - Attribute name.\n   * @param {String} value - Attribute value.\n   */\n  _setAttribute(name, value) {\n    const template = this._getTemplate(this.node);\n\n    try {\n      template.setAttribute(name, value);\n    } catch (err) {\n      throw new Error(\n        `${this.node.tagName.toLowerCase()} has no valid template. Template was ${template}`,\n      );\n    }\n  }\n\n  /**\n   * Get given attribute value from the current template.\n   *\n   * @private\n   * @param {String} name - Attribute name.\n   * @returns {String} - Attribute value.\n   */\n  _getAttribute(name) {\n    const template = this._getTemplate(this.node);\n    let attribute = '';\n\n    try {\n      attribute = template.getAttribute(name) || '';\n    } catch (err) {\n      throw new Error(\n        `${this.node.tagName.toLowerCase()} has no valid template. Template was ${template}`,\n      );\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Returns current template based on node type. If it's a routable component (page), we retrieve\n   * the first child element that matches with cells-template. Otherwise, we return directly the\n   * node (cells-template).\n   *\n   * @private\n   * @param {TemplateNode} node - Node for template retrieval.\n   * @returns {TemplateNode} - Associated template from given node.\n   * @r eturns {WCNode} - Associated template from given node.\n   */\n  _getTemplate(node) {\n    const { tagName } = node;\n    const isPage = tagName.toLowerCase().endsWith('-page');\n\n    return isPage ? this._getTemplateFromPage(node) || node : node;\n  }\n\n  /**\n   * Returns the first element from shadowRoot child nodes that matches 'cells-template'.\n   *\n   * @private\n   * @param {TemplateNode} node - First level component that contains cells-template inside\n   *   shadowRoot childNodes.\n   * @returns {TemplateNode | undefined} - Cells template.\n   * @r eturns {WCNode | undefined} - Cells template.\n   */\n  _getTemplateFromPage(node) {\n    const list =\n      node.shadowRoot && node.shadowRoot.childNodes ? node.shadowRoot.childNodes : node.children;\n\n    /** @t ype {WCNode[]} */\n    /** @type {TemplateNode[]} */\n    // @ts-ignore\n    const listOfTemplates = Array.from(list).filter(el => el instanceof HTMLElement);\n    return listOfTemplates.find(\n      el =>\n        el.tagName &&\n        (el.tagName.toLowerCase().indexOf('cells-template') !== -1 ||\n          el.getAttribute('data-cells-type') === 'template'),\n    );\n  }\n\n  /**\n   * Configures the Template with the provided configuration.\n   *\n   * @param {TemplateConfig} config - The configuration object for the Template.\n   */\n  config(config) {\n    const {\n      name,\n      template: { id: templateId, name: templateName },\n    } = config;\n\n    this.name = name;\n    this.node.id = templateId;\n    this.node.name = templateName;\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Template } from '../template';\nimport { eventManager } from './events';\nimport { Constants } from '../constants';\n\n/**\n * @typedef {import('../../types').WCNode} WCNode\n *\n * @typedef {import('../../types').TemplateNode} TemplateNode\n *\n * @typedef {import('../../types').TemplateManagerConfig} TemplateManagerConfig\n *\n * @typedef {import('../../types').TemplateConfig} TemplateConfig\n *\n * @typedef {import('../../types').TemplateSpec} TemplateSpec\n */\n\nconst { externalEventsCodes } = Constants;\n\n/**\n * @class TemplateManager Represents a template manager for Cells. Manages the creation, storage,\n *   and retrieval of templates.\n */\nexport class TemplateManager {\n  /**\n   * The template cache.\n   *\n   * @type {{ [key: string]: Template }}\n   */\n  cache = {};\n\n  /**\n   * The templates collection.\n   *\n   * @type {{ [key: string]: TemplateNode }}\n   */\n  templates = {};\n\n  /**\n   * The name of the currently selected template.\n   *\n   * @type {string}\n   */\n  selected = '';\n\n  /**\n   * The list of template locations.\n   *\n   * @type {string[]}\n   */\n  locations = [];\n\n  /**\n   * The number of templates stored in the cache.\n   *\n   * @type {number}\n   */\n  size = 0;\n\n  /**\n   * The list of fixed templates.\n   *\n   * @type {string[]}\n   */\n  fixedTemplates = ['__cross'];\n\n  /**\n   * Creates a new instance of the TemplateManager class.\n   *\n   * @param {TemplateManagerConfig} config - The configuration options.\n   */\n  constructor(config = {}) {\n    const persistentPages = config.persistentPages || [];\n\n    this.viewLimit = config.viewLimit && config.viewLimit >= 1 ? config.viewLimit : 3;\n    this.fixedTemplates = this.fixedTemplates.concat(persistentPages);\n    this.maxSize = this.viewLimit + this.fixedTemplates.length;\n  }\n\n  /**\n   * Creates a template with the specified name and spec.\n   *\n   * @param {string} name - The name of the template.\n   * @param {TemplateSpec} spec - The template spec. is `false`\n   * @returns {Template} The created template.\n   */\n  createTemplate(name, spec) {\n    let template = this.get(name);\n\n    if (!template) {\n      template = this._createTemplate(name, spec);\n      this._storeTemplate(name, template);\n    }\n\n    return template;\n  }\n\n  /**\n   * Creates a CellsTemplate instance.\n   *\n   * @private\n   * @param {string} name - The name of the template.\n   * @param {TemplateSpec} spec - The template spec.\n   * @returns {Template} The created CellsTemplate instance.\n   */\n  _createTemplate(name, spec) {\n    const cellsTemplate = new Template(spec);\n    const cellsTemplateConfig = this._createTemplateConfig(name);\n\n    cellsTemplate.config(cellsTemplateConfig);\n    return cellsTemplate;\n  }\n\n  /**\n   * Creates a CellsTemplateConfig object.\n   *\n   * @private\n   * @param {string} name - The name of the template.\n   * @returns {TemplateConfig} The created CellsTemplateConfig object.\n   */\n  _createTemplateConfig(name) {\n    return {\n      name: name,\n      template: {\n        id: this.computeTemplateId(name),\n        name: name,\n      },\n    };\n  }\n\n  /**\n   * Stores a template in memory.\n   *\n   * @private\n   * @param {string} name - The name of the template.\n   * @param {Template} template - The template object.\n   */\n  _storeTemplate(name, template) {\n    const { node } = template;\n\n    if (this.size >= this.maxSize) {\n      const olderTemplateToDeallocate = this._getOlderRemovableTemplate();\n      if (olderTemplateToDeallocate) {\n        this.removeTemplate(olderTemplateToDeallocate);\n      } else {\n        console.warn('No space left in template cache for template ', name);\n      }\n    }\n\n    this.locations.push(name);\n    this.cache[name] = template;\n    this.templates[name] = node;\n    this.size++;\n  }\n\n  /**\n   * Gets the older removable template.\n   *\n   * @private\n   * @returns {string | undefined} The name of the older removable template.\n   */\n  _getOlderRemovableTemplate() {\n    let found = false;\n    let olderRemovableTemplate;\n\n    for (let i = 0; !found && i < this.locations.length; i++) {\n      const isNotPersistantPage = this.fixedTemplates.indexOf(this.locations[i]) == -1;\n\n      if (isNotPersistantPage) {\n        olderRemovableTemplate = this.locations[i];\n        found = true;\n      }\n    }\n\n    return olderRemovableTemplate;\n  }\n\n  /**\n   * Gets a template by name.\n   *\n   * @param {string} name - The name of the template.\n   * @returns {Template} The template with the specified name.\n   */\n  get(name) {\n    return this.cache[name];\n  }\n\n  /**\n   * Gets the node of a template by name.\n   *\n   * @param {string} name - The name of the template.\n   * @returns {TemplateNode} The node of the template with the specified name.\n   */\n  getNode(name) {\n    return this.templates[name];\n  }\n\n  /**\n   * Parses a template name.\n   *\n   * @param {string} name - The template name.\n   * @returns {string} The parsed template name.\n   */\n  parseTemplateName(name) {\n    return name;\n  }\n\n  /**\n   * Computes the template ID.\n   *\n   * @param {string} name - The template name.\n   * @returns {string} The computed template ID.\n   */\n  computeTemplateId(name) {\n    return 'cells-template-' + name.replace(/\\./g, '-');\n  }\n\n  /**\n   * Selects a template.\n   *\n   * @fires template-transition-end\n   * @param {string} name - The name of the template.\n   */\n  select(name) {\n    const { TEMPLATE_TRANSITION_END } = externalEventsCodes;\n    const template = this.get(name);\n    const cache = this.cache;\n    let oldPageName;\n\n    for (let tplName in cache) {\n      if (cache.hasOwnProperty(tplName)) {\n        if (tplName === this.selected) {\n          oldPageName = tplName;\n          cache[tplName].deactivate();\n        } else if (name !== tplName) {\n          cache[tplName].cache();\n        }\n      }\n    }\n\n    this.selected = name;\n    template.activate();\n\n    eventManager.emit(TEMPLATE_TRANSITION_END, template);\n  }\n\n  /**\n   * Removes a template by name.\n   *\n   * @param {string} templateName - The name of the template to remove.\n   */\n  removeTemplate(templateName) {\n    if (this.templates[templateName]) {\n      const node = document.querySelector('#' + this.templates[templateName].id);\n      if (!node) {\n        throw new Error(`Template ${templateName} node not found`);\n      }\n      const pos = this.locations.indexOf(templateName);\n      this.locations.splice(pos, 1);\n      if (!node.parentNode) {\n        throw new Error(`Template ${templateName} has no parent node`);\n      }\n      node.parentNode.removeChild(node);\n      delete this.templates[templateName];\n      delete this.cache[templateName];\n      this.size--;\n    }\n  }\n\n  /**\n   * Removes all templates except the initial one and the cross component one.\n   *\n   * @param {string} initialTemplate - The name of the initial template.\n   * @param {string} crossContainerId - The name of the cross component template.\n   */\n  removeTemplates(initialTemplate, crossContainerId) {\n    for (let templateName in this.templates) {\n      if (this.templates.hasOwnProperty(templateName)) {\n        if (templateName !== initialTemplate && templateName !== crossContainerId) {\n          this.removeTemplate(templateName);\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes all children of a template.\n   *\n   * @param {string} templateName - The name of the template.\n   */\n  removeTemplateChildrens(templateName) {\n    const template = this.templates[templateName];\n    if (template) {\n      while (template.firstChild) {\n        template.removeChild(template.firstChild);\n      }\n    }\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Observable, fromEvent } from 'rxjs';\nimport { first } from 'rxjs/operators';\nimport { eventManager } from './events';\nimport { BRIDGE_CHANNEL_PREFIX } from '../constants';\n\n/**\n * @typedef {import('../../types').AugmentedFunction} AugmentedFunction\n *\n * @typedef {import('../../types').Bridge} Bridge\n *\n * @typedef {import('../../types').Channel} Channel\n *\n * @typedef {import('../../types').Navigation} Navigation\n *\n * @typedef {import('../../types').Binding} Binding\n *\n * @typedef {import('../../types').InConnection} InConnection\n *\n * @typedef {import('../../types').OutConnection} OutConnection\n *\n * @typedef {import('../../types').CCSubscriptions} CCSubscriptions\n *\n * @typedef {import('../../types').Route} Route\n *\n * @typedef {import('../../types').RouteData} RouteData\n *\n * @typedef {import('../../types').Router} Router\n *\n * @typedef {import('../state/subscriptor').Subscriptor} Subscriptor\n *\n * @typedef {import('../../types').WCNode} WCNode\n *\n * @typedef {import('../../types').WCSubscription} WCSubscription\n *\n * @typedef {import('../../types').WCSubscriptionDetail} WCSubscriptionDetail\n */\n\n/**\n * @class BridgeChannelManager\n *\n *   Manages the bridge channels for communication between components.\n */\nexport class BridgeChannelManager {\n  /**\n   * Creates a new instance of BridgeChannelManager.\n   *\n   * @param {Bridge} bridge - The bridge instance.\n   */\n  constructor(bridge) {\n    this.componentConnector = bridge.ComponentConnector;\n    this.privateChannels = new Set();\n  }\n\n  /**\n   * Returns the name of the application context channel.\n   *\n   * @returns {string} The application context channel name.\n   */\n  getAppContextChannelName() {\n    return `${BRIDGE_CHANNEL_PREFIX}_app`;\n  }\n\n  /**\n   * Returns the name of the channel that has cancellations of back navigations.\n   *\n   * @returns {string} The cancelled back navigation channel name.\n   */\n  getCancelledBackNavigationChannelName() {\n    return `${BRIDGE_CHANNEL_PREFIX}_cancelled_back_navigation`;\n  }\n\n  /**\n   * Returns the name of the channel that has intercepted navigations.\n   *\n   * @returns {string} The intercepted navigation channel name.\n   */\n  getInterceptedNavigationChannelName() {\n    return `${BRIDGE_CHANNEL_PREFIX}_intercepted_navigation`;\n  }\n\n  /**\n   * Returns the prefix for private channels.\n   *\n   * @returns {string} The private channel prefix.\n   */\n  getPrivateChannelPrefix() {\n    return `${BRIDGE_CHANNEL_PREFIX}_page_`;\n  }\n\n  /**\n   * Returns the prefix for event channels.\n   *\n   * @returns {string} The event channel prefix.\n   */\n  getEventChannelPrefix() {\n    return `${BRIDGE_CHANNEL_PREFIX}_evt_`;\n  }\n\n  /**\n   * Returns the prefix for generic channels.\n   *\n   * @returns {string} The bridge channel prefix.\n   */\n  getBridgeChannelPrefix() {\n    return `${BRIDGE_CHANNEL_PREFIX}_ch_`;\n  }\n\n  /**\n   * Returns the prefix for post message channels.\n   *\n   * @returns {string} The post message channel prefix.\n   */\n  getPostMessageChannelPrefix() {\n    return `${BRIDGE_CHANNEL_PREFIX}_post_message_`;\n  }\n\n  /**\n   * Gets a bridge channel. If the channel doesn't exist, it creates one.\n   *\n   * @param {string} channelName - The name of the channel to retrieve/create.\n   * @returns {Channel} The bridge channel.\n   */\n  getBridgeChannel(channelName) {\n    // return this.componentConnector.manager.get(this.getBridgeChannelPrefix() + channelName);\n    return this.componentConnector.getChannel(this.getBridgeChannelPrefix() + channelName);\n  }\n\n  // /**\n  //  * Gets the idle callback channel.\n  //  *\n  //  * @returns {Observable<boolean>} The idle callback channel.\n  //  */\n  // getIdleCallbackChannel() {\n  //   const idleChannel$ = new Observable(observer => observer.next(true));\n\n  //   return idleChannel$.pipe(first());\n  // }\n\n  /**\n   * Gets the application context channel.\n   *\n   * @returns {Channel} The application context channel.\n   */\n  getAppContextChannel() {\n    // return this.componentConnector.manager.get(this.getAppContextChannelName());\n    return this.componentConnector.getChannel(this.getAppContextChannelName());\n  }\n\n  /**\n   * Gets the cancelled back navigations channel.\n   *\n   * @returns {Channel} The cancelled back navigation channel.\n   */\n  getCancelledBackNavigationChannel() {\n    // return this.componentConnector.manager.get(this.getCancelledBackNavigationChannelName());\n    return this.componentConnector.getChannel(this.getCancelledBackNavigationChannelName());\n  }\n\n  /**\n   * Gets the intercepted navigations channel.\n   *\n   * @returns {Channel} The intercepted navigation channel.\n   */\n  getInterceptedNavigationChannel() {\n    // return this.componentConnector.manager.get(this.getInterceptedNavigationChannelName());\n    return this.componentConnector.getChannel(this.getInterceptedNavigationChannelName());\n  }\n\n  /**\n   * Gets the private channel that corresponds to a page.\n   *\n   * @param {string} pageName - The name of the page.\n   * @returns {Channel} The private channel.\n   */\n  getPrivate(pageName) {\n    const newName = this.getPrivateChannelPrefix() + pageName;\n    // const channel = this.componentConnector.manager.get(newName);\n    const channel = this.componentConnector.getChannel(newName);\n    this.privateChannels.add(newName);\n    return channel;\n  }\n\n  /**\n   * Gets the post message channel for the given event name.\n   *\n   * @param {string} eventName - The name of the event.\n   * @returns {Channel} The post message channel.\n   */\n  getPostMessageChannel(eventName) {\n    const newName = this.getPostMessageChannelPrefix() + eventName;\n\n    // return this.componentConnector.manager.get(newName);\n    return this.componentConnector.getChannel(newName);\n  }\n\n  /** Initializes the application context channel. */\n  initAppContextChannel() {\n    this.getAppContextChannel();\n  }\n\n  /** Initializes the cancelled back navigation channel. */\n  initCancelledBackNavigationChannel() {\n    this.getCancelledBackNavigationChannel();\n  }\n\n  /**\n   * Initializes the private channel for the given page.\n   *\n   * @param {string | undefined} oldPageName - The name of the old page.\n   * @param {string} newPageName - The name of the new page.\n   */\n  initPrivateChannel(oldPageName, newPageName) {\n    this.publishPrivatePageStatus(newPageName, true);\n\n    if (oldPageName) {\n      this.publishPrivatePageStatus(oldPageName, false);\n    }\n  }\n\n  /**\n   * Publishes the status of a page in its private channel.\n   *\n   * @param {string} pageName - The name of the page.\n   * @param {boolean} status - The status of the page.\n   */\n  publishPrivatePageStatus(pageName, status) {\n    const channel = this.getPrivate(pageName);\n    const evt = eventManager.createEvent('page-load', status);\n\n    channel.next(evt);\n  }\n\n  /**\n   * Updates the application context.\n   *\n   * @param {string | undefined} oldPage - The previous current page.\n   * @param {string} newPage - The new current page.\n   * @param {Object} appContext - The application context.\n   * @param {RouteData} currentRoute - The details about the route.\n   */\n  updateAppContext(oldPage, newPage, appContext, currentRoute) {\n    const evt = eventManager.createEvent('app-context', {\n      currentPage: newPage,\n      fromPage: oldPage,\n      interceptorContext: appContext,\n      currentRoute,\n    });\n\n    this.getAppContextChannel().next(evt);\n  }\n\n  /**\n   * Updates the bridge channels.\n   *\n   * @param {string | undefined} oldPage - The previous current page.\n   * @param {string} newPage - The new current page.\n   * @param {Object} appContext - The application context.\n   * @param {RouteData} currentRoute - The details about the route.\n   */\n  updateBridgeChannels(oldPage, newPage, appContext, currentRoute) {\n    this.updateAppContext(oldPage, newPage, appContext, currentRoute);\n    this.initPrivateChannel(oldPage, newPage);\n  }\n\n  /**\n   * Publishes the cancelled back navigation event.\n   *\n   * @param {Navigation} navigation - The navigation details.\n   */\n  publishCancelledBackNavigation(navigation) {\n    const evt = eventManager.createEvent('back-nav-cancelled', navigation);\n\n    this.getCancelledBackNavigationChannel().next(evt);\n  }\n\n  /**\n   * Publishes the intercepted navigation event.\n   *\n   * @param {Navigation} navigation - The navigation details.\n   */\n  publishInterceptedNavigation(navigation) {\n    const evt = eventManager.createEvent('intercepted-navigation', navigation);\n\n    this.getInterceptedNavigationChannel().next(evt);\n  }\n\n  /**\n   * Checks if the given name matches a private channel's name.\n   *\n   * @param {string} name - The name to check.\n   * @returns {boolean} True if the name matches a private channel's name, false otherwise.\n   */\n  isPrivateChannel(name) {\n    return name.indexOf(this.getPrivateChannelPrefix()) === 0;\n  }\n\n  /**\n   * Checks if there's an active private channel with the given name.\n   *\n   * @param {string} name - The name to check.\n   * @returns {boolean} True if there's an active private channel with the given name, false\n   *   otherwise.\n   */\n  isActivePrivateChannel(name) {\n    return this.privateChannels.has(name);\n  }\n\n  /**\n   * Resets all channels, including the private channels. It removes all observers and publications.\n   *\n   * @param {WCNode} mainNode - The main node.\n   * @param {boolean} cleanPrivateChannels - Whether to clean private channels or not.\n   */\n  resetBridgeChannels(mainNode, cleanPrivateChannels) {\n    // const bridgeChannels = Object.keys(this.componentConnector.manager.channels);\n    const bridgeChannels = Object.keys(this.componentConnector.getChannels());\n\n    bridgeChannels.forEach(chnlName => {\n      // let chnl = this.componentConnector.manager.get(chnlName);\n      let chnl = this.componentConnector.getChannel(chnlName);\n      chnl.clean();\n      chnl.unsubscribe();\n    });\n\n    this.componentConnector.unregisterComponent(mainNode, cleanPrivateChannels);\n    this.componentConnector.unregisterAllSubscriptors(cleanPrivateChannels);\n    // this.componentConnector.manager.cleanAllChannels();\n    this.componentConnector.cleanAllChannels();\n  }\n\n  /**\n   * Gets the cross-container and main node connections.\n   *\n   * @param {string} crossContainerId - The ID of the cross-container.\n   * @param {string} mainNodeId - The ID of the main node.\n   * @returns {CCSubscriptions} The cross-container and main node connections.\n   */\n  getCCSubscriptions(crossContainerId, mainNodeId) {\n    /** @type {Subscriptor[]} } */\n    const crossComponents = Array.from(this.componentConnector.subscriptors.values()).filter(\n      c =>\n        // @ts-ignore\n        c.node.parentNode?.id === crossContainerId ||\n        // @ts-ignore\n        c.node.parentNode?.id === mainNodeId ||\n        c.node.id === mainNodeId,\n    );\n\n    /** @type {OutConnection[]} */\n    const outConnections =\n      crossComponents\n        .map(c =>\n          /** @type {WCSubscription[]} */\n          c.publications?._subscriptions?.map((/** @type {WCSubscription} */ s) => {\n            /** @type {OutConnection} */\n            return {\n              channel: s.channelName || '',\n              bind: s.eventName || '',\n              component: c.node,\n              //options: s.options,\n              options: undefined,\n            };\n          }),\n        )\n        .filter(c => c !== undefined)\n        .reduce((acc, cnxs) => acc?.concat(cnxs || []), []) || [];\n\n    /** @type {InConnection[]} */\n    let inConnections = crossComponents\n      .map(\n        /** @type {Subscriptor} */ c =>\n          c.subscriptions?.map((/** @type {WCSubscriptionDetail} */ s) => {\n            /** @type {InConnection} */\n            return {\n              channel: s.channel.name,\n              bind: s.bind,\n              component: c.node,\n            };\n          }),\n      )\n      .filter((/** @type {InConnection[]} */ c) => c !== undefined)\n      .reduce(\n        (/** @type {InConnection[]} */ acc, /** @type {InConnection[]} */ cnxs) => acc.concat(cnxs),\n        [],\n      );\n\n    return { inConnections, outConnections };\n  }\n\n  /**\n   * Initializes the event channels.\n   *\n   * @param {Node} node - The node to listen for events.\n   * @param {string[]} externalEvents - The names of the external events.\n   */\n  initEventChannels(node, externalEvents) {\n    externalEvents.forEach(eventName => {\n      const prefix = this.getEventChannelPrefix();\n      const channelName = prefix + eventName;\n      // const channel = this.componentConnector.manager.get(channelName);\n      const channel = this.componentConnector.getChannel(channelName);\n      const source = fromEvent(node, eventName);\n      source.subscribe(event => channel.next(event));\n    });\n  }\n\n  /**\n   * Subscribes to an event channel.\n   *\n   * @param {HTMLElement} node - The node to subscribe.\n   * @param {string} eventName - The name of the event.\n   * @param {Function} callback - The callback function.\n   */\n  subscribeToEvent(node, eventName, callback) {\n    const prefix = this.getEventChannelPrefix();\n    const channelName = prefix + eventName;\n    const subscriptor = this.componentConnector.getSubscriptor(node);\n    // const channel = this.componentConnector.manager.get(channelName);\n    const channel = this.componentConnector.getChannel(channelName);\n\n    // callback.node = node;\n    const augmentedCallback = callback;\n    Object.defineProperty(augmentedCallback, /** @type {WCNode} */ 'node', {\n      writable: true,\n      configurable: true,\n      enumerable: true,\n    });\n    subscriptor.subscribe(channel, augmentedCallback, false, '');\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { eventManager } from '../manager/events';\nimport { Constants } from '../constants';\n\nconst { externalEventsCodes } = Constants;\n\n/**\n * @typedef {import('../../types').Bridge} Bridge\n *\n * @typedef {import('../../types').WCEvent} WCEvent\n *\n * @typedef {import('./bridge-channels').BridgeChannelManager} BridgeChannelManager\n *\n * @typedef {import('../../types').TemplateManager} TemplateManager\n */\n\n/**\n * Class representing an Action Channel Manager.\n *\n * @class\n */\nexport class ActionChannelManager {\n  /**\n   * Create an Action Channel Manager.\n   *\n   * @class\n   * @param {Bridge} bridge - The bridge object.\n   */\n  constructor(bridge) {\n    this.bridge = bridge;\n    this.ChannelManager = bridge.BridgeChannelManager;\n    this.TemplateManager = bridge.TemplateManager;\n  }\n\n  /** Subscribe to all action channels. */\n  subscribeAll() {\n    this.ChannelManager.getBridgeChannel('config').subscribe((/** @type {WCEvent} */ evt) =>\n      this._configSubscriptor(evt),\n    );\n    this.ChannelManager.getBridgeChannel('locales').subscribe((/** @type {WCEvent} */ evt) =>\n      this._localesSubscriptor(evt),\n    );\n    this.ChannelManager.getBridgeChannel('logout').subscribe((/** @type {WCEvent} */ evt) =>\n      this._logoutSubscriptor(),\n    );\n    this.ChannelManager.getBridgeChannel('interceptor_context').subscribe(\n      (/** @type {WCEvent} */ evt) => this._appContextSubscriptor(evt),\n    );\n  }\n\n  /**\n   * Update a property of the bridge object.\n   *\n   * @param {string} prop - The property to update.\n   * @param {any} value - The new value for the property.\n   */\n  updateProperty(prop, value) {\n    if (this.isAllowedProperty(prop)) {\n      // @ts-ignore\n      this.bridge[prop] = value;\n      // @ts-ignore\n      window.AppConfig && (window.AppConfig[prop] = value);\n    }\n  }\n\n  /**\n   * Check if a property is allowed to be updated.\n   *\n   * @param {string} prop - The property to check.\n   * @returns {boolean} - True if the property is allowed, false otherwise.\n   */\n  isAllowedProperty(prop) {\n    // @ts-ignore\n    return typeof this.bridge[prop] !== 'function';\n  }\n\n  /**\n   * Event handler for the 'config' action channel.\n   *\n   * @private\n   * @param {WCEvent} evt - The event object.\n   */\n  _configSubscriptor(evt) {\n    const { TEMPLATE_REGISTERED } = externalEventsCodes;\n    const selected = this.TemplateManager.selected;\n\n    if (evt.detail) {\n      for (let prop in evt.detail) {\n        if (evt.detail.hasOwnProperty(prop)) {\n          this.updateProperty(prop, evt.detail[prop]);\n        }\n      }\n\n      if (evt.detail.app || evt.detail.pagesPath) {\n        this.TemplateManager.removeTemplates(selected, this.bridge.crossContainerId);\n        eventManager.once(TEMPLATE_REGISTERED, () => this.TemplateManager.removeTemplate(selected));\n      }\n    }\n  }\n\n  /**\n   * Event handler for the 'locales' action channel.\n   *\n   * @private\n   * @param {WCEvent} evt - The event object.\n   */\n  _localesSubscriptor(evt) {\n    // @ts-ignore\n    if (window.I18nMsg && evt.detail && evt.detail.lang) {\n      // @ts-ignore\n      window.I18nMsg.lang = evt.detail.lang;\n    }\n  }\n\n  /**\n   * Event handler for the 'logout' action channel.\n   *\n   * @private\n   */\n  _logoutSubscriptor() {\n    this.bridge.logout();\n  }\n\n  /**\n   * Event handler for the 'interceptor_context' action channel.\n   *\n   * @private\n   * @param {WCEvent} evt - The event object.\n   */\n  _appContextSubscriptor(evt) {\n    const appContext = evt.detail;\n    this.bridge.setInterceptorContext(appContext);\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BRIDGE_CHANNEL_PREFIX } from '../constants';\n\n/**\n * @typedef {import('../../types').Bridge} Bridge\n *\n * @typedef {import('./bridge-channels').BridgeChannelManager} BridgeChannelManager\n *\n * @typedef {import('../component-connector').ComponentConnector} ComponentConnector\n *\n * @typedef {import('../../types').PostMessageEvent} PostMessageEvent\n *\n * @typedef {import('../../types').WrappedEventForPublication} WrappedEventForPublication\n */\n\n/** @class PostMessageManager */\n/** Manages postMessage communication between windows. */\nexport class PostMessageManager {\n  /** @param {Bridge} bridge - The bridge instance. */\n  constructor(bridge) {\n    /**\n     * Indicates whether postMessage is enabled.\n     *\n     * @type {boolean}\n     */\n    this.enabled = false;\n\n    /**\n     * The target origin for postMessage.\n     *\n     * @type {string}\n     */\n    this.postMessageTargetOrigin = '';\n\n    if (!bridge.postMessageTargetOrigin) {\n      this.enabled = false;\n    } else {\n      if (bridge.postMessageTargetOrigin === '*') {\n        this.enabled = false;\n        console.warn(\n          \"For security reasons postMessageTargetOrigin can't be the wildcard '*'. See docs for more info. \",\n        );\n      } else {\n        this.enabled = true;\n        this.postMessageTargetOrigin = bridge.postMessageTargetOrigin;\n      }\n    }\n\n    /**\n     * The component connector instance.\n     *\n     * @type {ComponentConnector}\n     */\n    this.componentConnector = bridge.ComponentConnector;\n\n    /**\n     * The bridge channel manager instance.\n     *\n     * @type {BridgeChannelManager}\n     */\n    this.bridgeChannelManager = bridge.BridgeChannelManager;\n  }\n\n  /**\n   * Handles the postMessage events sent to this window from its parent. It transforms them into\n   * channels [BRIDGE_CHANNEL_PREFIX]_post_message_{your-event-name} including the payload, to do so\n   * the postMessage must be: { \"event\" : \"your-event-name\", \"detail\" : <any> } Creates and listens\n   * to the private channel [BRIDGE_CHANNEL_PREFIX]_ch_send_post_message to send postMessages to\n   * parent window.\n   */\n  setupPostMessages() {\n    if (this.enabled) {\n      window.addEventListener('message', ({ data }) => {\n        if (data.event) {\n          const channel = this.bridgeChannelManager.getPostMessageChannel(data.event);\n          const evt = this.componentConnector.createEvent(data.event, data.detail);\n          channel.next(evt);\n        }\n      });\n      // @ts-ignore\n      this._sendPostMessage({ event: `${BRIDGE_CHANNEL_PREFIX}-ready` });\n      this.bridgeChannelManager\n        .getBridgeChannel('send_post_message')\n        // @ts-ignore\n        .subscribe(evt => this._sendPostMessage(evt.detail));\n    }\n  }\n\n  /**\n   * Sends a postMessage to the parent window.\n   *\n   * @private\n   * @param {PostMessageEvent} evt - The event to be sent.\n   */\n  _sendPostMessage(evt) {\n    window.parent &&\n      window.parent.postMessage(\n        { eventName: evt.event, eventDetail: evt.detail },\n        this.postMessageTargetOrigin,\n      );\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @typedef {import('../../types').Dictionary} Dictionary */\n\n/** Represents an in-memory storage. */\nclass InMemmoryStorage {\n  /**\n   * The dictionary object that stores the key-value pairs.\n   *\n   * @type {Dictionary}\n   */\n  dictionary = {};\n\n  /**\n   * Retrieves the value associated with the specified key.\n   *\n   * @param {string} key - The key to retrieve the value for.\n   * @returns {any} The value associated with the key, or null if the key does not exist.\n   */\n  getItem(key) {\n    return this.dictionary[key] || null;\n  }\n\n  /**\n   * Sets the value for the specified key.\n   *\n   * @param {string} key - The key to set the value for.\n   * @param {any} value - The value to be set.\n   */\n  setItem(key, value) {\n    this.dictionary[key] = value;\n  }\n\n  /**\n   * Removes the value for the specified key.\n   *\n   * @param {string} key - The key to set the value for.\n   */\n  removeItem(key) {\n    delete this.dictionary[key];\n  }\n}\n\n/**\n * Class representing a CellsStorage.\n *\n * @class\n */\nexport class CellsStorage {\n  /**\n   * The prefix for the storage keys.\n   *\n   * @type {string}\n   */\n  prefix = '';\n\n  /**\n   * Indicates whether the storage is persistent or not.\n   *\n   * @type {boolean}\n   */\n  persistent = false;\n\n  /**\n   * The internal storage used when persistent storage is not available.\n   *\n   * @type {InMemmoryStorage}\n   */\n  internalStorage = new InMemmoryStorage();\n\n  /**\n   * Creates an instance of CellsStorage.\n   *\n   * @param {Object} options - The options for the storage.\n   */\n  constructor(options) {\n    Object.assign(this, options);\n\n    if (this.persistent) {\n      this.clear();\n    }\n  }\n\n  /**\n   * Gets the storage object.\n   *\n   * @type {Storage | InMemmoryStorage}\n   */\n  get storage() {\n    let store;\n    try {\n      store = this.persistent ? window.localStorage : window.sessionStorage;\n      store.setItem('_$_', JSON.stringify({}));\n    } catch (error) {\n      store = this.internalStorage;\n    }\n    return store;\n  }\n\n  /**\n   * Gets the value associated with the specified key.\n   *\n   * @param {string} key - The key to retrieve the value for.\n   * @returns {any | null} The value associated with the key.\n   */\n  getItem(key) {\n    return JSON.parse(this.storage.getItem(this.prefix + key));\n  }\n\n  /**\n   * Sets the value associated with the specified key.\n   *\n   * @param {string} key - The key to set the value for.\n   * @param {any} value - The value to set.\n   */\n  setItem(key, value) {\n    this.storage.setItem(this.prefix + key, JSON.stringify(value));\n  }\n\n  /** Clears all the storage items with keys that match the prefix. */\n  clear() {\n    var pattern = new RegExp('^(' + this.prefix + ')');\n\n    for (let key in this.storage) {\n      if (this.storage.hasOwnProperty(key)) {\n        if (pattern.test(key)) {\n          this.storage.removeItem(key);\n        }\n      }\n    }\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CellsStorage } from './storage';\n\nconst CONFIG_STORAGE_PREFIX = '__app_';\nconst CONFIG_STORAGE_KEY = 'config';\n\n/** @typedef {import('./action-channels').ActionChannelManager} ActionChannelManager */\n\n/**\n * Manages the application configuration.\n *\n * @class\n */\nexport class ApplicationConfigManager {\n  /**\n   * Constructs a new ApplicationConfigManager instance.\n   *\n   * @class\n   * @param {Object} options - The options for the ApplicationConfigManager.\n   * @param {ActionChannelManager} options.ActionChannelManager - The ActionChannelManager instance.\n   */\n  constructor({ ActionChannelManager }) {\n    this.ActionChannelManager = ActionChannelManager;\n    this.storage = this._getAppConfigStorage();\n  }\n\n  /**\n   * Returns a new CellsStorage instance for storing the application configuration.\n   *\n   * @private\n   * @returns {CellsStorage} - The CellsStorage instance.\n   */\n  _getAppConfigStorage() {\n    return new CellsStorage({\n      prefix: CONFIG_STORAGE_PREFIX,\n      persistent: false,\n    });\n  }\n\n  /**\n   * Saves the application configuration.\n   *\n   * @param {{ [kwy: string]: any }} config - The configuration object to be saved.\n   */\n  saveAppConfig(config) {\n    /** @type {{ [kwy: string]: any }} */\n    const store = {};\n\n    for (let prop in config) {\n      if (config.hasOwnProperty(prop) && this.ActionChannelManager.isAllowedProperty(prop)) {\n        store[prop] = config[prop];\n      }\n    }\n\n    if (Object.keys(store).length > 0) {\n      this.storage.setItem(CONFIG_STORAGE_KEY, store);\n    }\n  }\n\n  /** Loads the application configuration. */\n  loadAppConfig() {\n    const config = this.storage.getItem(CONFIG_STORAGE_KEY);\n\n    for (let prop in config) {\n      config.hasOwnProperty(prop) && this.ActionChannelManager.updateProperty(prop, config[prop]);\n    }\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CellsStorage } from './storage';\n\nconst CONFIG_STORAGE_PREFIX = '__app_';\nconst CONFIG_STORAGE_KEY = 'state';\n\n/** @typedef {import('../component-connector').ComponentConnector} ComponentConnector */\n\n/** Represents the application state manager. */\nexport class ApplicationStateManager {\n  /**\n   * @param {object} config - The configuration object.\n   * @param {ComponentConnector} config.ComponentConnector - The component connector instance.\n   */\n  constructor({ ComponentConnector }) {\n    this.ComponentConnector = ComponentConnector;\n    this.storage = this._getAppStateStorage();\n  }\n\n  /**\n   * Returns the application state storage.\n   *\n   * @private\n   * @returns {CellsStorage} The application state storage.\n   */\n  _getAppStateStorage() {\n    return new CellsStorage({\n      prefix: CONFIG_STORAGE_PREFIX,\n      persistent: false,\n    });\n  }\n\n  /**\n   * Saves the application state for a specific channel.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @param {any} value - The value to be saved.\n   */\n  saveAppState(channelName, value) {\n    const state = this.storage.getItem(CONFIG_STORAGE_KEY);\n\n    if (state) {\n      state[channelName] = value;\n      this.storage.setItem(CONFIG_STORAGE_KEY, state);\n    }\n  }\n\n  /** Loads the application state from storage and publishes it to the corresponding channels. */\n  loadAppState() {\n    const state = this.storage.getItem(CONFIG_STORAGE_KEY);\n\n    for (let channel in state) {\n      this.ComponentConnector.publish(channel, state[channel]);\n    }\n  }\n}\n", "/*\n * Copyright 2024 Bilbao Vizcaya Argentaria, S.A.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// eslint-disable-next-line no-unused-vars../types\nimport { ComponentConnector } from './component-connector';\nimport { Router } from './router';\n/** @type {EventEmitter} */\nimport { eventManager } from './manager/events';\nimport { TemplateManager } from './manager/template';\nimport { BridgeChannelManager } from './manager/bridge-channels';\nimport { ActionChannelManager } from './manager/action-channels';\nimport { Utils } from './utils';\nimport { Constants } from './constants';\nimport { PostMessageManager } from './manager/post-message';\nimport { ApplicationConfigManager } from './manager/application-config';\nimport { ApplicationStateManager } from './manager/application-state';\nimport { Template } from './template';\nimport { BRIDGE_CHANNEL_PREFIX } from './constants';\n\n/**\n * @typedef {import('../types').CellsConfig} CellsConfig\n *\n * @typedef {import('../types').EventEmitter} EventEmitter\n *\n * @typedef {import('../types').BridgeAPI} BridgeAPI\n *\n * @typedef {import('../types').WCEvent} WCEvent\n *\n * @typedef {import('../types').WCNode} WCNode\n *\n * @typedef {import('../types').Binding} Binding\n *\n * @typedef {import('../types').EventSubscription} EventSubscription\n *\n * @typedef {import('../types').CallBackFunction} CallBackFunction\n *\n * @typedef {import('../types').IndexableHTMLElement} IndexableHTMLElement\n *\n * @typedef {import('../types').TemplateNode} TemplateNode\n *\n * @typedef {import('../types').AugmentedFunction} AugmentedFunction\n *\n * @typedef {import('./route').Route} Route\n *\n * @typedef {import('../types').RouteData} RouteData\n *\n * @typedef {import('../types').ParsedRoute} ParsedRoute\n *\n * @typedef {import('../types').NavigationWithParams} NavigationWithParams\n *\n * @typedef {import('../types').Navigation} Navigation\n *\n * @typedef {import('../types').Connection} Connection\n *\n * @typedef {import('../types').InConnection} InConnection\n *\n * @typedef {import('../types').OutConnection} OutConnection\n *\n * @typedef {import('../types').QueryParams} QueryParams\n *\n * @typedef {import('../types').RouteMap} RouteMap\n *\n * @typedef {import('../types').Channel} Channel\n *\n * @typedef {import('../types').RouteDefinition} RouteDefinition\n *\n * @typedef {import('../types').InterceptorFunction} InterceptorFunction\n */\nconst { dasherize } = Utils;\n\n/**\n * The bridge instance.\n *\n * @type {BridgeAPI | null}\n */\nexport let $bridge = null;\n/**\n * Queue of bridge commands due to delayed instance of bridge and premature execution of commands.\n *\n * @type {{ command: string; parameters: any }[]}\n */\nlet $queueCommands = [];\n\n/**\n * Application´s Configuration object.\n *\n * @type {CellsConfig}\n */\nlet $config;\n\n/**\n * Starts the bridge.\n *\n * @param {CellsConfig} config - The configuration object.\n */\nexport const startApp = function (config) {\n  if (!$bridge) {\n    $config = config;\n    new Bridge(config);\n  }\n  return $bridge;\n};\n\nexport const getConfig = function () {\n  return $config;\n};\n\n/**\n * Enqueues a bridge command due to delayed instance of bridge and premature execution of commands.\n *\n * @param {string} command - The command to be enqueued.\n * @param {any[]} parameters - The parameters to be enqueued.\n */\nexport const enqueueCommand = function (command, parameters) {\n  $queueCommands.push({ command, parameters });\n};\n\n/**\n * Calls a command on the bridge with the provided parameters. If the bridge is not ready, the\n * command is enqueued to be executed later.\n *\n * @param {...any} args - The arguments to pass to the bridge command. The first argument is the\n *   command name, and the rest are the parameters for the command.\n * @returns {any} The result of the bridge command, or undefined if the bridge is not ready.\n * @throws {Error} If the bridge is ready but the command does not exist on the bridge.\n */\nfunction __callBridge(...args) {\n  const [command, ...parameters] = args;\n  let result;\n\n  // cells is ready\n  if ($bridge) {\n    // @ts-ignore\n    if (!$bridge[command]) {\n      throw new Error(`WARNING: Invalid cells bridge command execution: ${command}.`);\n    }\n    // @ts-ignore\n    result = $bridge[command](...parameters);\n    return result;\n  }\n\n  enqueueCommand(command, parameters);\n  return result;\n}\n\n/**\n * Subscribes a node to a specific channel.\n *\n * @param {string} channelName - The name of the channel to subscribe to.\n * @param {Object} node - The node that is subscribing.\n * @param {Function} callback - The function to call when a message is received.\n * @export\n */\nexport function subscribe(channelName, node, callback) {\n  __callBridge('registerInConnection', channelName, node, callback);\n}\n\n/**\n * Unsubscribes a node from specific channels.\n *\n * @param {string[] | string} channels - The channels to unsubscribe from. Can be a single channel\n *   name or an array of channel names.\n * @param {Object} node - The node that is unsubscribing.\n * @export\n */\nexport function unsubscribe(channels, node) {\n  __callBridge('unsubscribe', channels, node);\n}\n\n/**\n * Publishes a value to a specific channel.\n *\n * @param {string} channelName - The name of the channel to publish to.\n * @param {any} value - The value to publish.\n * @param {Object} options - Optional parameters for the publish operation.\n * @export\n */\nexport function publish(channelName, value, options = {}) {\n  __callBridge('publish', channelName, value, options);\n}\n\n/**\n * Registers an event on an HTML element to publish on a specific channel when the event is\n * triggered.\n *\n * @param {string} channelName - The name of the channel to publish to.\n * @param {HTMLElement} htmlElement - The HTML element to register the event on.\n * @param {string} eventName - The name of the event to register.\n * @export\n */\nexport function publishOn(channelName, htmlElement, eventName) {\n  __callBridge('registerOutConnection', channelName, htmlElement, eventName);\n}\n\n/**\n * Navigates to a specific page with optional parameters.\n *\n * @param {string} page - The name of the page to navigate to.\n * @param {Object} params - Optional parameters to pass to the page.\n * @export\n */\nexport function navigate(page, params) {\n  __callBridge('navigate', page, params);\n}\n\n/**\n * Updates the context of the interceptor using the partial context.\n *\n * @param {Object} ctx - The partial context.\n * @export\n */\nexport function updateInterceptorContext(ctx) {\n  __callBridge('updateInterceptorContext', ctx);\n}\n\n/**\n * Resets the context of the interceptor to its default state.\n *\n * @export\n */\nexport function resetInterceptorContext() {\n  __callBridge('resetInterceptorContext');\n}\n\n/**\n * Retrieves the current context of the interceptor.\n *\n * @returns {Object} The current context of the interceptor.\n * @export\n */\nexport function getInterceptorContext() {\n  return __callBridge('getInterceptorContext');\n}\n\n/**\n * Sets the context of the interceptor.\n *\n * @param {Object} ctx - The new context for the interceptor.\n * @export\n */\nexport function setInterceptorContext(ctx) {\n  __callBridge('setInterceptorContext', ctx);\n}\n\n/**\n * Retrieves the current route.\n *\n * @returns {RouteData} The current route.\n * @export\n */\nexport function getCurrentRoute() {\n  return __callBridge('getCurrentRoute');\n}\n\n/**\n * Updates the current subroute.\n *\n * @param {string} subroute - The new subroute.\n * @export\n */\nexport function updateSubroute(subroute) {\n  __callBridge('updateSubroute', subroute);\n}\n\n/**\n * Navigates one step back in the navigation history.\n *\n * @export\n */\nexport function backStep() {\n  __callBridge('backStep');\n}\n\n/**\n * Constants object containing various constant values.\n *\n * @typedef {Object} Constants\n * @property {string} externalEvents - The external events.\n * @property {string} externalEventsCodes - The external event codes.\n * @property {string} initialTemplate - The default initial template.\n * @property {string} pagesPath - The path to the pages.\n * @property {string} renderEngines - The render engines.\n */\nconst {\n  externalEvents,\n  externalEventsCodes,\n  initialTemplate: DEFAULT_INITIAL_TEMPLATE,\n  pagesPath: DEFAULT_PAGES_PATH,\n  renderEngines,\n} = Constants;\n\n/** @type {Object<string, Channel>} */\nconst globalChannel = {};\n\n/** Class representing the CellsBridge. */\nexport class Bridge {\n  /**\n   * Pages Cache\n   *\n   * Saves page definitions into localstorage.\n   *\n   * @type {Boolean}\n   */\n  cache = true;\n  /**\n   * PubSub Context\n   *\n   * 'global' => Notifies all components of all bridge instances. 'local' => Notifies components\n   * created by the current bridge instance.\n   *\n   * @type {String}\n   */\n  channel = 'global';\n\n  /**\n   * Cross container node Id\n   *\n   * @type {String}\n   */\n  crossContainerId = '__cross';\n  /**\n   * Prints debug info\n   *\n   * @type {Boolean}\n   */\n  debug = true;\n  /**\n   * Proactive Cache. Loads future pages definition.\n   *\n   * @type {Boolean}\n   */\n  preCache = false;\n\n  /**\n   * Prefix for LocalStorage keys\n   *\n   * @type {String}\n   */\n  storagePrefix = `${BRIDGE_CHANNEL_PREFIX}-`;\n\n  /**\n   * Lib version.\n   *\n   * @type {string}\n   */\n  version = '__VERSION__';\n  /**\n   * Max number of views\n   *\n   * Keeps this number of template alive.\n   *\n   * @type {Number}\n   */\n  viewLimit = 1000;\n  /**\n   * The name of the initial template that gets rendered\n   *\n   * @type {String}\n   */\n  initialTemplate = DEFAULT_INITIAL_TEMPLATE;\n  /**\n   * The node where the template will be rendered\n   *\n   * @type {WCNode | null}\n   */\n  __mainNodeElement = null;\n\n  /**\n   * The node's id where the template will be rendered.\n   *\n   * @type {String}\n   */\n  mainNode;\n\n  /**\n   * Events to expose\n   *\n   * @type {string[]}\n   */\n  externalEvents = externalEvents;\n\n  /**\n   * The path to the folder that contains the components that renders a route.\n   *\n   * @type {String}\n   */\n  pagesPath = DEFAULT_PAGES_PATH;\n\n  /**\n   * Listener for navigation requests.\n   *\n   * @type {(info: any) => void}\n   */\n  navRequestListener;\n\n  /** @type {ComponentConnector} */\n  ComponentConnector;\n\n  /** @type {TemplateManager} */\n  TemplateManager;\n\n  /** @type {Router} */\n  Router;\n\n  /** @type {BridgeChannelManager} */\n  BridgeChannelManager;\n\n  /** @type {ActionChannelManager} */\n  ActionChannelManager;\n\n  /** @type {PostMessageManager} */\n  PostMessageManager;\n\n  /** @type {ApplicationConfigManager} */\n  ApplicationConfigManager;\n\n  /** @type {ApplicationStateManager} */\n  ApplicationStateManager;\n\n  /** @type {InterceptorFunction} */\n  interceptor;\n\n  /** @type {Navigation[]} */\n  skipNavigations;\n\n  /** @type {EventSubscription[]} */\n  eventSubscriptions;\n\n  /** @type {string} */\n  postMessageTargetOrigin;\n\n  /** @type {string[]} */\n  commonPages;\n\n  /** @param {CellsConfig} config */\n  constructor(config) {\n    if (config && typeof config == 'object') {\n      Object.assign(this, config);\n    }\n\n    if (!this.mainNode) {\n      console.warn('You should indicate the main node of your app');\n    }\n\n    this._initializeManagers();\n\n    this._initializeDebug();\n    this._initializeRouter();\n\n    this._initializeBridgeStatus();\n    this._initializeEventListeners();\n\n    this.PostMessageManager.setupPostMessages();\n\n    this._initCrossComponents();\n    this._plugExternalEvents();\n\n    this._lazyLoadPages(this.commonPages || []);\n  }\n\n  /** Initialize managers and conectors */\n  _initializeManagers() {\n    /** @type {ComponentConnector} */\n    this.ComponentConnector = new ComponentConnector();\n\n    /** @type {TemplateManager} */\n    this.TemplateManager = new TemplateManager(this);\n\n    /** @type {Router} */\n    this.Router = new Router();\n\n    /** @type {BridgeChannelManager} */\n    this.BridgeChannelManager = new BridgeChannelManager(this);\n\n    /** @type {ActionChannelManager} */\n    this.ActionChannelManager = new ActionChannelManager(this);\n\n    /** @type {PostMessageManager} */\n    this.PostMessageManager = new PostMessageManager(this);\n\n    /** @type {ApplicationConfigManager} */\n    this.ApplicationConfigManager = new ApplicationConfigManager(this);\n\n    /** @type {ApplicationStateManager} */\n    this.ApplicationStateManager = new ApplicationStateManager(this);\n\n    if (this.channel === 'global') {\n      // this.ComponentConnector.manager.channels = globalChannel;\n      this.ComponentConnector.setChannels(globalChannel);\n    }\n  }\n\n  /** Initialize debug mode * */\n  _initializeDebug() {\n    if (this.debug) {\n      $bridge = this;\n      // @ts-ignore\n      window.$bridge = $bridge;\n    } else {\n      $bridge = {\n        // bridge\n        logout: () => this.logout(),\n        subscribeToEvent: (/** @type {string} */ eventName, /** @type {Function} */ callback) =>\n          this.subscribeToEvent(eventName, callback),\n        registerInConnection: (\n          /** @type {string} */ channel,\n          /** @type {WCNode} */ node,\n          /** @type {Function} */ callback,\n        ) => this.registerInConnection(channel, node, callback),\n        unsubscribe: (/** @type {string | string[]} */ channels, /** @type {WCNode} */ node) =>\n          this.unsubscribe(channels, node),\n        registerOutConnection: (\n          /** @type {string} */ channel,\n          /** @type {WCNode} */ node,\n          /** @type {string} */ bindName,\n          /** @type {Connection} */ options,\n        ) => this.registerOutConnection(channel, node, bindName, options),\n        publish: (\n          /** @type {string} */ channel,\n          /** @type {any} */ value,\n          /** @type {{ sessionStorage: boolean } | undefined} */ options,\n        ) => this.publish(channel, value, options),\n        updateSubroute: (/** @type {string} */ subroute) => this.updateSubroute(subroute),\n        getCurrentRoute: () => this.getCurrentRoute(),\n        navigate: (/** @type {string} */ page, /** @type {QueryParams} */ params) =>\n          this.navigate(page, params),\n        updateApplicationConfig: (\n          /** @type {any} */ config,\n          /** @type {{ sessionStorage: boolean }} */ options,\n        ) => this.updateApplicationConfig(config, options),\n\n        // router interceptor\n        updateInterceptorContext: (/** @type {Object} */ ctx) => this.updateInterceptorContext(ctx),\n        resetInterceptorContext: () => this.resetInterceptorContext(),\n        getInterceptorContext: () => this.getInterceptorContext(),\n        setInterceptorContext: (/** @type {Object} */ ctx) => this.setInterceptorContext(ctx),\n      };\n    }\n  }\n\n  /** Initializate route * */\n  _initializeRouter() {\n    if (this.interceptor && typeof this.interceptor === 'function') {\n      this.Router.channelManager = this.BridgeChannelManager;\n      this.Router.interceptor = this.interceptor;\n    }\n\n    this.Router.handler = () => this.routeHandler();\n\n    if (Array.isArray(this.routes)) {\n      this.routes = this._parseRoutes(this.routes);\n    }\n    this.Router.addRoutes(this.routes);\n\n    if (this.skipNavigations && this.skipNavigations.length > 0) {\n      for (let i = 0; i < this.skipNavigations.length; i++) {\n        this.skipNavigations[i].skipHistory = true;\n      }\n      this.Router.addSkipNavigations(this.skipNavigations);\n    }\n\n    this.Router.start();\n  }\n\n  /** Initializate state and context * */\n  _initializeBridgeStatus() {\n    this.BridgeChannelManager.initAppContextChannel();\n    this.BridgeChannelManager.getCancelledBackNavigationChannel();\n    this.BridgeChannelManager.getInterceptedNavigationChannel();\n    this.ActionChannelManager.subscribeAll();\n\n    this._executePendingBridgeQueue();\n    this.ApplicationConfigManager.loadAppConfig();\n    this.ApplicationStateManager.loadAppState();\n  }\n\n  /** Initialize listeners * */\n  _initializeEventListeners() {\n    const { NAV_REQUEST, ROUTER_BACKSTEP } = externalEventsCodes;\n\n    this.navRequestListener = info => {\n      if (this.Router.hashIsDirty) {\n        window.location.hash = '#!';\n      }\n      const { event, detail: navigationDetail } = info;\n      let { page, params, skipHistory, cleanUntil, replace = false, paramPage } = navigationDetail;\n\n      /** @type {{ [key: string]: any }} */\n      let p = {};\n\n      if (!page && paramPage && event.detail) {\n        page = event.detail[paramPage];\n      }\n      if (event.detail && params) {\n        for (let param in params) {\n          if (event.detail.hasOwnProperty(param)) {\n            p[params[param]] = event.detail[param];\n          }\n        }\n      }\n\n      if (cleanUntil) {\n        this.Router.clearStackUntil(cleanUntil);\n      }\n\n      this.Router.go(page, p, replace, skipHistory);\n    };\n\n    eventManager.on(NAV_REQUEST, this.navRequestListener);\n    eventManager.on(ROUTER_BACKSTEP, this.handleBack.bind(this));\n  }\n\n  /**\n   * Updates the interceptor context.\n   *\n   * @param {Object} ctx - The interceptor context.\n   */\n  updateInterceptorContext(ctx) {\n    this.Router.updateInterceptorContext(ctx);\n  }\n\n  /** Resets the interceptor context by setting it to an empty object. */\n  resetInterceptorContext() {\n    this.Router.setInterceptorContext({});\n  }\n\n  /**\n   * Returns the interceptor context.\n   *\n   * @returns {Object} The interceptor context.\n   */\n  getInterceptorContext() {\n    return this.Router.getInterceptorContext();\n  }\n\n  /**\n   * Sets the interceptor context.\n   *\n   * @param {Object} ctx - The interceptor context.\n   */\n  setInterceptorContext(ctx) {\n    this.Router.setInterceptorContext(ctx);\n  }\n\n  /**\n   * Performs the go back action. This method is overriden by the CellsNativeBridge\n   *\n   * @returns {NavigationWithParams} The executed navigation, an object with properties:\n   */\n  goBack() {\n    return this.Router.back();\n  }\n\n  /**\n   * This method is executed when the event router-backstep is fired. It calls the hook method for\n   * handling backward navigations and if that method allows the continuation, it does the\n   * navegation. Otherwise it will cancel the navigation and publish the response in the channel\n   * [BRIDGE_CHANNEL_PREFIX]_cancelled_back_navigation.\n   */\n  handleBack() {\n    this.goBack();\n  }\n\n  /**\n   * Execute queued bridge commands due to delayed instance of bridge and premature execution of\n   * commands.\n   */\n  _executePendingBridgeQueue() {\n    /** @type {{ command: string; parameters: any }[]} */\n    let cellsBridgeQueue;\n    cellsBridgeQueue = $queueCommands;\n    if (Array.isArray(cellsBridgeQueue)) {\n      cellsBridgeQueue.forEach(({ command, parameters }) => {\n        const queuedCommand = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), command);\n\n        if (!queuedCommand) {\n          console.log(`WARNING: Invalid cells bridge command execution: ${command} (QUEUE).`);\n          return;\n        }\n        /** @type {Function} */\n        const queuedCommandFunction = queuedCommand.value;\n\n        console.log(`Executing queued command ${command}.`);\n        queuedCommandFunction.apply(this, parameters);\n      });\n      $queueCommands = [];\n    }\n  }\n\n  /**\n   * Dispatches a custom event with the given name and payload.\n   *\n   * @param {string} name - The name of the event.\n   * @param {any} payload - The payload to be attached to the event.\n   * @throws {Error} If the defined main node does not exist.\n   */\n  _dispatchEvent(name, payload) {\n    const mainNode = this.getMainNode();\n    if (!mainNode) {\n      throw new Error('The defined main node does not exist');\n    }\n    const event = payload ? new CustomEvent(name, { detail: payload }) : new CustomEvent(name);\n\n    mainNode.dispatchEvent(event);\n  }\n\n  /** Plugs external events to the main node. */\n  _plugExternalEvents() {\n    let len = this.externalEvents.length;\n    let mainNode = this.getMainNode();\n\n    if (mainNode) {\n      for (let i = 0; i < len; i++) {\n        const eventName = this.externalEvents[i];\n\n        eventManager.on(eventName, (/** @type {Function} */ data) => {\n          this._dispatchEvent(eventName, data);\n        });\n      }\n      this._initEventChannels();\n    } else {\n      console.warn('The defined main node does not exist');\n    }\n  }\n\n  /** Initializes the event channels for the bridge. */\n  _initEventChannels() {\n    let mainNode = this.getMainNode();\n    this.BridgeChannelManager.initEventChannels(mainNode, this.externalEvents);\n    this._addInitialSubscribersToEvents();\n  }\n\n  /** Adds initial subscribers to events. If there are event subscriptions, it subscribes to them. */\n  _addInitialSubscribersToEvents() {\n    if (this.eventSubscriptions && this.eventSubscriptions.length > 0) {\n      this._subscribeToEvents(this.eventSubscriptions);\n    }\n  }\n\n  /**\n   * Subscribes to multiple events.\n   *\n   * @param {Object[]} eventSubscriptions - An array of event subscriptions.\n   * @param {string} eventSubscriptions[].event - The event to subscribe to.\n   * @param {Function} eventSubscriptions[].callback - The callback function to be executed when the\n   *   event is triggered.\n   */\n  _subscribeToEvents(eventSubscriptions) {\n    eventSubscriptions.forEach(subscription => {\n      const { event, callback } = subscription;\n\n      this.subscribeToEvent(event, callback);\n    });\n  }\n\n  /**\n   * Initialization of cross components container. Check if cross component container exists.\n   * Otherwise, it will be created.\n   */\n  _initCrossComponents() {\n    const crossContainerTemplateId = this.TemplateManager.computeTemplateId(this.crossContainerId);\n    let crossContainer = this.TemplateManager.get(crossContainerTemplateId);\n    const crossContainerElement = document.getElementById(crossContainerTemplateId);\n\n    // no cross container registered on memory\n    if (!crossContainer) {\n      if (!crossContainerElement) {\n        // no html element for cross container, we build it from scratch\n        crossContainer = this.TemplateManager.createTemplate(this.crossContainerId, {\n          tagName: 'div',\n        });\n        document.body.appendChild(crossContainer.node);\n      } else {\n        // html element found. we register it\n        this.usingDeclarativeCrossContainer = true;\n        this.TemplateManager.createTemplate(this.crossContainerId, {\n          node: crossContainerElement,\n        });\n      }\n    }\n  }\n\n  /**\n   * Determines if the given zone is inside a layout.\n   *\n   * @param {string} zone - The zone to check.\n   * @returns {boolean} - True if the zone is inside a layout, false otherwise.\n   */\n  _insideLayout(zone) {\n    return zone != undefined && zone.split('.').length === 2;\n  }\n\n  /**\n   * Creates a page from a web component.\n   *\n   * @param {string} name - The name of the route.\n   * @param {string | undefined} componentRoute - The name of the web component.\n   * @returns {Promise<void>} A promise that resolves when the page is created.\n   */\n  createPageFromWebComponent(name, componentRoute) {\n    const componentName = componentRoute || `${name}-page`;\n    const component = this.TemplateManager.getNode(componentName);\n\n    this.BridgeChannelManager.getPrivate(name);\n\n    const isUnresolved = (/** @type {TemplateNode} */ node) => {\n      const isCustomElement = node.tagName.includes('-');\n      const resolved = !!window.customElements.get(node.tagName.toLowerCase());\n      // const resolved = node.updateComplete instanceof Promise && typeof node.render === 'function';\n\n      return isCustomElement && !resolved;\n    };\n\n    if (!component) {\n      const template = this.TemplateManager.createTemplate(name, {\n        tagName: componentName,\n      });\n\n      if (isUnresolved(template.node)) {\n        if (this.loadCellsPage) {\n          // (loadCellsPage) Guard for compatibilty with Cells CLI<3.2\n          return this.loadCellsPage(name);\n        }\n      }\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Id for template node\n   *\n   * @param {String} name Template name\n   * @returns {String}\n   */\n  computeTemplateId(name) {\n    return 'cells-template-' + name.replace(/\\./g, '-');\n  }\n\n  /** Prints debug information about the bridge. */\n  printDebugInfo() {\n    const getColor = function (/** @type {any} */ option, /** @type {string} */ color) {\n      const hexColor = option ? color : '#b0bec5';\n      return `background:${hexColor}; color:#fff; padding:2px 4px; margin-right: 5px;`;\n    };\n    console.log(\n      `%cbridge version: ${this.version} %ccache: ${this.cache}`,\n      getColor(this.version, '#003f8d'),\n      getColor(this.cache, '#0093e2'),\n    );\n  }\n\n  /** Handles the routing logic and updates the page accordingly. */\n  routeHandler() {\n    const { PARSE_ROUTE } = externalEventsCodes;\n    const route = this.Router.currentRoute;\n\n    eventManager.emit(PARSE_ROUTE, route);\n\n    // 2. Load a new page when route changes\n    this._handleRouteLoading(route);\n\n    // 3. Publish URL params to global params.\n    for (let param in route.params) {\n      const evt = eventManager.createEvent(dasherize(param) + '-changed', route.params[param]);\n      this.ComponentConnector.getChannel(param).next(evt);\n    }\n  }\n\n  /**\n   * Handles the loading of a route.\n   *\n   * @param {Route} route - The route object.\n   */\n  _handleRouteLoading(route) {\n    this.createPageFromWebComponent(route.name, route.component).then(() =>\n      this.selectPage(route.name, route.params),\n    );\n  }\n\n  // this function MAY BE OVERRIDDEN by native bridge - not required due to internal router updating the context\n  /**\n   * Updates the bridge channels based on the previous and current templates.\n   *\n   * @param {Template} previousTemplate - The previous template object.\n   * @param {Template} currentTemplate - The current template object.\n   */\n  _updateChannels(previousTemplate, currentTemplate) {\n    if (this.BridgeChannelManager) {\n      const oldName = previousTemplate ? previousTemplate.name : undefined;\n      const ctx = this.getInterceptorContext();\n      const currentRoute = this.getCurrentRoute();\n      this.BridgeChannelManager.updateBridgeChannels(\n        oldName,\n        currentTemplate.name,\n        ctx,\n        currentRoute,\n      );\n    }\n  }\n\n  /**\n   * Registers a connection in the bridge.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @param {WCNode} node - The node to be connected.\n   * @param {Binding} callback - The callback function to be executed when a message is received on\n   *   the channel.\n   */\n  registerInConnection(channelName, node, callback) {\n    this.ComponentConnector.addSubscription(channelName, node, callback);\n  }\n\n  /**\n   * Registers an outgoing connection.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @param {WCNode} htmlElement - The HTML element to bind the connection to.\n   * @param {string} bindName - The name of the binding.\n   * @param {Connection | undefined} extraParameters - Any extra parameters to pass to the\n   *   connection.\n   */\n  registerOutConnection(channelName, htmlElement, bindName, extraParameters) {\n    this.ComponentConnector.addPublication(channelName, htmlElement, bindName, extraParameters);\n  }\n\n  /**\n   * Unsubscribes a node from the specified channels.\n   *\n   * @param {string | string[]} channels - The channels to unsubscribe from.\n   * @param {WCNode} node - The node to unsubscribe.\n   */\n  unsubscribe(channels, node) {\n    this.ComponentConnector.unsubscribe(channels, node);\n  }\n\n  /**\n   * Publishes a value to a channel.\n   *\n   * @param {string} channelName - The name of the channel.\n   * @param {any} value - The value to be published.\n   * @param {Object} options - Optional parameters.\n   * @param {boolean} options.sessionStorage - Indicates whether to save the app state in session\n   *   storage.\n   */\n  publish(channelName, value, { sessionStorage } = { sessionStorage: false }) {\n    this.ComponentConnector.publish(channelName, value);\n\n    if (sessionStorage === true) {\n      this.ApplicationStateManager.saveAppState(channelName, value);\n    }\n  }\n\n  /**\n   * Updates the application configuration and optionally saves it to session storage.\n   *\n   * @param {object} config - The new application configuration.\n   * @param {object} [options] - Optional parameters.\n   * @param {boolean} [options.sessionStorage] - Indicates whether to save the configuration to\n   *   session storage.\n   */\n  updateApplicationConfig(config, { sessionStorage } = {}) {\n    const CONFIG_CHANNEL_NAME = `${BRIDGE_CHANNEL_PREFIX}_ch_config`;\n\n    this.publish(CONFIG_CHANNEL_NAME, config);\n\n    if (sessionStorage === true) {\n      this.ApplicationConfigManager.saveAppConfig(config);\n    }\n  }\n\n  /**\n   * Updates the subroute in the browser.\n   *\n   * @param {string} subroute - The new subroute to update.\n   */\n  updateSubroute(subroute) {\n    this.Router.updateSubrouteInBrowser(subroute);\n  }\n\n  /**\n   * Returns the current route information.\n   *\n   * @returns {RouteData} The current route object containing the name, params, query, subroute, and\n   *   hashPath.\n   */\n  getCurrentRoute() {\n    const { name, params, query, subroute } = this.Router.currentRoute;\n    return {\n      name,\n      params,\n      query,\n      subroute,\n      hashPath: this.Router._getHashPath(),\n    };\n  }\n\n  /**\n   * Navigate to a specific page.\n   *\n   * @param {string} page - La página a la que se desea navegar.\n   * @param {QueryParams} params - Los parámetros opcionales para la página.\n   */\n  navigate(page, params) {\n    this.Router.go(page, params);\n  }\n\n  /** Performs a back step in the router. */\n  backStep() {\n    const { ROUTER_BACKSTEP } = externalEventsCodes;\n\n    eventManager.emit(ROUTER_BACKSTEP, {\n      event: {},\n      detail: {},\n    });\n  }\n\n  /**\n   * Waits for the rendering of the template to complete.\n   *\n   * @param {Template} template - The template to wait for rendering completion.\n   * @returns {Promise<boolean>} - A promise that resolves when the rendering is complete.\n   */\n  _waitRenderComplete(template) {\n    return template.node.updateComplete || Promise.resolve(true);\n  }\n\n  /**\n   * Selects a page and performs necessary operations.\n   *\n   * @param {string} name - The name of the page to select.\n   * @param {QueryParams} params - The parameters to pass to the selected page.\n   * @returns {void}\n   */\n  selectPage(name, params) {\n    const { TEMPLATE_REGISTERED } = externalEventsCodes;\n    const template = this.TemplateManager.get(name);\n    const currentTemplate = this.TemplateManager.get(this.TemplateManager.selected);\n    const oldTemplateName = currentTemplate ? currentTemplate.name : undefined;\n\n    if (this.onRender) {\n      this.onRender(template.node);\n    }\n\n    (async () => {\n      await this._waitRenderComplete(template);\n      this._handleParams(template.node, params);\n      const ctx = this.getInterceptorContext();\n      const currentRoute = this.getCurrentRoute();\n      this.TemplateManager.select(name);\n\n      if (this.BridgeChannelManager) {\n        this.BridgeChannelManager.updateBridgeChannels(oldTemplateName, name, ctx, currentRoute);\n      }\n\n      eventManager.emit(TEMPLATE_REGISTERED, { template: name });\n    })();\n  }\n\n  /**\n   * Handles the parameters for a given node.\n   *\n   * @param {IndexableHTMLElement} node - The node to handle the parameters for.\n   * @param {QueryParams} params - The parameters to bind to the node.\n   */\n  _handleParams(node, params) {\n    const shouldBindParams = node['params'] && Object.keys(params).length > 0;\n\n    if (shouldBindParams) {\n      node['params'] = params;\n    }\n  }\n\n  /**\n   * It subscribe the main node to an event channel.\n   *\n   * @param {string} eventName Is the name of the event to subscribe\n   * @param {Function} callback Is the function to call when the event channel is activated with a\n   *   new value\n   */\n  subscribeToEvent(eventName, callback) {\n    if (this.externalEvents.indexOf(eventName) < 0) {\n      console.warn('Trying to subscribe to a non existing event: ', eventName);\n      return;\n    }\n    if (typeof callback !== 'function') {\n      console.warn('You must provide a function callback to subscribe to the event: ', eventName);\n      return;\n    }\n    let mainNode = this.getMainNode();\n    this.BridgeChannelManager.subscribeToEvent(mainNode, eventName, callback);\n  }\n\n  /**\n   * Retrieves the main node element.\n   *\n   * @returns {WCNode} The main node element.\n   */\n  getMainNode() {\n    if (!this.__mainNodeElement) {\n      this.__mainNodeElement = document.querySelector('#' + this.mainNode);\n    }\n    if (!this.__mainNodeElement) {\n      throw new Error('The defined main node does not exist');\n    }\n    return this.__mainNodeElement;\n  }\n\n  /**\n   * Disconnects cross components by unregistering the components from the ComponentConnector.\n   *\n   * @param {{ inConnections: InConnection[]; outConnections: OutConnection[] }} connections - The\n   *   connections object containing inConnections and outConnections.\n   * @param {boolean} cleanPrivateChannels - Indicates whether to clean private channels during\n   *   unregistering.\n   */\n  _disconnectCrossComponents({ inConnections, outConnections }, cleanPrivateChannels) {\n    inConnections?.forEach((/** @type {InConnection} */ cnx) => {\n      this.ComponentConnector.unregisterComponent(cnx.component, cleanPrivateChannels);\n    });\n    outConnections?.forEach((/** @type {OutConnection} */ cnx) => {\n      this.ComponentConnector.unregisterComponent(cnx.component, cleanPrivateChannels);\n    });\n  }\n\n  /**\n   * Reconnects the cross components by registering the input and output connections.\n   *\n   * @param {{ inConnections: InConnection[]; outConnections: OutConnection[] }} connections - The\n   *   connections object containing the input and output connections.\n   */\n  _reconnectCrossComponents({ inConnections, outConnections }) {\n    inConnections?.forEach((/** @type {InConnection} */ cnx) => {\n      this.registerInConnection(cnx.channel, cnx.component, cnx.bind);\n    });\n    outConnections?.forEach((/** @type {OutConnection} */ cnx) => {\n      this.registerOutConnection(cnx.channel, cnx.component, cnx.bind, cnx.options);\n    });\n  }\n\n  /** Cleans up the dynamic cross components by removing them from the DOM and clearing the register. */\n  _cleanDynamicCrossComponents() {}\n\n  /** Resets the bridge channels and performs necessary cleanup operations. */\n  _resetBridgeChannels() {\n    const cleanPrivateChannels = true;\n    const crossContainerTemplateId = this.TemplateManager.computeTemplateId(this.crossContainerId);\n    const crossComponentsConnections =\n      this.BridgeChannelManager.getCCSubscriptions(\n        crossContainerTemplateId,\n        this.getMainNode().id,\n      ) || {};\n\n    this._disconnectCrossComponents(crossComponentsConnections, cleanPrivateChannels);\n    this.BridgeChannelManager.resetBridgeChannels(this.getMainNode(), cleanPrivateChannels);\n    this._cleanDynamicCrossComponents();\n    this._reconnectCrossComponents(crossComponentsConnections);\n  }\n\n  /**\n   * Performs a logout action. It resets all channels, removes templates from DOM and redirects to\n   * the initial page\n   */\n  logout() {\n    if (this.TemplateManager.selected === this.initialTemplate) {\n      return;\n    }\n\n    // clean up current page\n    this.BridgeChannelManager.publishPrivatePageStatus(this.TemplateManager.selected, false);\n\n    this._resetBridgeChannels();\n\n    if (!this.usingDeclarativeCrossContainer) {\n      this.TemplateManager.removeTemplateChildrens(this.crossContainerId);\n    }\n    this.TemplateManager.removeTemplates('', this.crossContainerId);\n\n    this.ActionChannelManager.subscribeAll();\n    this._addInitialSubscribersToEvents();\n\n    this.resetInterceptorContext();\n\n    this.Router.init();\n    this.Router.go(this.initialTemplate);\n  }\n\n  /**\n   * Renders the template and appends it to the main node. If fixed is provided, it appends the\n   * fixed components to their respective zones.\n   *\n   * @param {WCNode} template - The template to be rendered.\n   */\n  onRender(template) {\n    if (!template.parentNode && this.mainNode) {\n      document.getElementById(this.mainNode)?.appendChild(template);\n      const componentsInTemplateLoaded = new CustomEvent('componentsInTemplateLoaded');\n      document.body.dispatchEvent(componentsInTemplateLoaded);\n    }\n  }\n  /**\n   * Loads the specified cells page.\n   *\n   * @param {string} page - The page to load.\n   * @returns {any} - The result of the page action.\n   */\n  loadCellsPage(page) {\n    const route = this.Router.routes[page];\n    return route.action();\n  }\n\n  /**\n   * Parses an array of routes and returns an object with route names as keys and corresponding path\n   * and action as values.\n   *\n   * @param {RouteDefinition[]} routesArray - The array of routes to be parsed.\n   * @returns {ParsedRoute} - The parsed routes object.\n   */\n  _parseRoutes(routesArray) {\n    /** @type {ParsedRoute} */\n    const routesObject = {};\n    routesArray.forEach((/** @type {RouteDefinition} */ route) => {\n      const { name, path, action, notFound, component } = route;\n      routesObject[name] = { path, action, notFound: Boolean(notFound), component };\n    });\n    return routesObject;\n  }\n\n  /**\n   * Lazy loading of pages.\n   *\n   * @param {string[]} componentNames *\n   */\n  _lazyLoadPages(componentNames) {\n    componentNames.forEach(componentName => {\n      this.loadCellsPage(componentName);\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["timeout", "subscribe", "timestamp", "timestamp", "last", "delay", "timeout", "delay", "delay", "delay", "delay", "delay", "delay", "repeat", "delay", "delay", "isArray", "expand", "buffer", "iterator", "iterator", "isArray", "first", "ReflectApply", "ReflectOwnKeys", "NumberIsNaN", "listeners", "resolved", "externalEventsCodes", "config", "_a", "from", "EMPTY", "externalEventsCodes", "_a", "config", "externalEventsCodes", "config", "initialTemplate", "externalEvents", "externalEventsCodes", "ActionChannelManager", "config", "CONFIG_STORAGE_PREFIX", "CONFIG_STORAGE_KEY", "ComponentConnector", "dasherize", "config", "externalEvents", "externalEventsCodes", "renderEngines", "resolved"]
}
