import {
  backStep,
  getCurrentRoute,
  getInterceptorContext,
  navigate,
  publish,
  publishOn,
  resetInterceptorContext,
  setInterceptorContext,
  subscribe,
  unsubscribe,
  updateInterceptorContext,
  updateSubroute
} from "./chunk-F7YLLEUV.js";

// node_modules/@open-cells/core-plugin/src/CorePlugin.js
var services = {};
services["subscribe"] = function(channelName, callback) {
  subscribe(channelName, this, callback);
};
services["unsubscribe"] = function(channels) {
  unsubscribe(channels, this);
};
services["publish"] = function(channelName, value, options = {}) {
  publish(channelName, value, options);
};
services["publishOn"] = function(channelName, htmlElement, eventName) {
  publishOn(channelName, htmlElement, eventName);
};
services["navigate"] = function(page, params) {
  navigate(page, params);
};
services["updateInterceptorContext"] = function(ctx) {
  updateInterceptorContext(ctx);
};
services["resetInterceptorContext"] = function() {
  resetInterceptorContext();
};
services["getInterceptorContext"] = function() {
  return getInterceptorContext();
};
services["setInterceptorContext"] = function(ctx) {
  setInterceptorContext(ctx);
};
services["getCurrentRoute"] = function() {
  getCurrentRoute();
};
services["updateSubroute"] = function(subroute) {
  updateSubroute(subroute);
};
services["backStep"] = function() {
  backStep();
};
function _plugCellsCore(element, bindToElement = true) {
  Object.entries(services).forEach(function([key, fn]) {
    element[key] = bindToElement ? fn.bind(element) : fn;
  });
}
function plugCellsCore(element) {
  _plugCellsCore(element, false);
  return element;
}

// node_modules/@open-cells/element-controller/src/ElementController.js
var ElementController = class {
  constructor(host) {
    this.subscriptions = [];
    plugCellsCore(this);
    this.subscribe = this.subscribe.bind(host);
    this.unsubscribe = this.unsubscribe.bind(host);
    this.publish = this.publish.bind(host);
    (this.host = host).addController(this);
    this._definedBoundedProperties();
  }
  _definedBoundedProperties() {
    const inbounds = this.host.constructor.inbounds;
    const outbounds = this.host.constructor.outbounds;
    if (!inbounds && !outbounds) {
      return;
    }
    const inout = this._mergeBounds(inbounds, outbounds);
    Object.keys(inout).forEach((key) => {
      let { output, input, skipUpdate, action } = inout[key];
      this._inOut(key, output, input, skipUpdate, action);
    });
  }
  _mergeBounds(inbounds = {}, outbounds = {}) {
    const inout = [];
    Object.keys(inbounds).forEach((key) => {
      const { channel: input, skipUpdate, action } = inbounds[key];
      inout[key] = { input, skipUpdate, action };
    });
    Object.keys(outbounds).forEach((key) => {
      const { channel: output } = outbounds[key];
      let previous = inout[key] || {};
      inout[key] = { ...previous, output };
    });
    return inout;
  }
  _inOut(propertyName, outChannelName, inChannelName, skipUpdate = false, action) {
    let internalValue;
    let setter = (value) => {
      internalValue = value;
      this.publish(outChannelName, value);
    };
    let getter = () => {
      return internalValue;
    };
    let internalSubscriberAction;
    if (action && typeof action === "function") {
      internalSubscriberAction = (value) => {
        internalValue = action(value);
        if (!skipUpdate) {
          this.host.requestUpdate();
        }
      };
    } else {
      internalSubscriberAction = (value) => {
        internalValue = value;
        if (!skipUpdate) {
          this.host.requestUpdate();
        }
      };
    }
    this.subscriptions.push({ channel: inChannelName, action: internalSubscriberAction });
    if (outChannelName) {
      Object.defineProperties(this.host, {
        [propertyName]: {
          get: getter,
          set: setter
        }
      });
    } else {
      Object.defineProperties(this.host, {
        [propertyName]: {
          get: getter
        }
      });
    }
  }
  hostConnected() {
    for (const subscription of this.subscriptions) {
      this.subscribe(subscription.channel, subscription.action);
    }
  }
  hostDisconnected() {
    for (const subscription of this.subscriptions) {
      this.unsubscribe(subscription.channel);
    }
  }
};

export {
  ElementController
};
//# sourceMappingURL=chunk-JMOEXHQD.js.map
