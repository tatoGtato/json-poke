import {
  notEqual
} from "./chunk-CMT2GIH3.js";
import "./chunk-V6TY7KAL.js";

// node_modules/@lit/task/development/task.js
var TaskStatus = {
  INITIAL: 0,
  PENDING: 1,
  COMPLETE: 2,
  ERROR: 3
};
var initialState = Symbol();
var Task = class {
  /**
   * A Promise that resolve when the current task run is complete.
   *
   * If a new task run is started while a previous run is pending, the Promise
   * is kept and only resolved when the new run is completed.
   */
  get taskComplete() {
    if (this._taskComplete) {
      return this._taskComplete;
    }
    if (this._status === TaskStatus.PENDING) {
      this._taskComplete = new Promise((res, rej) => {
        this._resolveTaskComplete = res;
        this._rejectTaskComplete = rej;
      });
    } else if (this._status === TaskStatus.ERROR) {
      this._taskComplete = Promise.reject(this._error);
    } else {
      this._taskComplete = Promise.resolve(this._value);
    }
    return this._taskComplete;
  }
  constructor(host, task, args) {
    var _a;
    this._callId = 0;
    this._status = TaskStatus.INITIAL;
    (this._host = host).addController(this);
    const taskConfig = typeof task === "object" ? task : { task, args };
    this._task = taskConfig.task;
    this._argsFn = taskConfig.args;
    this._argsEqual = taskConfig.argsEqual ?? shallowArrayEquals;
    this._onComplete = taskConfig.onComplete;
    this._onError = taskConfig.onError;
    this.autoRun = taskConfig.autoRun ?? true;
    if ("initialValue" in taskConfig) {
      this._value = taskConfig.initialValue;
      this._status = TaskStatus.COMPLETE;
      this._previousArgs = (_a = this._getArgs) == null ? void 0 : _a.call(this);
    }
  }
  hostUpdate() {
    if (this.autoRun === true) {
      this._performTask();
    }
  }
  hostUpdated() {
    if (this.autoRun === "afterUpdate") {
      this._performTask();
    }
  }
  _getArgs() {
    if (this._argsFn === void 0) {
      return void 0;
    }
    const args = this._argsFn();
    if (!Array.isArray(args)) {
      throw new Error("The args function must return an array");
    }
    return args;
  }
  /**
   * Determines if the task should run when it's triggered because of a
   * host update, and runs the task if it should.
   *
   * A task should run when its arguments change from the previous run, based on
   * the args equality function.
   *
   * This method is side-effectful: it stores the new args as the previous args.
   */
  async _performTask() {
    const args = this._getArgs();
    const prev = this._previousArgs;
    this._previousArgs = args;
    if (args !== prev && args !== void 0 && (prev === void 0 || !this._argsEqual(prev, args))) {
      await this.run(args);
    }
  }
  /**
   * Runs a task manually.
   *
   * This can be useful for running tasks in response to events as opposed to
   * automatically running when host element state changes.
   *
   * @param args an optional set of arguments to use for this task run. If args
   *     is not given, the args function is called to get the arguments for
   *     this run.
   */
  async run(args) {
    var _a, _b, _c, _d, _e;
    args ?? (args = this._getArgs());
    this._previousArgs = args;
    if (this._status === TaskStatus.PENDING) {
      (_a = this._abortController) == null ? void 0 : _a.abort();
    } else {
      this._taskComplete = void 0;
      this._resolveTaskComplete = void 0;
      this._rejectTaskComplete = void 0;
    }
    this._status = TaskStatus.PENDING;
    let result;
    let error;
    if (this.autoRun === "afterUpdate") {
      queueMicrotask(() => this._host.requestUpdate());
    } else {
      this._host.requestUpdate();
    }
    const key = ++this._callId;
    this._abortController = new AbortController();
    let errored = false;
    try {
      result = await this._task(args, { signal: this._abortController.signal });
    } catch (e) {
      errored = true;
      error = e;
    }
    if (this._callId === key) {
      if (result === initialState) {
        this._status = TaskStatus.INITIAL;
      } else {
        if (errored === false) {
          try {
            (_b = this._onComplete) == null ? void 0 : _b.call(this, result);
          } catch {
          }
          this._status = TaskStatus.COMPLETE;
          (_c = this._resolveTaskComplete) == null ? void 0 : _c.call(this, result);
        } else {
          try {
            (_d = this._onError) == null ? void 0 : _d.call(this, error);
          } catch {
          }
          this._status = TaskStatus.ERROR;
          (_e = this._rejectTaskComplete) == null ? void 0 : _e.call(this, error);
        }
        this._value = result;
        this._error = error;
      }
      this._host.requestUpdate();
    }
  }
  /**
   * Aborts the currently pending task run by aborting the AbortSignal
   * passed to the task function.
   *
   * Aborting a task does nothing if the task is not running: ie, in the
   * complete, error, or initial states.
   *
   * Aborting a task does not automatically cancel the task function. The task
   * function must be written to accept the AbortSignal and either forward it
   * to other APIs like `fetch()`, or handle cancellation manually by using
   * [`signal.throwIfAborted()`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted}
   * or the
   * [`abort`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/abort_event}
   * event.
   *
   * @param reason The reason for aborting. Passed to
   *     `AbortController.abort()`.
   */
  abort(reason) {
    var _a;
    if (this._status === TaskStatus.PENDING) {
      (_a = this._abortController) == null ? void 0 : _a.abort(reason);
    }
  }
  /**
   * The result of the previous task run, if it resolved.
   *
   * Is `undefined` if the task has not run yet, or if the previous run errored.
   */
  get value() {
    return this._value;
  }
  /**
   * The error from the previous task run, if it rejected.
   *
   * Is `undefined` if the task has not run yet, or if the previous run
   * completed successfully.
   */
  get error() {
    return this._error;
  }
  get status() {
    return this._status;
  }
  render(renderer) {
    var _a, _b, _c, _d;
    switch (this._status) {
      case TaskStatus.INITIAL:
        return (_a = renderer.initial) == null ? void 0 : _a.call(renderer);
      case TaskStatus.PENDING:
        return (_b = renderer.pending) == null ? void 0 : _b.call(renderer);
      case TaskStatus.COMPLETE:
        return (_c = renderer.complete) == null ? void 0 : _c.call(renderer, this.value);
      case TaskStatus.ERROR:
        return (_d = renderer.error) == null ? void 0 : _d.call(renderer, this.error);
      default:
        throw new Error(`Unexpected status: ${this._status}`);
    }
  }
};
var shallowArrayEquals = (oldArgs, newArgs) => oldArgs === newArgs || oldArgs.length === newArgs.length && oldArgs.every((v, i) => !notEqual(v, newArgs[i]));
export {
  Task,
  TaskStatus,
  initialState,
  shallowArrayEquals
};
/*! Bundled license information:

@lit/task/development/task.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/task/development/index.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@lit_task.js.map
