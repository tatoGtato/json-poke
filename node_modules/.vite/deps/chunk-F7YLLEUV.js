import {
  __publicField
} from "./chunk-V6TY7KAL.js";

// node_modules/rxjs/dist/esm/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js
var UnsubscriptionError = class extends Error {
  constructor(errors) {
    super(errors ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join("\n  ")}` : "");
    __publicField(this, "errors");
    this.errors = errors;
    this.name = "UnsubscriptionError";
  }
};

// node_modules/rxjs/dist/esm/internal/Subscription.js
var _Subscription = class _Subscription {
  constructor(initialTeardown) {
    __publicField(this, "initialTeardown");
    __publicField(this, "closed", false);
    __publicField(this, "_finalizers", null);
    this.initialTeardown = initialTeardown;
  }
  unsubscribe() {
    let errors;
    if (!this.closed) {
      this.closed = true;
      const { initialTeardown: initialFinalizer } = this;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      const { _finalizers } = this;
      if (_finalizers) {
        this._finalizers = null;
        for (const finalizer of _finalizers) {
          try {
            execFinalizer(finalizer);
          } catch (err) {
            errors = errors ?? [];
            if (err instanceof UnsubscriptionError) {
              errors.push(...err.errors);
            } else {
              errors.push(err);
            }
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  }
  add(teardown) {
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown && "add" in teardown) {
          teardown.add(() => {
            this.remove(teardown);
          });
        }
        this._finalizers ?? (this._finalizers = /* @__PURE__ */ new Set());
        this._finalizers.add(teardown);
      }
    }
  }
  remove(teardown) {
    var _a;
    (_a = this._finalizers) == null ? void 0 : _a.delete(teardown);
  }
};
__publicField(_Subscription, "EMPTY", (() => {
  const empty = new _Subscription();
  empty.closed = true;
  return empty;
})());
var Subscription = _Subscription;
if (typeof Symbol.dispose === "symbol") {
  Subscription.prototype[Symbol.dispose] = Subscription.prototype.unsubscribe;
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null
};

// node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout(handler, timeout2, ...args) {
    const { delegate } = timeoutProvider;
    if (delegate == null ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout(handler, timeout2, ...args);
    }
    return setTimeout(handler, timeout2, ...args);
  },
  clearTimeout(handle) {
    const { delegate } = timeoutProvider;
    return ((delegate == null ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(() => {
    const { onUnhandledError } = config;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = (() => createNotification("C", void 0, void 0))();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm/internal/Subscriber.js
var Subscriber = class _Subscriber extends Subscription {
  constructor(destination, overrides) {
    super();
    __publicField(this, "isStopped", false);
    __publicField(this, "destination");
    __publicField(this, "_nextOverride", null);
    __publicField(this, "_errorOverride", null);
    __publicField(this, "_completeOverride", null);
    __publicField(this, "_onFinalize", null);
    this.destination = destination instanceof _Subscriber ? destination : createSafeObserver(destination);
    this._nextOverride = (overrides == null ? void 0 : overrides.next) ?? null;
    this._errorOverride = (overrides == null ? void 0 : overrides.error) ?? null;
    this._completeOverride = (overrides == null ? void 0 : overrides.complete) ?? null;
    this._onFinalize = (overrides == null ? void 0 : overrides.finalize) ?? null;
    this._next = this._nextOverride ? overrideNext : this._next;
    this._error = this._errorOverride ? overrideError : this._error;
    this._complete = this._completeOverride ? overrideComplete : this._complete;
    if (hasAddAndUnsubscribe(destination)) {
      destination.add(this);
    }
  }
  next(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  }
  error(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  }
  complete() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  }
  unsubscribe() {
    var _a;
    if (!this.closed) {
      this.isStopped = true;
      super.unsubscribe();
      (_a = this._onFinalize) == null ? void 0 : _a.call(this);
    }
  }
  _next(value) {
    this.destination.next(value);
  }
  _error(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  }
  _complete() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }
};
function overrideNext(value) {
  try {
    this._nextOverride(value);
  } catch (error) {
    this.destination.error(error);
  }
}
function overrideError(err) {
  try {
    this._errorOverride(err);
  } catch (error) {
    this.destination.error(error);
  } finally {
    this.unsubscribe();
  }
}
function overrideComplete() {
  try {
    this._completeOverride();
  } catch (error) {
    this.destination.error(error);
  } finally {
    this.unsubscribe();
  }
}
var ConsumerObserver = class {
  constructor(partialObserver) {
    __publicField(this, "partialObserver");
    this.partialObserver = partialObserver;
  }
  next(value) {
    const { partialObserver } = this;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        reportUnhandledError(error);
      }
    }
  }
  error(err) {
    const { partialObserver } = this;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        reportUnhandledError(error);
      }
    } else {
      reportUnhandledError(err);
    }
  }
  complete() {
    const { partialObserver } = this;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        reportUnhandledError(error);
      }
    }
  }
};
function createSafeObserver(observerOrNext) {
  return new ConsumerObserver(!observerOrNext || isFunction(observerOrNext) ? { next: observerOrNext ?? void 0 } : observerOrNext);
}
function handleStoppedNotification(notification, subscriber) {
  const { onStoppedNotification } = config;
  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
}
function hasAddAndUnsubscribe(value) {
  return value && isFunction(value.unsubscribe) && isFunction(value.add);
}
function operate({ destination, ...subscriberOverrides }) {
  return new Subscriber(destination, subscriberOverrides);
}

// node_modules/rxjs/dist/esm/internal/symbol/observable.js
var observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();

// node_modules/rxjs/dist/esm/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  };
}

// node_modules/rxjs/dist/esm/internal/Observable.js
var Observable = class {
  constructor(subscribe2) {
    if (subscribe2) {
      this._subscribe = subscribe2;
    }
  }
  subscribe(observerOrNext) {
    const subscriber = observerOrNext instanceof Subscriber ? observerOrNext : new Subscriber(observerOrNext);
    subscriber.add(this._trySubscribe(subscriber));
    return subscriber;
  }
  _trySubscribe(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  }
  forEach(next) {
    return new Promise((resolve, reject) => {
      const subscriber = new Subscriber({
        next: (value) => {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      this.subscribe(subscriber);
    });
  }
  _subscribe(_subscriber) {
    return;
  }
  [observable]() {
    return this;
  }
  pipe(...operations) {
    return pipeFromArray(operations)(this);
  }
  [Symbol.asyncIterator]() {
    let subscription;
    let hasError = false;
    let error;
    let completed = false;
    const values = [];
    const deferreds = [];
    const handleError = (err) => {
      hasError = true;
      error = err;
      while (deferreds.length) {
        const [_, reject] = deferreds.shift();
        reject(err);
      }
    };
    const handleComplete = () => {
      completed = true;
      while (deferreds.length) {
        const [resolve] = deferreds.shift();
        resolve({ value: void 0, done: true });
      }
    };
    return {
      next: () => {
        if (!subscription) {
          subscription = this.subscribe({
            next: (value) => {
              if (deferreds.length) {
                const [resolve] = deferreds.shift();
                resolve({ value, done: false });
              } else {
                values.push(value);
              }
            },
            error: handleError,
            complete: handleComplete
          });
        }
        if (values.length) {
          return Promise.resolve({ value: values.shift(), done: false });
        }
        if (completed) {
          return Promise.resolve({ value: void 0, done: true });
        }
        if (hasError) {
          return Promise.reject(error);
        }
        return new Promise((resolve, reject) => {
          deferreds.push([resolve, reject]);
        });
      },
      throw: (err) => {
        subscription == null ? void 0 : subscription.unsubscribe();
        handleError(err);
        return Promise.reject(err);
      },
      return: () => {
        subscription == null ? void 0 : subscription.unsubscribe();
        handleComplete();
        return Promise.resolve({ value: void 0, done: true });
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule(callback) {
    let request = requestAnimationFrame;
    let cancel = cancelAnimationFrame;
    const { delegate } = animationFrameProvider;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    const handle = request((timestamp2) => {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(() => cancel == null ? void 0 : cancel(handle));
  },
  requestAnimationFrame(...args) {
    const { delegate } = animationFrameProvider;
    return ((delegate == null ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame)(...args);
  },
  cancelAnimationFrame(...args) {
    const { delegate } = animationFrameProvider;
    return ((delegate == null ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame)(...args);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable((subscriber) => {
    const provider = timestampProvider || performanceTimestampProvider;
    const start = provider.now();
    let id = 0;
    const run = () => {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame((timestamp2) => {
          id = 0;
          const now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return () => {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm/internal/Subject.js
var Subject = class extends Observable {
  constructor() {
    super();
    __publicField(this, "_closed", false);
    __publicField(this, "_observerCounter", 0);
    __publicField(this, "currentObservers", /* @__PURE__ */ new Map());
    __publicField(this, "observerSnapshot");
    __publicField(this, "hasError", false);
    __publicField(this, "thrownError", null);
  }
  get closed() {
    return this._closed;
  }
  get observers() {
    return this.observerSnapshot ?? (this.observerSnapshot = Array.from(this.currentObservers.values()));
  }
  _clearObservers() {
    this.currentObservers.clear();
    this.observerSnapshot = void 0;
  }
  next(value) {
    if (!this._closed) {
      const { observers } = this;
      const len = observers.length;
      for (let i = 0; i < len; i++) {
        observers[i].next(value);
      }
    }
  }
  error(err) {
    if (!this._closed) {
      this.hasError = this._closed = true;
      this.thrownError = err;
      const { observers } = this;
      const len = observers.length;
      for (let i = 0; i < len; i++) {
        observers[i].error(err);
      }
      this._clearObservers();
    }
  }
  complete() {
    if (!this._closed) {
      this._closed = true;
      const { observers } = this;
      const len = observers.length;
      for (let i = 0; i < len; i++) {
        observers[i].complete();
      }
      this._clearObservers();
    }
  }
  unsubscribe() {
    this._closed = true;
    this._clearObservers();
  }
  get observed() {
    return this.currentObservers.size > 0;
  }
  _subscribe(subscriber) {
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  }
  _innerSubscribe(subscriber) {
    if (this.hasError || this._closed) {
      return Subscription.EMPTY;
    }
    const { currentObservers } = this;
    const observerId = this._observerCounter++;
    currentObservers.set(observerId, subscriber);
    this.observerSnapshot = void 0;
    subscriber.add(() => {
      currentObservers.delete(observerId);
      this.observerSnapshot = void 0;
    });
    return subscriber;
  }
  _checkFinalizedStatuses(subscriber) {
    const { hasError, thrownError, _closed } = this;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (_closed) {
      subscriber.complete();
    }
  }
  asObservable() {
    return new Observable((subscriber) => this.subscribe(subscriber));
  }
};
__publicField(Subject, "create", (destination, source) => {
  return new AnonymousSubject(destination, source);
});
var AnonymousSubject = class extends Subject {
  constructor(destination, _source) {
    super();
    __publicField(this, "destination");
    __publicField(this, "_source");
    this.destination = destination;
    this._source = _source;
  }
  next(value) {
    var _a, _b;
    (_b = (_a = this.destination) == null ? void 0 : _a.next) == null ? void 0 : _b.call(_a, value);
  }
  error(err) {
    var _a, _b;
    (_b = (_a = this.destination) == null ? void 0 : _a.error) == null ? void 0 : _b.call(_a, err);
  }
  complete() {
    var _a, _b;
    (_b = (_a = this.destination) == null ? void 0 : _a.complete) == null ? void 0 : _b.call(_a);
  }
  _subscribe(subscriber) {
    var _a;
    return ((_a = this._source) == null ? void 0 : _a.subscribe(subscriber)) ?? Subscription.EMPTY;
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/ReplaySubject.js
var ReplaySubject = class extends Subject {
  constructor(_bufferSize = Infinity, _windowTime = Infinity, _timestampProvider = dateTimestampProvider) {
    super();
    __publicField(this, "_bufferSize");
    __publicField(this, "_windowTime");
    __publicField(this, "_timestampProvider");
    __publicField(this, "_buffer", []);
    __publicField(this, "_infiniteTimeWindow", true);
    this._bufferSize = _bufferSize;
    this._windowTime = _windowTime;
    this._timestampProvider = _timestampProvider;
    this._infiniteTimeWindow = _windowTime === Infinity;
    this._bufferSize = Math.max(1, _bufferSize);
    this._windowTime = Math.max(1, _windowTime);
  }
  next(value) {
    const { _closed, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;
    if (!_closed) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    super.next(value);
  }
  _subscribe(subscriber) {
    this._trimBuffer();
    const subscription = this._innerSubscribe(subscriber);
    const { _infiniteTimeWindow, _buffer } = this;
    const copy = _buffer.slice();
    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  }
  _trimBuffer() {
    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;
    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      const now = _timestampProvider.now();
      let last3 = 0;
      for (let i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/Action.js
var Action = class extends Subscription {
  constructor(scheduler, work) {
    super();
  }
  schedule(state, delay2 = 0) {
    return this;
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval(handler, timeout2, ...args) {
    const { delegate } = intervalProvider;
    if (delegate == null ? void 0 : delegate.setInterval) {
      return delegate.setInterval(handler, timeout2, ...args);
    }
    return setInterval(handler, timeout2, ...args);
  },
  clearInterval(handle) {
    const { delegate } = intervalProvider;
    return ((delegate == null ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    const index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm/internal/scheduler/AsyncAction.js
var AsyncAction = class extends Action {
  constructor(scheduler, work) {
    super(scheduler, work);
    __publicField(this, "scheduler");
    __publicField(this, "work");
    __publicField(this, "id");
    __publicField(this, "state");
    __publicField(this, "delay");
    __publicField(this, "pending", false);
    this.scheduler = scheduler;
    this.work = work;
  }
  schedule(state, delay2 = 0) {
    if (this.closed) {
      return this;
    }
    this.state = state;
    const id = this.id;
    const scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  }
  requestAsyncId(scheduler, _id, delay2 = 0) {
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  }
  recycleAsyncId(_scheduler, id, delay2 = 0) {
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  }
  execute(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    const error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  }
  _execute(state, _delay) {
    let errored = false;
    let errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  }
  unsubscribe() {
    if (!this.closed) {
      const { id, scheduler } = this;
      const { actions } = scheduler;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      super.unsubscribe();
    }
  }
};

// node_modules/rxjs/dist/esm/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate(cb) {
    const handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(() => findAndClearHandle(handle) && cb());
    return handle;
  },
  clearImmediate(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/immediateProvider.js
var { setImmediate, clearImmediate } = Immediate;
var immediateProvider = {
  setImmediate(...args) {
    const { delegate } = immediateProvider;
    return ((delegate == null ? void 0 : delegate.setImmediate) || setImmediate)(...args);
  },
  clearImmediate(handle) {
    const { delegate } = immediateProvider;
    return ((delegate == null ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/scheduler/AsapAction.js
var AsapAction = class extends AsyncAction {
  constructor(scheduler, work) {
    super(scheduler, work);
    __publicField(this, "scheduler");
    __publicField(this, "work");
    this.scheduler = scheduler;
    this.work = work;
  }
  requestAsyncId(scheduler, id, delay2 = 0) {
    if (delay2 !== null && delay2 > 0) {
      return super.requestAsyncId(scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  }
  recycleAsyncId(scheduler, id, delay2 = 0) {
    var _a;
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return super.recycleAsyncId(scheduler, id, delay2);
    }
    const { actions } = scheduler;
    if (id != null && ((_a = actions[actions.length - 1]) == null ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  }
};

// node_modules/rxjs/dist/esm/internal/Scheduler.js
var _Scheduler = class _Scheduler {
  constructor(schedulerActionCtor, now = _Scheduler.now) {
    __publicField(this, "schedulerActionCtor");
    __publicField(this, "now");
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  schedule(work, delay2 = 0, state) {
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  }
};
__publicField(_Scheduler, "now", dateTimestampProvider.now);
var Scheduler = _Scheduler;

// node_modules/rxjs/dist/esm/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = class extends Scheduler {
  constructor(SchedulerAction, now = Scheduler.now) {
    super(SchedulerAction, now);
    __publicField(this, "actions", []);
    __publicField(this, "_active", false);
    __publicField(this, "_scheduled");
  }
  flush(action) {
    const { actions } = this;
    if (this._active) {
      actions.push(action);
      return;
    }
    let error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/AsapScheduler.js
var AsapScheduler = class extends AsyncScheduler {
  flush(action) {
    this._active = true;
    const flushId = this._scheduled;
    this._scheduled = void 0;
    const { actions } = this;
    let error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);

// node_modules/rxjs/dist/esm/internal/scheduler/QueueAction.js
var QueueAction = class extends AsyncAction {
  constructor(scheduler, work) {
    super(scheduler, work);
    __publicField(this, "scheduler");
    __publicField(this, "work");
    this.scheduler = scheduler;
    this.work = work;
  }
  schedule(state, delay2 = 0) {
    if (delay2 > 0) {
      return super.schedule(state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  }
  execute(state, delay2) {
    return delay2 > 0 || this.closed ? super.execute(state, delay2) : this._execute(state, delay2);
  }
  requestAsyncId(scheduler, id, delay2 = 0) {
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return super.requestAsyncId(scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/QueueScheduler.js
var QueueScheduler = class extends AsyncScheduler {
};

// node_modules/rxjs/dist/esm/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = class extends AsyncAction {
  constructor(scheduler, work) {
    super(scheduler, work);
    __publicField(this, "scheduler");
    __publicField(this, "work");
    this.scheduler = scheduler;
    this.work = work;
  }
  requestAsyncId(scheduler, id, delay2 = 0) {
    if (delay2 !== null && delay2 > 0) {
      return super.requestAsyncId(scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(void 0)));
  }
  recycleAsyncId(scheduler, id, delay2 = 0) {
    var _a;
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return super.recycleAsyncId(scheduler, id, delay2);
    }
    const { actions } = scheduler;
    if (id != null && ((_a = actions[actions.length - 1]) == null ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = class extends AsyncScheduler {
  flush(action) {
    this._active = true;
    const flushId = this._scheduled;
    this._scheduled = void 0;
    const { actions } = this;
    let error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm/internal/util/isArrayLike.js
var isArrayLike = (x) => x && typeof x.length === "number" && typeof x !== "function";

// node_modules/rxjs/dist/esm/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value == null ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj == null ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError(`You provided ${input !== null && typeof input === "object" ? "an invalid object" : `'${input}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);
}

// node_modules/rxjs/dist/esm/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input == null ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js
async function* readableStreamLikeToAsyncGenerator(readableStream) {
  const reader = readableStream.getReader();
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) {
        return;
      }
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}
function isReadableStreamLike(obj) {
  return isFunction(obj == null ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm/internal/observable/from.js
function from(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable((subscriber) => {
    const obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable((subscriber) => {
    subscribeToArray(array, subscriber);
  });
}
function fromPromise(promise) {
  return new Observable((subscriber) => {
    promise.then((value) => {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, (err) => subscriber.error(err)).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable((subscriber) => {
    for (const value of iterable) {
      subscriber.next(value);
      if (subscriber.closed) {
        return;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable((subscriber) => {
    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
async function process(asyncIterable, subscriber) {
  for await (const value of asyncIterable) {
    subscriber.next(value);
    if (subscriber.closed) {
      return;
    }
  }
  subscriber.complete();
}
function subscribeToArray(array, subscriber) {
  const length = array.length;
  for (let i = 0; i < length; i++) {
    if (subscriber.closed) {
      return;
    }
    subscriber.next(array[i]);
  }
  subscriber.complete();
}

// node_modules/rxjs/dist/esm/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2 = 0, repeat2 = false) {
  const scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2 = 0) {
  return (source) => new Observable((subscriber) => {
    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay2));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/map.js
function map(project) {
  return (source) => new Observable((destination) => {
    let index = 0;
    source.subscribe(operate({
      destination,
      next: (value) => {
        destination.next(project(value, index++));
      }
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js
var { isArray } = Array;
function callOrApply(fn, args) {
  return isArray(args) ? fn(...args) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map((args) => callOrApply(fn, args));
}

// node_modules/rxjs/dist/esm/internal/operators/observeOn.js
function observeOn(scheduler, delay2 = 0) {
  return (source) => new Observable((destination) => {
    source.subscribe(operate({
      destination,
      next: (value) => executeSchedule(destination, scheduler, () => destination.next(value), delay2),
      error: (err) => executeSchedule(destination, scheduler, () => destination.error(err), delay2),
      complete: () => executeSchedule(destination, scheduler, () => destination.complete(), delay2)
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js
var { isArray: isArray2 } = Array;
var { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;

// node_modules/rxjs/dist/esm/internal/observable/empty.js
var EMPTY = new Observable((subscriber) => subscriber.complete());

// node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js
function mergeInternals(source, destination, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  const buffer2 = [];
  let active = 0;
  let index = 0;
  let isComplete = false;
  const checkComplete = () => {
    if (isComplete && !buffer2.length && !active) {
      destination.complete();
    }
  };
  const outerNext = (value) => active < concurrent ? doInnerSub(value) : buffer2.push(value);
  const doInnerSub = (value) => {
    expand2 && destination.next(value);
    active++;
    let innerComplete = false;
    from(project(value, index++)).subscribe(operate({
      destination,
      next: (innerValue) => {
        onBeforeNext == null ? void 0 : onBeforeNext(innerValue);
        if (expand2) {
          outerNext(innerValue);
        } else {
          destination.next(innerValue);
        }
      },
      complete: () => {
        innerComplete = true;
      },
      finalize: () => {
        if (innerComplete) {
          try {
            active--;
            while (buffer2.length && active < concurrent) {
              const bufferedValue = buffer2.shift();
              if (innerSubScheduler) {
                executeSchedule(destination, innerSubScheduler, () => doInnerSub(bufferedValue));
              } else {
                doInnerSub(bufferedValue);
              }
            }
            checkComplete();
          } catch (err) {
            destination.error(err);
          }
        }
      }
    }));
  };
  source.subscribe(operate({
    destination,
    next: outerNext,
    complete: () => {
      isComplete = true;
      checkComplete();
    }
  }));
  return () => {
    additionalFinalizer == null ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm/internal/operators/mergeMap.js
function mergeMap(project, concurrent = Infinity) {
  return (source) => new Observable((subscriber) => mergeInternals(source, subscriber, project, concurrent));
}

// node_modules/rxjs/dist/esm/internal/operators/mergeAll.js
function mergeAll(concurrent = Infinity) {
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return from(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return from(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable((subscriber) => {
    let i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable((subscriber) => {
    let iterator2;
    executeSchedule(subscriber, scheduler, () => {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, () => {
        let value;
        let done;
        try {
          ({ value, done } = iterator2.next());
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return () => isFunction(iterator2 == null ? void 0 : iterator2.return) && iterator2.return();
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable((subscriber) => {
    executeSchedule(subscriber, scheduler, () => {
      const iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, () => {
        iterator2.next().then((result) => {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  const isValidTarget = isNodeStyleEventEmitter(target) || isJQueryStyleEventEmitter(target) || isEventTarget(target);
  if (!isValidTarget && !isArrayLike(target)) {
    throw new TypeError("Invalid event target");
  }
  return new Observable((subscriber) => {
    const handler = (...args) => subscriber.next(1 < args.length ? args : args[0]);
    if (isValidTarget) {
      doSubscribe(handler, subscriber, target, eventName, options);
    } else {
      for (let i = 0; i < target.length && !subscriber.closed; i++) {
        const subTarget = target[i];
        doSubscribe(handler, subscriber, subTarget, eventName, options);
      }
    }
  });
}
function doSubscribe(handler, subscriber, subTarget, eventName, options) {
  const [addMethod, removeMethod] = getRegistryMethodNames(subTarget);
  if (!addMethod || !removeMethod) {
    throw new TypeError("Invalid event target");
  }
  subTarget[addMethod](eventName, handler, options);
  subscriber.add(() => subTarget[removeMethod](eventName, handler, options));
}
function getRegistryMethodNames(target) {
  return isEventTarget(target) ? eventTargetMethods : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods : isJQueryStyleEventEmitter(target) ? jqueryMethods : [];
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

// node_modules/rxjs/dist/esm/internal/observable/merge.js
function merge(...args) {
  const scheduler = popScheduler(args);
  const concurrent = popNumber(args, Infinity);
  const sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? from(sources[0]) : mergeAll(concurrent)(scheduler ? scheduled(sources, scheduler) : from(sources));
}

// node_modules/rxjs/dist/esm/internal/util/argsOrArgArray.js
var { isArray: isArray3 } = Array;

// node_modules/rxjs/dist/esm/internal/operators/filter.js
function filter(predicate, thisArg) {
  return (source) => new Observable((destination) => {
    let index = 0;
    source.subscribe(operate({ destination, next: (value) => predicate.call(thisArg, value, index++) && destination.next(value) }));
  });
}

// node_modules/rxjs/dist/esm/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector = identity) {
  comparator = comparator ?? defaultCompare;
  return (source) => new Observable((destination) => {
    let previousKey;
    let first2 = true;
    source.subscribe(operate({
      destination,
      next: (value) => {
        const currentKey = keySelector(value);
        if (first2 || !comparator(previousKey, currentKey)) {
          first2 = false;
          previousKey = currentKey;
          destination.next(value);
        }
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}

// node_modules/rxjs/dist/esm/internal/operators/startWith.js
function startWith(...values) {
  return (source) => new Observable((destination) => {
    subscribeToArray(values, operate({ destination, complete: () => source.subscribe(destination) }));
  });
}

// node_modules/@open-cells/core/src/external/event-emitter.js
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError(
      'The "listener" argument must be of type Function. Received type ' + typeof listener
    );
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError(
        'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + "."
      );
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError(
      'The value of "n" is out of range. It must be a non-negative number. Received ' + n + "."
    );
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === "error";
  var events = this._events;
  if (events !== void 0) doError = doError && events.error === void 0;
  else if (!doError) return false;
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events[type];
  if (handler === void 0) return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners2[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;
  if (events === void 0) {
    events = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === void 0) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      var w = new Error(
        "Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit"
      );
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === void 0) return this;
  list = events[type];
  if (list === void 0) return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events[type];
      if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (position === 0) list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events, i;
  events = this._events;
  if (events === void 0) return this;
  if (events.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== void 0) {
      if (--this._eventsCount === 0) this._events = /* @__PURE__ */ Object.create(null);
      else delete events[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === void 0) return [];
  var evlistener = events[type];
  if (evlistener === void 0) return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events !== void 0) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

// node_modules/@open-cells/core/src/manager/events.js
var MAX_NUM_LISTENERS = 20;
var CustomEventEmitter = class extends EventEmitter {
  constructor(maxNumListeners = 10) {
    super();
    this.setMaxListeners(maxNumListeners);
  }
  /**
   * Listens to an event on a given node and executes the callback function once.
   *
   * @param {WCNode} node - The node to listen to the event on.
   * @param {string} name - The name of the event to listen for.
   * @param {Function} callback - The callback function to execute when the event is triggered.
   */
  listenToOnce(node, name, callback) {
    node.addEventListener(name, function cb(event) {
      var _a;
      callback();
      (_a = event.currentTarget) == null ? void 0 : _a.removeEventListener(event.type, cb);
    });
  }
  /**
   * Creates an event.
   *
   * @param {string} name - The name of the event.
   * @param {any} value - The value of the event.
   * @returns {WCEvent} The created event.
   */
  createEvent(name, value) {
    let evt = new Event(name);
    evt.detail = { value };
    return evt;
  }
};
var eventManager = new CustomEventEmitter(MAX_NUM_LISTENERS);

// node_modules/@open-cells/core/src/state/channel.js
function generateUUID() {
  let d = (/* @__PURE__ */ new Date()).getTime();
  let uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    let r = (d + Math.random() * 16) % 16 | 0;
    return (c == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid;
}
var Channel = class extends ReplaySubject {
  /**
   * Creates a channel for sending values, errors, and completion signals.
   *
   * @param {string} name - The name of the channel.
   */
  constructor(name) {
    super(1);
    this.name = name;
  }
  /**
   * Sends the next value to the channel. If the value does not have a UUID, it generates one. If
   * the value does not have a time, it sets the current time.
   *
   * @param {PublishableValue} value - The value to be sent to the channel.
   * @returns {void}
   */
  next(value) {
    if (!value.uuid) {
      value.uuid = generateUUID();
    }
    if (!value.time) {
      value.time = (/* @__PURE__ */ new Date()).getTime();
    }
    super.next(value);
  }
  /**
   * Checks if the channel has any observers.
   *
   * @returns {boolean} True if the channel has observers, false otherwise.
   * @throws {Error} If the channel is closed.
   */
  hasObservers() {
    if (this.closed) {
      throw new Error();
    }
    return this.observed;
  }
  // /**
  //  * Unsubscribes an observer from the channel.
  //  *
  //  * @param {number} index - The index of the observer to unsubscribe.
  //  * @returns {void}
  //  */
  // unsubscribeObserver(index) {
  //   this.observers?.splice(index, 1);
  //   if (this.observers?.length === 0) {
  //     this.unsubscribe();
  //   }
  // }
  /**
   * Unsubscribes all observers from the channel.
   *
   * @returns {void}
   */
  unsubscribeAllObservers() {
    this.unsubscribe();
  }
  /**
   * Cleans the channel by resetting the buffer and observers.
   *
   * @memberof Channel
   * @function
   * @returns {void}
   * @name clean
   * @instance
   */
  clean() {
    this._buffer = [];
    this._clearObservers();
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    this._buffer = value;
  }
  // /**
  //  * Disposes the channel by unsubscribing from it.
  //  *
  //  * @memberof Channel
  //  * @function
  //  * @returns {void}
  //  * @instance
  //  */
  // dispose() {
  //   this.unsubscribeAllObsrvers();
  // }
};
var createChannel = (name) => {
  return new Channel(name);
};

// node_modules/@open-cells/core/src/constants.js
var externalEventsCodes = {
  PARSE_ROUTE: "parse-route",
  AFTER_PUBLISH: "after-publish",
  NAV_REQUEST: "nav-request",
  TEMPLATE_TRANSITION_END: "template-transition-end",
  TRACK_EVENT: "track-event",
  TEMPLATE_REGISTERED: "template-registered",
  ROUTER_BACKSTEP: "router-backstep",
  LOG_EVENT: "log-event"
};
var externalEvents = Object.values(externalEventsCodes);
var initialTemplate = "login";
var pagesPath = "./pages/";
var renderEngines = {
  LIT_ELEMENT: "litElement"
};
var BRIDGE_CHANNEL_PREFIX = "__oc";
var Constants = {
  bridgeChannelPrefix: BRIDGE_CHANNEL_PREFIX,
  externalEvents,
  externalEventsCodes,
  initialTemplate,
  pagesPath,
  renderEngines
};

// node_modules/@open-cells/core/src/state/subscriptor.js
var Subscriptor = class {
  /** @param {WCNode} node */
  constructor(node) {
    this.node = node;
    this.subscriptions = [];
    this.publications = new Subscription();
    this.nodeChannelData = {};
  }
  /**
   * Indicates if the node has a subscription to a channel.
   *
   * @param {Channel} channel - Channel to check
   * @returns {boolean} True if the node has a subscription to the channel, false otherwise.
   */
  hasSubscription(channel) {
    return this.subscriptions.filter((d) => d.channel === channel).length > 0;
  }
  /**
   * Publish an event.
   *
   * @param {WrappedEventForPublication} WrappedEvent
   */
  publish(WrappedEvent) {
    this.publications.add(WrappedEvent);
  }
  /**
   * Retrieves the time interval from the specified channel name.
   *
   * @param {string} channelName - The name of the channel.
   * @returns {number | null} The time interval of the channel.
   */
  getTimeFromNode(channelName) {
    return this.nodeChannelData[channelName].interval;
  }
  /**
   * Sets the time interval for a specific channel.
   *
   * @param {string} channelName - The name of the channel.
   * @param {number} time - The time interval to set.
   */
  setTimeForNode(channelName, time) {
    this.nodeChannelData[channelName].interval = time;
  }
  /**
   * Returns the time from the given channel.
   *
   * @param {Channel} channel - The channel object.
   * @returns {number} The time from the channel.
   */
  getTimeFromChannel(channel) {
    var _a;
    if (((_a = channel == null ? void 0 : channel.buffer) == null ? void 0 : _a.length) && channel.buffer.length > 0) {
      return channel.buffer[0].time;
    } else {
      return 1;
    }
  }
  /**
   * Obtiene el ID asociado a un nombre de canal.
   *
   * @param {string} channelName - El nombre del canal.
   * @returns {string | null} - El ID asociado al nombre del canal.
   */
  getIdFromNode(channelName) {
    return this.nodeChannelData[channelName].id;
  }
  /**
   * Sets the ID for a specific channel node.
   *
   * @param {string} channelName - The name of the channel.
   * @param {string} id - The ID to set for the channel node.
   */
  setIdForNode(channelName, id) {
    this.nodeChannelData[channelName].id = id;
  }
  /**
   * Retrieves the ID from the given channel.
   *
   * @param {Object} channel - The channel object.
   * @returns {string | null} The ID of the channel, or null if the channel is empty.
   */
  getIdFromChannel(channel) {
    var _a, _b;
    if (((_a = channel.buffer) == null ? void 0 : _a.length) && ((_b = channel.buffer) == null ? void 0 : _b.length) > 0) {
      return channel.buffer[0].uuid;
    } else {
      return null;
    }
  }
  /**
   * @param {Channel} channel
   * @param {AugmentedFunction} fn Callback function to run when a value from a channel changed
   * @returns {AugmentedFunction}
   */
  makeCallbackWithNoReplay(channel, fn) {
    if (!this.nodeChannelData[channel.name]) {
      this.nodeChannelData[channel.name] = { interval: null, id: null };
    }
    const self = this;
    const fnReplayOff = (function() {
      let lastInterval = self.getTimeFromChannel(channel);
      let nodeInterval = self.getTimeFromNode(channel.name);
      let lastId = self.getIdFromChannel(channel);
      let nodeId = self.getIdFromNode(channel.name);
      if (!nodeInterval || nodeInterval < lastInterval || nodeInterval === lastInterval && nodeId != lastId) {
        self.setTimeForNode(channel.name, lastInterval);
        if (lastId) {
          self.setIdForNode(channel.name, lastId);
        }
        return fn.apply(
          /** @type {any} */
          self,
          arguments
        );
      }
      self.setTimeForNode(channel.name, lastInterval);
    }).bind(self);
    return fnReplayOff;
  }
  /**
   * Subscribe to a channel.
   *
   * @param {Channel} channel - Channel to subscribe
   * @param {AugmentedFunction} fn - Callback function to run when a value from a channel changed
   * @param {boolean} previousState
   * @param {Binding} bind
   */
  subscribe(channel, fn, previousState, bind) {
    if (!this.hasSubscription(channel)) {
      let callback = fn;
      let subscription;
      if (previousState === false) {
        callback = this.makeCallbackWithNoReplay(channel, fn);
      }
      let pos = this._firstInstanceOfObserver(this.node, channel);
      if (pos === -1) {
        subscription = channel.subscribe(callback);
      } else {
        subscription = this.subscriptions[pos].subscription;
      }
      const subscriptionDetail = {
        channel,
        bind,
        node: this.node,
        subscription
      };
      this.subscriptions.push(subscriptionDetail);
    }
  }
  /**
   * Remove all active subscriptions.
   *
   * @param {Boolean} cleanPrivateChannels
   */
  unsubscribe(cleanPrivateChannels) {
    this.subscriptions.forEach(({ channel, subscription }) => {
      if (cleanPrivateChannels === true || !channel.name.match(new RegExp(`\\b${BRIDGE_CHANNEL_PREFIX}`))) {
        subscription.unsubscribe();
      }
    });
    this.publications.unsubscribe();
  }
  /**
   * Returns the position of the first occurrence of the observer's node in the channel. If the node
   * has none observer registered to the channel, it returns -1.
   *
   * @param {WCNode} node
   * @param {Channel} channel
   * @returns {number}
   */
  _firstInstanceOfObserver(node, channel) {
    return this.subscriptions.findIndex(
      (subscriptionDetail) => channel === subscriptionDetail.channel && node === subscriptionDetail.subscription.node
    );
  }
};

// node_modules/@open-cells/core/src/utils.js
var dasherize = (str) => str.trim().replace(/[_\s]+/g, "-").replace(/([A-Z])/g, "-$1").replace(/-+/g, "-").toLowerCase();
var camelize = (str) => str.trim().replace(/(-|_|\s)+(.)?/g, (mathc, sep, c) => c ? c.toUpperCase() : "");
var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
var findPropertyInArray = (
  /** @type {function(string): function(any[]): any[]} */
  (prop) => (arr) => arr.map(findProperty(prop)).flat()
);
var findPropertyInObject = (
  /** @type {function(string): function(Object): any[]} */
  (prop) => (collection) => Object.entries(collection).map(([k, v]) => k === prop ? [v] : findProperty(prop)(v)).flat()
);
var findProperty = (
  /** @type {function(string): function( any ): any[]} */
  (prop) => (v) => isPlainObject(v) ? findPropertyInObject(prop)(v) : Array.isArray(v) ? findPropertyInArray(prop)(v) : []
);
var attributeWhiteList = ["ambient", "variant", "disabled"];
var setAttribute = (node, attr, value) => {
  if (typeof value === "boolean") {
    if (value) {
      node.setAttribute(attr, "");
    } else {
      node.removeAttribute(attr);
    }
  } else {
    node.setAttribute(attr, value);
  }
};
var Utils = {
  dasherize,
  camelize,
  findProperty,
  attributeWhiteList,
  setAttribute
};

// node_modules/@open-cells/core/src/adapter/element-adapter.js
var _dashToCamelCase = (input) => {
  return input.toLowerCase().replace(/-(.)/g, function(match, group1) {
    return group1.toUpperCase();
  });
};
var ElementAdapter = class {
  /**
   * Creates a new instance of LitElementAdapter.
   *
   * @param {ComponentConnector} componentConnector - The component connector.
   */
  constructor(componentConnector) {
    /**
     * @typedef {Object} ActionDetail
     * @property {string} path - The path of the action.
     * @property {any} value - The value of the action.
     * @property {string} property - The property of the action.
     */
    /**
     * Parses the action in the event.
     *
     * @private
     * @param {WCEvent} evt - The event.
     * @param {string} targetPath - The target path.
     * @param {HTMLElement} target - The target object.
     * @returns {ActionDetail} - The parsed action.
     */
    __publicField(this, "_parseActionInEvent", (evt, targetPath, target) => {
      let propertyName = this._getPropertyChangedName(evt.type);
      let value;
      let path;
      if (propertyName && evt.detail && Object.prototype.hasOwnProperty.call(evt.detail, "value")) {
        value = evt.detail.value;
        targetPath = targetPath || propertyName;
        if (evt.detail.path) {
          path = evt.detail.path.replace(propertyName, targetPath);
        } else {
          path = targetPath;
        }
      } else {
        path = targetPath;
        value = evt.detail;
      }
      return {
        path,
        value,
        property: targetPath
      };
    });
    this.componentConnector = componentConnector;
  }
  /**
   * Checks if the given node is unresolved.
   *
   * @param {HTMLElement} node - The node to check.
   * @returns {boolean} - True if the node is unresolved, false otherwise.
   */
  isUnresolved(node) {
    const isCustomElement = node.tagName.includes("-");
    const resolved2 = !!window.customElements.get(node.tagName.toLowerCase());
    return isCustomElement && !resolved2;
  }
  /**
   * Checks if the given node is an instance of a web component.
   *
   * @param {HTMLElement} node - The node to check.
   * @returns {boolean} - True if the node is an instance, false otherwise.
   */
  isInstance(node) {
    const isCustomElement = node.tagName.includes("-");
    return isCustomElement && !this.isUnresolved(node);
  }
  /**
   * Returns true if the event has reached the node that is listening the event.
   *
   * @param {WCEvent} event - The event to check.
   * @returns {boolean} - True if the event is at the target, false otherwise.
   */
  isEventAtTarget(event) {
    const AT_TARGET_VALUE = Event.AT_TARGET || Event.prototype.AT_TARGET;
    return event.eventPhase === AT_TARGET_VALUE;
  }
  /**
   * Dispatches an action function.
   *
   * @param {WCEvent} evt - The event.
   * @param {IndexableHTMLElement} target - The target object.
   * @param {Function | string} method - The method to call.
   */
  dispatchActionFunction(evt, target, method) {
    const payload = evt.detail;
    if (typeof method === "function") {
      method(payload);
    } else {
      if (target[method] && typeof target[method] === "function") {
        target[method](payload);
      }
    }
  }
  /**
   * Dispatches an action property.
   *
   * @param {WCEvent} evt - The event.
   * @param {IndexableHTMLElement} target - The target object.
   * @param {string} property - The property to set.
   */
  dispatchActionProperty(evt, target, property) {
    const data = this._parseActionInEvent(evt, property, target);
    if (!attributeWhiteList.includes(property) && target[property]) {
      target[property] = data.value;
    } else {
      setAttribute(target, property, data.value);
    }
  }
  /**
   * Gets the property changed name.
   *
   * @private
   * @param {string} name - The name.
   * @returns {string | undefined} - The property changed name.
   */
  _getPropertyChangedName(name) {
    let propertyName;
    const EVENT_CHANGED = "-changed";
    if (name.indexOf(EVENT_CHANGED, name.length - EVENT_CHANGED.length) !== -1) {
      propertyName = name.slice(0, -EVENT_CHANGED.length);
      propertyName = _dashToCamelCase(propertyName);
    }
    return propertyName;
  }
};

// node_modules/@open-cells/core/src/manager/channel-manager.js
var ChannelManager = class {
  /** Constructs a new ChannelManager. */
  constructor() {
    this.channels = {};
  }
  /**
   * Gets a channel by name.
   *
   * @param {string} name - The name of the channel.
   * @returns {Channel} The channel with the specified name.
   */
  get(name) {
    var channel = this.channels[name];
    if (!channel) {
      channel = this.create(name);
    }
    return channel;
  }
  /**
   * Gets a channel by name.
   *
   * @param {string} name - The name of the channel.
   * @returns {Channel} The channel with the specified name.
   */
  getUnsafe(name) {
    return this.channels[name];
  }
  /**
   * Creates a channel.
   *
   * @param {string} name - The name of the channel.
   * @returns {Channel} The newly created channel.
   */
  create(name) {
    const channel = createChannel(name);
    this.channels[name] = channel;
    return channel;
  }
  /**
   * Removes a channel from the collection.
   *
   * @param {string} name - The name of the channel to remove.
   */
  remove(name) {
    delete this.channels[name];
  }
  /**
   * Gets all channels.
   *
   * @returns {Object<string, Channel>} The channels.
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Sets all channels.
   *
   * @param {Object<string, Channel>} channels - The channels.
   */
  setChannels(channels) {
    this.channels = channels;
  }
  /** Cleans all channels. */
  cleanAllChannels() {
    for (let channelName in this.channels) {
      if (this.channels.hasOwnProperty(channelName)) {
        this.channels[channelName].clean();
      }
    }
  }
  /** Removes all channels from the collection. */
  removeAllChannels() {
    for (let channelName in this.channels) {
      if (this.channels.hasOwnProperty(channelName)) {
        delete this.channels[channelName];
      }
    }
  }
  /**
   * Checks if a channel with the given name exists.
   *
   * @param {string} name - The name of the channel.
   * @returns {boolean} True if a channel with the given name exists, false otherwise.
   */
  has(name) {
    return this.channels[name] != null;
  }
};

// node_modules/@open-cells/core/src/component-connector.js
var { externalEventsCodes: externalEventsCodes2 } = Constants;
var ComponentConnector = class {
  /** Creates a new instance of ComponentConnector. */
  constructor() {
    this.adapter = new ElementAdapter(this);
    this.manager = new ChannelManager();
    this.subscriptors = /* @__PURE__ */ new Map();
    this.bridgeChannelsPrefix = new RegExp(`${BRIDGE_CHANNEL_PREFIX}_(?!ch)`);
  }
  /**
   * Get a subscriptor for the given node. If the subscriptor does not exist, a new one will be
   * created.
   *
   * @param {WCNode} node - The node to get the subscriptor for.
   * @returns {Subscriptor} The subscriptor for the given node.
   */
  getSubscriptor(node) {
    let subscriptor = this.subscriptors.get(node);
    if (!subscriptor) {
      subscriptor = new Subscriptor(node);
      this.subscriptors.set(node, subscriptor);
    }
    return subscriptor;
  }
  /**
   * Add a subscription to a node with a channel.
   *
   * @param {string} channelName - The name of the channel.
   * @param {WCNode} node - The node to add the subscription to.
   * @param {Binding} bind - The bind object.
   * @param {boolean} [previousState=false] - The previous state flag. Default is `false`
   */
  addSubscription(channelName, node, bind, previousState = false) {
    const callback = this._wrapCallbackWithNode(node, bind);
    const channel = this.manager.get(channelName);
    if (channel) {
      const subscriptor = this.getSubscriptor(node);
      subscriptor.subscribe(channel, callback, previousState, bind);
    }
  }
  /**
   * Get a channel by name.
   *
   * @param {string} channelName - The name of the channel.
   * @returns {Channel} The channel.
   */
  getChannel(channelName) {
    return this.manager.get(channelName);
  }
  /**
   * Get all channels.
   *
   * @returns {Object<string, Channel>} The channels.
   */
  getChannels() {
    return this.manager.getChannels();
  }
  /**
   * Set the channels.
   *
   * @param {Object<string, Channel>} channels - The channels.
   */
  setChannels(channels) {
    this.manager.setChannels(channels);
  }
  /** Clean all channels. */
  cleanAllChannels() {
    this.manager.cleanAllChannels();
  }
  /**
   * Update a subscription to a node with a channel.
   *
   * @param {string} channelName - The name of the channel.
   * @param {WCNode} node - The node to update the subscription for.
   * @param {Binding} bind - The bind object.
   * @param {boolean} [previousState=false] - The previous state flag. Default is `false`
   */
  updateSubscription(channelName, node, bind, previousState = false) {
    const subscriptor = this.getSubscriptor(node);
    if (this.isActiveBridgeChannel(channelName) || !this.isActiveBridgeChannel(channelName) && !this.hasSubscriptions(subscriptor, channelName)) {
      const channel = this.manager.get(channelName);
      const callback = this._wrapCallbackWithNode(node, bind);
      subscriptor.subscribe(channel, callback, previousState, bind);
    }
  }
  /**
   * Wrap a callback function with the given node and bind name.
   *
   * @param {WCNode} node - The node to wrap the callback with.
   * @param {Binding} bindName - The bind name.
   * @returns {AugmentedFunction} The wrapped callback function.
   */
  _wrapCallbackWithNode(node, bindName) {
    return this.wrapCallback(node, bindName);
  }
  /**
   * Wrap a callback function with the given node and bind name.
   *
   * @param {IndexableHTMLElement} node - The node to wrap the callback with.
   * @param {Binding} bindName - The bind name.
   * @returns {AugmentedFunction} The wrapped callback function. re t urns {function(Event): void} -
   *   The wrapped callback function that expects an Event parameter and returns void.
   */
  wrapCallback(node, bindName) {
    const _idleCallback = (fn) => {
      setTimeout(function() {
        if ("requestIdleCallback" in window) {
          window.requestIdleCallback(fn);
        } else {
          setTimeout(fn, 1);
        }
      }, 100);
    };
    const wrappedCallback = (evt) => {
      const checkComponentResolution = (mutationsList, observerObject) => {
        if (!this.adapter.isUnresolved(node)) {
          checkDispatchActionType();
          if (observerObject) {
            observerObject.disconnect();
          }
        } else {
          _idleCallback(checkDispatchActionType);
        }
      };
      const checkDispatchActionType = () => {
        if (typeof bindName === "function" || typeof node[bindName] === "function") {
          this.adapter.dispatchActionFunction(evt, node, bindName);
        } else {
          this.adapter.dispatchActionProperty(evt, node, bindName);
        }
      };
      if (this.adapter.isUnresolved(node)) {
        var observer = new MutationObserver(checkComponentResolution);
        var config2 = { attributes: false, childList: true, characterData: true };
        observer.observe(node, config2);
        _idleCallback(checkDispatchActionType);
      } else {
        checkDispatchActionType();
      }
    };
    Object.defineProperty(
      wrappedCallback,
      /** @type {WCNode} */
      "node",
      {
        writable: true,
        configurable: true,
        enumerable: true
      }
    );
    return wrappedCallback;
  }
  /**
   * Check if a node has a publisher for the given channel and bind name.
   *
   * @param {Subscriptor} subscriptor - The subscriptor to check.
   * @param {WCNode} node - The node to check.
   * @param {string} channelName - The name of the channel.
   * @param {string} bindName - The bind name.
   * @returns {boolean} True if the node has a publisher, false otherwise.
   */
  _hasPublisher({ publications }, node, channelName, bindName) {
    return Boolean(
      (publications._subscriptions || []).find(
        (publication) => publication.node === node && publication.channelName === channelName && publication.eventName === bindName
      )
    );
  }
  /**
   * Add a publicator to a node.
   *
   * @param {string} channelName - The name of the channel.
   * @param {WCNode} node - The node to add the publicator to.
   * @param {string} bindName - The bind name.
   * @param {Connection | undefined} outConnectionDefinition - The out connection definition.
   */
  addPublication(channelName, node, bindName, outConnectionDefinition) {
    if (this.isBridgeChannel(channelName)) {
      console.warn(
        `Forbidden operation. You are trying to write to a private channel (${channelName}).`
      );
    } else {
      let subscriptor = this.getSubscriptor(node);
      let hasPublisher = this._hasPublisher(subscriptor, node, channelName, bindName);
      if (!hasPublisher) {
        let channel = this.manager.get(channelName);
        subscriptor.publish(this._wrapEvent(node, bindName, channel, outConnectionDefinition));
      }
    }
  }
  /**
   * Publish a value to the given channel.
   *
   * @param {string} channelName - The name of the channel.
   * @param {Object} value - The value to publish.
   */
  publish(channelName, value) {
    if (this.isBridgeChannel(channelName)) {
      console.warn(
        `Forbidden operation. You are trying to write to a private channel (${channelName}).`
      );
    } else {
      const channel = this.manager.get(channelName);
      const customEventName = `${channelName}-publish`;
      channel.next(new CustomEvent(customEventName, { detail: value }));
    }
  }
  /**
   * Unsubscribe a node from the given channels.
   *
   * @param {string | string[]} channels - The channels to unsubscribe from.
   * @param {WCNode} node - The node to unsubscribe.
   */
  unsubscribe(channels, node) {
    var _a;
    if (!channels || !node) {
      return;
    }
    const normalizedChannels = Array.isArray(channels) ? channels : [channels];
    const subscriptor = this.subscriptors.get(node);
    const byChannelName = (subscription) => {
      var _a2, _b;
      return ((_a2 = subscription.channel) == null ? void 0 : _a2.name) && normalizedChannels.includes((_b = subscription.channel) == null ? void 0 : _b.name);
    };
    const filterAndRemove = (sub) => {
      if (byChannelName(sub)) {
        sub.subscription.unsubscribe();
        return false;
      }
      return true;
    };
    if (!subscriptor) {
      return;
    }
    subscriptor.subscriptions = (_a = subscriptor.subscriptions) == null ? void 0 : _a.filter(filterAndRemove);
  }
  /**
   * Unregister a node from pubsub.
   *
   * @param {WCNode | undefined} node - The node to unregister.
   * @param {boolean} cleanPrivateChannels - The private channels to clean.
   */
  unregisterComponent(node, cleanPrivateChannels) {
    if (!node) {
      return;
    }
    const subscriptor = this.subscriptors.get(node);
    if (subscriptor) {
      subscriptor.unsubscribe(cleanPrivateChannels);
      this.subscriptors.delete(node);
    }
  }
  /**
   * Unregister all subscriptors and clean private channels.
   *
   * @param {boolean} cleanPrivateChannels - The private channels to clean.
   */
  unregisterAllSubscriptors(cleanPrivateChannels) {
    this.subscriptors.forEach((s) => s.unsubscribe(cleanPrivateChannels));
    this.subscriptors = /* @__PURE__ */ new Map();
  }
  /**
   * Wrap an event with the given node, event name, channel, and connection.
   *
   * @param {WCNode} node - The node to wrap the event with.
   * @param {string} eventName - The event name.
   * @param {Channel} channel - The channel.
   * @param {Connection | undefined} connection - The connection definition.
   * @returns {WCSubscription} The wrapped event function.
   */
  _wrapEvent(node, eventName, channel, connection) {
    const { AFTER_PUBLISH, NAV_REQUEST, ROUTER_BACKSTEP, TRACK_EVENT, LOG_EVENT } = externalEventsCodes2;
    const source = fromEvent(node, eventName);
    const wrappedListener = source.subscribe((event) => {
      if (!this.adapter.isEventAtTarget(event)) {
        return;
      }
      channel.next(event);
      eventManager.emit(AFTER_PUBLISH, event);
      if (connection && connection.link) {
        const linkObject = Object.assign({}, connection.link);
        if (connection.link.page) {
          if (connection.link.page.hasOwnProperty("bind")) {
            linkObject.page = event.detail[connection.link.page.bind];
          }
        }
        if (connection.link.cleanUntil) {
          if (connection.link.cleanUntil.hasOwnProperty("bind")) {
            linkObject.cleanUntil = event.detail[connection.link.cleanUntil.bind];
          }
        }
        eventManager.emit(NAV_REQUEST, {
          event,
          detail: linkObject
        });
      }
      if (connection && connection.backStep) {
        eventManager.emit(ROUTER_BACKSTEP, {
          event,
          detail: {}
        });
      }
      if (connection && connection.analytics) {
        eventManager.emit(TRACK_EVENT, {
          event,
          detail: connection.analytics
        });
      }
      if (connection && connection.log) {
        eventManager.emit(LOG_EVENT, {
          event,
          detail: connection.log
        });
      }
    });
    Object.defineProperty(
      wrappedListener,
      /** @type {WCNode} */
      "node",
      {
        value: node,
        writable: true,
        configurable: true,
        enumerable: true
      }
    );
    Object.defineProperty(
      wrappedListener,
      /** @type {string} */
      "eventName",
      {
        value: eventName,
        writable: true,
        configurable: true,
        enumerable: true
      }
    );
    Object.defineProperty(
      wrappedListener,
      /** @type {string} */
      "channelName",
      {
        value: channel.name,
        writable: true,
        configurable: true,
        enumerable: true
      }
    );
    Object.defineProperty(
      wrappedListener,
      /** @type {Connection} */
      "options",
      {
        value: connection,
        writable: true,
        configurable: true,
        enumerable: true
      }
    );
    return wrappedListener;
  }
  /**
   * Create a new event with the given name and value.
   *
   * @param {string} name - The name of the event.
   * @param {Object} value - The value of the event.
   * @returns {WCEvent} The created event.
   */
  createEvent(name, value) {
    const evt = new Event(name);
    evt.detail = { value };
    return evt;
  }
  /**
   * Check if a channel with the given name is an active bridge channel.
   *
   * @param {string} name - The name of the channel.
   * @returns {boolean} True if the channel is an active bridge channel, false otherwise.
   */
  isActiveBridgeChannel(name) {
    if (this.manager.getUnsafe(name)) {
      return this.isBridgeChannel(name);
    } else {
      return false;
    }
  }
  /**
   * Check if a channel with the given name is a bridge channel.
   *
   * @param {string} name - The name of the channel.
   * @returns {boolean} True if the channel is a bridge channel, false otherwise.
   */
  isBridgeChannel(name) {
    return this.bridgeChannelsPrefix.test(name);
  }
  /**
   * Check if the given subscriptor has subscriptions to the given channel.
   *
   * @param {Subscriptor} subscriptor - The subscriptor to check.
   * @param {string} channelName - The name of the channel.
   * @returns {boolean} True if the subscriptor has subscriptions, false otherwise.
   */
  hasSubscriptions(subscriptor, channelName) {
    return Boolean(subscriptor.subscriptions.find((d) => d.channel.name === channelName));
  }
};

// node_modules/@open-cells/core/src/route.js
var _Route = class _Route {
  /**
   * Creates a new Route instance.
   *
   * @param {string} name - The name of the route.
   * @param {string | string[]} pattern - The pattern(s) of the route.
   * @param {Function} action - The action to be performed when the route is matched.
   * @param {boolean} [notFound=false] - Indicates whether the route represents the 404 page.
   * @param {string | undefined} component - The name of component.
   *   Default is `false`
   */
  constructor(name, pattern, action, notFound = false, component = void 0) {
    /**
     * The name of the route.
     *
     * @type {string}
     */
    __publicField(this, "name", "");
    /**
     * The parameters of the route.
     *
     * @type {QueryParams}
     * @t ype {{ [key: string]: string | number }}
     */
    __publicField(this, "params", {});
    /**
     * The patterns of the route.
     *
     * @type {string[]}
     */
    __publicField(this, "patterns", [""]);
    /**
     * The regular expressions derived from the route patterns.
     *
     * @type {RegExp[]}
     */
    __publicField(this, "regexps");
    /**
     * The page to redirect to.
     *
     * @type {string | null}
     */
    __publicField(this, "redirectPage", null);
    /**
     * Indicates whether the route is accessible.
     *
     * @type {boolean}
     */
    __publicField(this, "isAccessible", true);
    /**
     * Indicates whether the route is wildcarded.
     *
     * @type {boolean}
     */
    __publicField(this, "isWildcarded", false);
    this.name = name;
    this.patterns = typeof pattern === "string" ? [pattern] : pattern;
    this.action = action;
    this.notFound = notFound;
    this.component = component;
    this.regexps = this.patterns.map((p) => this._getRegExp(p));
  }
  /**
   * Sanitizes a route pattern and returns a regular expression for matching the route.
   *
   * @param {string} p - The route pattern.
   * @returns {RegExp} - The regular expression for matching the route.
   */
  _getRegExp(p) {
    let urlPattern = p;
    let regex;
    let trailingSlashesReplacement = "/*";
    let regExEnding = "$";
    const indexOfWildcard = urlPattern.indexOf("*");
    if (indexOfWildcard >= 0) {
      this.isWildcarded = true;
      urlPattern = urlPattern.substring(0, indexOfWildcard);
      trailingSlashesReplacement = "/+";
      regExEnding = "";
    }
    let regexpStr = urlPattern.replace(_Route.PARAM, "([^/]+)").replace(_Route.TRAILING_SLASHES, trailingSlashesReplacement);
    return new RegExp("^" + regexpStr + regExEnding);
  }
  /**
   * Generates a path for the route using the specified parameters.
   *
   * @param {QueryParams | undefined} params - The parameters for generating the path.
   * @returns {string} - The generated path.
   */
  path(params) {
    params = params || {};
    this.params = {};
    let parts;
    let path = this.patterns[0];
    while ((parts = _Route.PARAM.exec(this.patterns[0])) !== null) {
      path = path.replace(parts[0], "" + params[parts[1]]);
      this.params[parts[1]] = params[parts[1]];
    }
    const queryParams = [];
    for (let param in params) {
      if (!this.params.hasOwnProperty(param)) {
        queryParams.push(param + "=" + encodeURIComponent(params[param]));
      }
    }
    if (queryParams.length) {
      path += "?" + queryParams.join("&");
    }
    return path;
  }
  /**
   * Matches the specified path against the route patterns and returns the matching information.
   *
   * @param {string} path - The path to match.
   * @returns {?{
   *   index: number;
   *   parts: RegExpExecArray;
   *   pattern: string;
   *   regex: RegExp;
   * }}
   *   - The matching information, or null if no match is found.
   */
  matchPath(path) {
    let match = null;
    this.regexps.forEach((re, i) => {
      let result = path.match(re);
      if (result) {
        match = {
          index: i,
          regex: this.regexps[i],
          pattern: this.patterns[i],
          parts: result
        };
      }
    });
    return match;
  }
  /**
   * Parses the specified path and extracts the route parameters.
   *
   * @param {string} path - The path to parse.
   */
  parsePath(path) {
    let match = this.matchPath(path);
    this.params = {};
    this.subroute = void 0;
    if (match) {
      let i = 1;
      let parts;
      if (match.parts[0] !== match.parts.input) {
        this.subroute = match.parts.input.substring(match.parts[0].length - 1);
      }
      while ((parts = _Route.PARAM.exec(match.pattern)) !== null) {
        this.params[parts[1]] = this._parseParam(match.parts[i]);
        i++;
      }
    }
  }
  /**
   * Parses the specified query string and adds the parameters to the route.
   *
   * @param {any} query - The query string or object.
   */
  parseQuery(query) {
    this.query = query;
    for (let queryParam in this.query) {
      if (this.query.hasOwnProperty(queryParam)) {
        this.params[queryParam] = this.query[queryParam];
      }
    }
  }
  /**
   * Checks if the route represents the 404 page.
   *
   * @returns {boolean} - True if the route represents the 404 page, false otherwise.
   */
  is404() {
    return this.notFound === true;
  }
  /**
   * Checks if a value is a number.
   *
   * @private
   * @param {string} value - The value to check.
   * @returns {boolean} - True if the value is a number, false otherwise.
   */
  _isNumber(value) {
    return parseInt(value) + "" === value || parseFloat(value) + "" === value;
  }
  /**
   * Parses a route parameter and returns it as a string or number.
   *
   * @private
   * @param {string} param - The route parameter to parse.
   * @returns {string | number} - The parsed route parameter.
   */
  _parseParam(param) {
    return this._isNumber(param) ? +param : param;
  }
  /** Placeholder method for handling the current route. */
  handler() {
  }
};
/**
 * Regular expression to match route parameters in a route pattern.
 *
 * @type {RegExp}
 */
__publicField(_Route, "PARAM", /(?::([^/]+))/g);
/**
 * Regular expression to match trailing slashes in a route pattern.
 *
 * @type {RegExp}
 */
__publicField(_Route, "TRAILING_SLASHES", /\/*$/);
var Route = _Route;

// node_modules/@open-cells/core/src/navigation-stack.js
var NavigationStack = class {
  /** Constructs a new NavigationStack object. */
  constructor() {
    this.navStack = [];
    this.skipNav = {};
  }
  /**
   * Gets the length of the navigation stack.
   *
   * @returns {number} The length of the navigation stack.
   */
  get length() {
    return this.navStack.length;
  }
  /**
   * Adds a skip navigation entry to the navigation stack.
   *
   * @param {Navigation} nav - The navigation object.
   */
  addSkipNavigation(nav) {
    if (nav.skipHistory === true || nav.skipHistory === false) {
      this.skipNav[`${nav.from}:${nav.to}`] = nav.skipHistory;
    }
  }
  /**
   * Reverses a navigation object.
   *
   * @param {Navigation} nav - The navigation object to reverse.
   * @returns {Navigation} The reversed navigation object.
   */
  _reverseNavigation(nav) {
    return {
      from: nav.to,
      to: nav.from
    };
  }
  /**
   * Checks if a navigation is marked as skip navigation.
   *
   * @param {Navigation} nav - The navigation object to check.
   * @returns {boolean} True if the navigation is marked as skip navigation, false otherwise.
   */
  isSkipNavigation(nav) {
    return this.skipNav[`${nav.from}:${nav.to}`] === true;
  }
  /**
   * Gets the last navigation object in the navigation stack.
   *
   * @returns {Navigation} The last navigation object.
   */
  lastNavigation() {
    const navCount = this.navStack.length;
    let from2;
    let to;
    if (navCount === 1) {
      to = this.navStack[0];
    } else if (navCount > 1) {
      to = this.navStack[navCount - 1];
      from2 = this.navStack[navCount - 2];
    }
    return this.createNavigation(from2, to);
  }
  /**
   * Creates a route object.
   *
   * @param {string} page - The page name.
   * @param {QueryParams} params - The route parameters.
   * @returns {RoutePage} The created route object.
   */
  createRoute(page, params = {}) {
    return {
      page,
      params
    };
  }
  /**
   * Creates a navigation object.
   *
   * @param {RoutePage | undefined} routeFrom - The route object representing the starting page.
   * @param {RoutePage | undefined} routeTo - The route object representing the destination page.
   * @returns {Navigation} The created navigation object.
   */
  createNavigation(routeFrom, routeTo) {
    return {
      from: routeFrom ? routeFrom.page : void 0,
      to: routeTo ? routeTo.page : void 0
    };
  }
  /**
   * Pushes a route object to the navigation stack.
   *
   * @param {RoutePage} route - The route object to push.
   */
  push(route) {
    var _a;
    if (!this.top() || ((_a = this.top()) == null ? void 0 : _a.page) !== route.page) {
      this.navStack.push(route);
    }
  }
  /**
   * Replaces the top route object in the navigation stack with a new route object.
   *
   * @param {RoutePage} route - The new route object.
   */
  replace(route) {
    var _a;
    if (!this.top() || ((_a = this.top()) == null ? void 0 : _a.page) !== route.page) {
      this.navStack[this.navStack.length - 1] = route;
    }
  }
  /**
   * Removes and returns the top route object from the navigation stack.
   *
   * @returns {RoutePage | undefined} The top route object, or undefined if the navigation stack is
   *   empty.
   */
  pop() {
    return this.navStack.pop();
  }
  /**
   * Returns the top route object from the navigation stack without removing it.
   *
   * @returns {RoutePage | undefined} The top route object, or undefined if the navigation stack is
   *   empty.
   */
  top() {
    return this.navStack.length > 0 ? this.navStack[this.navStack.length - 1] : void 0;
  }
  /**
   * Checks if a navigation is a backward navigation.
   *
   * @param {Navigation} newNav - The new navigation object.
   * @returns {boolean} True if the navigation is a backward navigation, false otherwise.
   */
  isBackwardNavigation(newNav) {
    const lastNav = this.lastNavigation();
    return lastNav && newNav.from === lastNav.to && newNav.to === lastNav.from;
  }
  /**
   * Updates the navigation stack based on the given route objects.
   *
   * @param {RoutePage} routeFrom - The route object representing the starting page.
   * @param {RoutePage} routeTo - The route object representing the destination page.
   * @returns {RoutePage | undefined} The top route object after the update.
   */
  update(routeFrom, routeTo) {
    const nav = this.createNavigation(routeFrom, routeTo);
    if (this.isBackwardNavigation(nav)) {
      while (this.isSkipNavigation(this._reverseNavigation(this.lastNavigation()))) {
        this.pop();
      }
      this.pop();
    } else {
      this.push(routeTo);
    }
    return this.top();
  }
  /** Clears the navigation stack. */
  clear() {
    this.navStack = [];
  }
  /**
   * Replaces the top route object in the navigation stack with a new route object, or pushes the
   * new route object if the navigation stack is empty.
   *
   * @param {RoutePage} route - The new route object.
   */
  replaceRoute(route) {
    if (this.navStack.length > 0) {
      this.navStack[this.navStack.length - 1] = route;
    } else {
      this.push(route);
    }
  }
  /**
   * Clears the navigation stack until the specified page is found.
   *
   * @param {string} targetPage - The page name to clear until.
   */
  clearUntil(targetPage) {
    if (this.navStack.find((route) => route.page === targetPage)) {
      let currentRoute = null;
      do {
        currentRoute = this.navStack.pop();
      } while (currentRoute && currentRoute.page != targetPage);
    }
  }
};

// node_modules/@open-cells/core/src/router.js
var EMPTY2 = Subscription.EMPTY;
var { externalEventsCodes: externalEventsCodes3 } = Constants;
var instance = null;
var _useHistory = false;
var _routes = {};
var _disposables;
var _currentRoute;
var _404Route;
var SerialSubscription = class extends Subscription {
  constructor() {
    super();
    this._currentSubscription = EMPTY2;
  }
  /**
   * Adds a tear down to be called during the unsubscribe() of this Subscription.
   *
   * If there's existing subscription, it'll be unsubscribed and removed.
   *
   * @param {() => void} teardown The additional logic to execute on teardown.
   */
  add(teardown) {
    if (this.closed) return;
    const newSubscription = new Subscription(teardown);
    if (this._currentSubscription) {
      this.remove(this._currentSubscription);
      this._currentSubscription.unsubscribe();
      this._currentSubscription = EMPTY2;
    }
    this._currentSubscription = newSubscription;
    super.add(teardown);
  }
  // add(teardown) {
  //   if (this.closed) return;
  //   if (typeof teardown === 'function') teardown = new Subscription(teardown);
  //   if (this._currentSubscription) {
  //     this.remove(this._currentSubscription);
  //     this._currentSubscription.unsubscribe();
  //     this._currentSubscription = null;
  //   }
  //   super.add((this._currentSubscription = teardown));
  // }
};
var _Router = class _Router {
  /**
   * Represents the constructor of the Router class.
   *
   * @class
   */
  constructor() {
    /**
     * Represents the navigation stack.
     *
     * @type {NavigationStack}
     */
    __publicField(this, "navigationStack");
    /**
     * The channel manager handles the communication channels in the router. It is responsible for
     * managing the creation, deletion, and routing of channels.
     *
     * @type {BridgeChannelManager | null}
     */
    __publicField(this, "_channelManager", null);
    /**
     * The context object for interceptors.
     *
     * @type {Object}
     */
    __publicField(this, "interceptorContext", {});
    const { TEMPLATE_TRANSITION_END } = externalEventsCodes3;
    if (!instance) {
      instance = this;
    }
    this.navigationStack = this._createNavigationStack();
    eventManager.on(TEMPLATE_TRANSITION_END, () => {
      this.isNavigationInProgress = false;
    });
    return instance;
  }
  /**
   * Creates a new navigation stack.
   *
   * @returns {NavigationStack} The newly created navigation stack.
   */
  _createNavigationStack() {
    return new NavigationStack();
  }
  /**
   * Setter for the useHistory property.
   *
   * @param {boolean} value - The value to set for useHistory.
   */
  set useHistory(value) {
    if (_Router.SUPPORTS_HISTORY_API) {
      _useHistory = value;
    }
  }
  /**
   * Getter for the useHistory property.
   *
   * @returns {boolean} The useHistory object.
   */
  get useHistory() {
    return _useHistory;
  }
  /**
   * Setter for the channelManager property.
   *
   * @param {BridgeChannelManager} channelManager - The channel manager to be set.
   */
  set channelManager(channelManager) {
    this._channelManager = channelManager;
  }
  /**
   * Getter for the channelManager property.
   *
   * @returns {BridgeChannelManager | null} The channel manager.
   */
  get channelManager() {
    return this._channelManager;
  }
  /**
   * Setter for the routes property.
   *
   * @param {{ [key: string]: Route }} routes - The routes to be set.
   */
  set routes(routes) {
    _routes = routes;
  }
  /**
   * Get the routes.
   *
   * @returns {{ [key: string]: Route }} The routes.
   */
  get routes() {
    return _routes;
  }
  /**
   * Gets the current route.
   *
   * @returns {Route} The current route.
   */
  get currentRoute() {
    return _currentRoute;
  }
  /**
   * Sets the current route.
   *
   * @param {Route} route - The current route.
   */
  set currentRoute(route) {
    _currentRoute = route;
  }
  /** @param {Route} route */
  // eslint-disable-next-line no-unused-vars
  handler(route) {
  }
  /**
   * Adds a route to the router.
   *
   * @param {string} name - The name of the route.
   * @param {string | string[]} patterns - The patterns associated with the route.
   * @param {Function} action - The action to be executed when the route is matched.
   * @param {boolean} notFound - Indicates whether the route is the 404 page. Default is `false`.
   * @param {string | undefined} component - The name of component.
   * @returns {Route} - The newly added route.
   */
  addRoute(name, patterns, action, notFound, component) {
    this.routes[name] = new Route(name, patterns, action, notFound, component);
    return this.routes[name];
  }
  /**
   * Adds routes to the router.
   *
   * @param {ParsedRoute | undefined} routes
   */
  addRoutes(routes) {
    if (!routes) {
      throw new Error("Routes must be defined");
    }
    for (let routeName in routes) {
      if (routes.hasOwnProperty(routeName)) {
        const { path, action, notFound, component } = routes[routeName];
        this.addRoute(routeName, path, action, notFound, component);
      }
    }
  }
  /**
   * Adds skip navigations to the router.
   *
   * @param {Navigation[]} skipNavs - The skip navigations to be added.
   */
  addSkipNavigations(skipNavs) {
    for (let i = 0; i < skipNavs.length; i++) {
      this.navigationStack.addSkipNavigation(skipNavs[i]);
    }
  }
  /**
   * Returns the hash path by replacing the hash prefix and empty values.
   *
   * @returns {string} The hash path.
   */
  _getHashPath() {
    return location.hash.replace(_Router.HASH_PREFIX, "/").replace(_Router.EMPTY, "/");
  }
  /**
   * Observes the hash change event and returns an observable that emits the hash path.
   *
   * @returns {ObservableString} An observable that emits the hash path.
   */
  _observeHashChange() {
    return fromEvent(window, "hashchange").pipe(
      map(this._getHashPath),
      startWith(this._getHashPath())
    );
  }
  /**
   * Returns the URL path by replacing the Router.PATH_PREFIX with a forward slash.
   *
   * @returns {string} The URL path.
   */
  _getURLPath() {
    return location.pathname.replace(_Router.PATH_PREFIX, "/");
  }
  /**
   * Observes changes in the browser's state (popstate and pushstate events) and returns an
   * Observable that emits the URL path whenever a state change occurs.
   *
   * @returns {ObservableString} An Observable that emits the URL path on state changes.
   */
  _observeStateChange() {
    return merge(fromEvent(window, "popstate"), fromEvent(window, "pushstate")).pipe(
      map(this._getURLPath),
      startWith(this._getURLPath())
    );
  }
  /**
   * Matches the given full path against the defined routes and returns the matching route.
   *
   * @param {string} fullPath - The full path to match against the routes.
   * @returns {Route | undefined} - The matching route object, or undefined if no match is found.
   */
  matchRoute(fullPath) {
    const [path, query] = fullPath.split("?");
    const queryObject = this._parseQuery(query);
    for (let routeName in this.routes) {
      if (this.routes.hasOwnProperty(routeName)) {
        const route = this.routes[routeName];
        if ((!route.is404() || route.isAccessible) && route.matchPath(path)) {
          if (route.isWildcarded) {
            route.parsePath(fullPath);
          } else {
            route.parsePath(path);
            route.parseQuery(queryObject);
          }
          return route;
        }
      }
    }
    return void 0;
  }
  /**
   * Parses a query string and returns an object containing key-value pairs.
   *
   * @param {string} queryStr - The query string to be parsed.
   * @returns {QueryParams} - An object containing the parsed key-value pairs.
   */
  _parseQuery(queryStr) {
    const params = {};
    if (queryStr) {
      const queries = queryStr.split("&");
      if (queries) {
        let key, value, i, len = queries.length;
        for (i = 0; i < len; i++) {
          [key, value] = queries[i].split("=");
          params[key] = decodeURIComponent(value);
        }
      }
    }
    return params;
  }
  /**
   * Sets up the 404 route.
   *
   * @returns {Route | null} The 404 route object.
   */
  _setup404() {
    const route404 = Object.values(this.routes).find((route) => route.is404()) || null;
    if (route404 && route404.patterns.length === 1) {
      const routeWithSamePattern = this.getRouteWithPattern(route404.patterns[0]);
      route404.redirectPage = route404.name;
      route404.isAccessible = true;
    }
    return route404;
  }
  /**
   * Returns the route that matches the given pattern.
   *
   * @param {string} patternToMatch - The pattern to match against the routes.
   * @returns {Route | null} - The matching route, or null if no match is found.
   */
  getRouteWithPattern(patternToMatch) {
    for (let routeName in this.routes) {
      if (this.routes.hasOwnProperty(routeName)) {
        let route = this.routes[routeName];
        if (!route.is404() && route.patterns.includes(patternToMatch)) {
          return route;
        }
      }
    }
    return null;
  }
  /**
   * Interceptor function that is called during navigation.
   *
   * @param {NavigationWithParams} navigation - The navigation object.
   * @param {Object} context - The context object.
   * @returns {{ intercept: boolean }} - An object with an 'intercept' property indicating whether
   *   the navigation should be intercepted.
   */
  interceptor(navigation, context) {
    return { intercept: false };
  }
  /**
   * Intercepts the navigation from one route to another.
   *
   * @param {RoutePage} routeFrom - The route object representing the current route.
   * @param {Route} routeTo - The route object representing the target route.
   * @returns {{
   *   from: RoutePage;
   *   to: RoutePage;
   *   [redirect: string];
   *   intercept: boolean;
   * }}
   *   - The intercepted navigation object.
   */
  intercept(routeFrom, routeTo) {
    const navigation = {
      from: {
        page: routeFrom.page,
        params: routeFrom.params
      },
      to: {
        page: routeTo.name,
        path: routeTo.patterns[0],
        params: routeTo.params
      }
    };
    return { ...this.interceptor(navigation, this.interceptorContext), ...navigation };
  }
  /**
   * Updates the interceptor context with the provided values.
   *
   * @param {Object} ctx - The new values to be merged into the interceptor context.
   */
  updateInterceptorContext(ctx) {
    this.interceptorContext = Object.assign({}, this.interceptorContext, ctx);
  }
  /**
   * Sets the interceptor context.
   *
   * @param {Object} ctx - The context object.
   */
  setInterceptorContext(ctx) {
    this.interceptorContext = Object.assign({}, ctx);
  }
  /**
   * Returns the interceptor context.
   *
   * @returns {Object} The interceptor context.
   */
  getInterceptorContext() {
    return Object.assign({}, this.interceptorContext);
  }
  /**
   * Starts the router and initializes the necessary subscriptions and event listeners.
   *
   * @returns {Subscription} The subscription object that can be used to unsubscribe from the
   *   router.
   */
  start() {
    if (!_disposables) {
      const active = new SerialSubscription();
      _404Route = this._setup404();
      const source = this.useHistory ? this._observeStateChange() : this._observeHashChange();
      const subscription = source.pipe(
        distinctUntilChanged(),
        map(this.matchRoute.bind(this)),
        filter((r) => {
          var _a;
          if (r && r.name === this.cancelledNavigation) {
            this.cancelledNavigation = void 0;
            this.isNavigationInProgress = false;
            if (this.currentRoute.name !== ((_a = this.navigationStack.top()) == null ? void 0 : _a.page)) {
              this.navigationStack.push({
                page: this.currentRoute.name,
                params: this.currentRoute.params
              });
            }
            return false;
          } else return true;
        })
      );
      subscription.forEach((route) => {
        var _a, _b, _c;
        if (!this.hashIsDirty) {
          if (route) {
            const currentRouteName = (_a = this.currentRoute) == null ? void 0 : _a.name;
            const currentRouteParams = (_b = this.currentRoute) == null ? void 0 : _b.params;
            const routeFrom = this.navigationStack.createRoute(
              currentRouteName,
              currentRouteParams
            );
            const routeTo = this.navigationStack.createRoute(route.name, route.params);
            const interceptorResult = this.intercept(routeFrom, route);
            if (interceptorResult.intercept) {
              this.isNavigationInProgress = false;
              if (interceptorResult.redirect) {
                this.goReplacing(
                  interceptorResult.redirect.page,
                  interceptorResult.redirect.params
                );
              } else {
                this.go(currentRouteName, currentRouteParams, false);
                this.cancelledNavigation = currentRouteName;
              }
              if (this.channelManager) {
                setTimeout(() => {
                  var _a2;
                  const interceptedNavigation = {
                    from: interceptorResult.from.page,
                    to: interceptorResult.to.page
                  };
                  (_a2 = this.channelManager) == null ? void 0 : _a2.publishInterceptedNavigation(interceptedNavigation);
                }, 0);
              }
              return;
            } else {
              const newRouteName = (_c = this.navigationStack.update(routeFrom, routeTo)) == null ? void 0 : _c.page;
              if (newRouteName && newRouteName !== routeTo.page) {
                this.go(newRouteName, void 0, false);
                return;
              }
            }
            _currentRoute = route;
            const disposable = new Subscription(() => this.currentRoute);
            const dispose = () => disposable.unsubscribe();
            active.add(dispose);
            this.currentRoute.handler();
            this.handler(this.currentRoute);
          } else if (_404Route == null ? void 0 : _404Route.redirectPage) {
            this.goReplacing(_404Route.redirectPage);
          }
        } else {
          this.hashIsDirty = false;
        }
      });
      _disposables = active;
    }
    return _disposables;
  }
  /** Stops the router and cleans up any resources. */
  stop() {
    if (_disposables) {
      _disposables.unsubscribe();
      _disposables = null;
    }
    this.isNavigationInProgress = false;
    this.hashIsDirty = false;
  }
  /** Destroys the router by stopping it and clearing the routes. */
  destroy() {
    this.stop();
    this.routes = {};
  }
  /**
   * Returns the resolved path for a given route name and parameters.
   *
   * @param {string} routeName - The name of the route.
   * @param {QueryParams | undefined} params - The parameters for the route.
   * @returns {string | undefined} The resolved path.
   */
  getPath(routeName, params) {
    const route = this.routes[routeName];
    if (route) {
      let resolvedPath;
      const routeWithParams = route.path(params);
      const idxQueryParams = routeWithParams.indexOf("?");
      if (idxQueryParams > -1) {
        const path = routeWithParams.substring(0, idxQueryParams);
        const queryParams = routeWithParams.substring(idxQueryParams);
        resolvedPath = path.replace(/\*/g, "") + queryParams;
      } else {
        resolvedPath = routeWithParams.replace(/\*/g, "");
      }
      return resolvedPath;
    } else {
      console.error(
        "Wrong route name: %s, valid route names: %s",
        routeName,
        Object.keys(this.routes).join(", ")
      );
      return void 0;
    }
  }
  /**
   * Creates a new navigation object.
   *
   * @param {string} name - The name of the route to navigate to.
   * @returns {Navigation} - The navigation object with 'from' and 'to' properties.
   */
  newNavigation(name) {
    return {
      from: this.currentRoute ? this.currentRoute.name : void 0,
      to: name
    };
  }
  /**
   * Reverses the navigation object by swapping the 'from' and 'to' properties.
   *
   * @param {Navigation} nav - The navigation object.
   * @returns {Navigation} - The reversed navigation object.
   */
  reverseNavigation(nav) {
    return {
      from: nav.to,
      to: nav.from
    };
  }
  /**
   * Navigates to a specified route.
   *
   * @param {string} name - The name of the route.
   * @param {QueryParams | undefined} params - The parameters for the route.
   * @param {boolean} [replace=false] - Whether to replace the current history entry. Default is
   *   `false`
   * @param {boolean} [skipHistory=false] - Whether to skip adding the navigation to the history.
   *   Default is `false`
   */
  go(name, params = void 0, replace = false, skipHistory = false) {
    if (this.isNavigationInProgress) {
      return;
    }
    if (skipHistory !== void 0) {
      const newNav = this.newNavigation(name);
      const reverseNav = this.reverseNavigation(newNav);
      reverseNav.skipHistory = skipHistory;
      this.navigationStack.addSkipNavigation(reverseNav);
    }
    const sanitizedName = name.replace(_Router.LTRIM_SLASH, "");
    const path = this.getPath(sanitizedName, params);
    if (path && path !== this._getHashPath()) {
      this.isNavigationInProgress = true;
      this.updatePathInBrowser(path, replace);
    }
  }
  /**
   * Navigates back to the previous route in the navigation stack.
   *
   * @returns {NavigationWithParams} The navigation object containing the 'from' and 'to' routes.
   * @throws {Error} If there is no page to go back to.
   */
  back() {
    const navigation = {};
    if (this.navigationStack.length > 1) {
      let fromRoute = this.navigationStack.pop();
      let auxFromRoute = fromRoute;
      let backRoute = this.getLastRoute();
      while (this.navigationStack.isSkipNavigation({ from: auxFromRoute == null ? void 0 : auxFromRoute.page, to: backRoute == null ? void 0 : backRoute.page }) && this.navigationStack.length > 1) {
        auxFromRoute = this.navigationStack.pop();
        if (this.navigationStack.length > 0) {
          backRoute = this.getLastRoute();
        }
      }
      const page = backRoute == null ? void 0 : backRoute.page;
      const params = backRoute == null ? void 0 : backRoute.params;
      navigation.from = fromRoute;
      navigation.to = backRoute;
      if (page) {
        this.go(page, params);
      } else {
        throw new Error("No page to go back to");
      }
    } else {
      navigation.from = this.getLastRoute();
      navigation.to = this.getLastRoute();
    }
    return navigation;
  }
  /**
   * Updates the path in the browser's address bar.
   *
   * @param {string} path - The new path to be set in the address bar.
   * @param {boolean} replace - Indicates whether to replace the current history state or push a new
   *   one.
   */
  updatePathInBrowser(path, replace) {
    if (this.useHistory) {
      if (replace) {
        this.historyReplaceState(path);
      } else {
        this.historyPushState(path);
      }
    } else {
      if (replace) {
        this.locationReplace(path);
      } else {
        this.locationHash(path);
      }
    }
  }
  /**
   * Updates the subroute in the browser.
   *
   * @param {string} subroute - The subroute to be added to the current route. It must start with a
   *   slash (/)
   */
  updateSubrouteInBrowser(subroute) {
    const currentRoute = this.currentRoute;
    let pathWithSubroute = this.getPath(currentRoute.name, currentRoute.params);
    if (pathWithSubroute) {
      if (subroute) {
        if (pathWithSubroute == null ? void 0 : pathWithSubroute.endsWith("/")) {
          pathWithSubroute = pathWithSubroute.substring(0, pathWithSubroute.length - 1);
        }
        pathWithSubroute = pathWithSubroute + subroute;
      }
      this.updatePathInBrowser(pathWithSubroute, true);
      this.hashIsDirty = true;
    }
  }
  /**
   * Replaces the current route with a new route using the specified name and parameters.
   *
   * @param {string} name - The name of the route to navigate to.
   * @param {QueryParams} [params] - The parameters to pass to the new route.
   */
  goReplacing(name, params = void 0) {
    this.go(name, params, true);
  }
  /**
   * Reemplaza el estado actual del historial del navegador con una nueva URL.
   *
   * @param {string} path - La nueva URL a reemplazar en el historial del navegador.
   */
  historyReplaceState(path) {
    history.replaceState(null, "", path);
  }
  /**
   * Pushes a new state to the browser history.
   *
   * @param {string} path - The path to push to the history.
   */
  historyPushState(path) {
    history.pushState(null, "", path);
  }
  /**
   * Replaces the current location with the specified path.
   *
   * @param {string} path - The path to replace the current location with.
   */
  locationReplace(path) {
    location.replace("#!" + path);
  }
  /**
   * Sets the location hash with the specified path.
   *
   * @param {string} path - The path to set as the location hash.
   */
  locationHash(path) {
    location.hash = "#!" + path;
  }
  /**
   * Get last route from stack.
   *
   * @returns {RoutePage | undefined} Last route from stack.
   */
  getLastRoute() {
    return this.navigationStack.top();
  }
  /** Initialize router stack. */
  init() {
    this._clearStack();
  }
  /** Clear the router stack. */
  _clearStack() {
    this.navigationStack.clear();
  }
  /**
   * Clear the router stack until given page is found on router stack.
   *
   * @param {string} targetPage
   */
  clearStackUntil(targetPage) {
    this.navigationStack.clearUntil(targetPage);
  }
};
/**
 * Indicates whether the browser supports the History API.
 *
 * @type {boolean}
 */
__publicField(_Router, "SUPPORTS_HISTORY_API", window.history && "pushState" in window.history);
/**
 * Regular expression pattern used to match and capture route parameters.
 *
 * @type {RegExp}
 */
__publicField(_Router, "PARAM", /(?::([^/]+))/g);
/**
 * Regular expression pattern used to match and remove leading slashes from a string.
 *
 * @type {RegExp}
 */
__publicField(_Router, "LTRIM_SLASH", /^\/(\b)/);
/**
 * Regular expression pattern representing an empty string.
 *
 * @type {RegExp}
 */
__publicField(_Router, "EMPTY", /^$/);
/**
 * Regular expression pattern used to match and remove hash prefixes.
 *
 * @type {RegExp}
 */
__publicField(_Router, "HASH_PREFIX", /^#!?\/*/);
/**
 * Regular expression pattern used to match and remove leading slashes from a path.
 *
 * @type {RegExp}
 */
__publicField(_Router, "PATH_PREFIX", /^\/*/);
/**
 * Indicates whether a navigation is currently in progress.
 *
 * @type {boolean}
 */
__publicField(_Router, "isNavigationInProgress", false);
/**
 * Represents the status of a cancelled navigation.
 *
 * @type {string}
 */
__publicField(_Router, "cancelledNavigation");
/**
 * Indicates whether the hash is dirty or not.
 *
 * @type {boolean}
 */
__publicField(_Router, "hashIsDirty", false);
var Router = _Router;

// node_modules/@open-cells/core/src/template.js
var Template = class {
  /**
   * Creates a new Template instance.
   *
   * @param {TemplateSpec} spec - The specification object for the Template.
   */
  constructor(spec) {
    /**
     * Type
     *
     * Indicates the type of this component
     *
     * @type {String}
     */
    __publicField(this, "type", "TEMPLATE");
    if (spec.node) {
      this.node = spec.node;
    } else if (spec.tagName) {
      this.node = document.createElement(spec.tagName);
    } else {
      throw new Error("Template must have a node or a tagName");
    }
    this.name = "";
  }
  /**
   * Returns the zone node in the template identified by the id.
   *
   * @param {String} zoneId - The ID of the zone.
   * @returns {TemplateNode} - The zone node.
   */
  getZone(zoneId) {
    const curTemplateNode = this.node;
    let node;
    if (!zoneId) {
      node = curTemplateNode;
    } else {
      node = curTemplateNode.querySelector("#" + zoneId);
    }
    return node || curTemplateNode;
  }
  /**
   * Sets the attribute cache in the template node to 'cached' for not loading the template again
   * the next time the template is used.
   */
  cache() {
    this._setAttribute("state", "cached");
  }
  /**
   * Sets the attribute cache in the template node to 'active' so you can know which of the
   * templates in html is the actual one.
   */
  activate() {
    this._setAttribute("state", "active");
  }
  /**
   * Sets the attribute cache in the template node to 'inactive' so you can know which of the
   * templates in html are not the actual one.
   */
  deactivate() {
    this._setAttribute("state", "inactive");
  }
  /**
   * Set given value to corresponding attribute name of current template.
   *
   * @private
   * @param {String} name - Attribute name.
   * @param {String} value - Attribute value.
   */
  _setAttribute(name, value) {
    const template = this._getTemplate(this.node);
    try {
      template.setAttribute(name, value);
    } catch (err) {
      throw new Error(
        `${this.node.tagName.toLowerCase()} has no valid template. Template was ${template}`
      );
    }
  }
  /**
   * Get given attribute value from the current template.
   *
   * @private
   * @param {String} name - Attribute name.
   * @returns {String} - Attribute value.
   */
  _getAttribute(name) {
    const template = this._getTemplate(this.node);
    let attribute = "";
    try {
      attribute = template.getAttribute(name) || "";
    } catch (err) {
      throw new Error(
        `${this.node.tagName.toLowerCase()} has no valid template. Template was ${template}`
      );
    }
    return attribute;
  }
  /**
   * Returns current template based on node type. If it's a routable component (page), we retrieve
   * the first child element that matches with cells-template. Otherwise, we return directly the
   * node (cells-template).
   *
   * @private
   * @param {TemplateNode} node - Node for template retrieval.
   * @returns {TemplateNode} - Associated template from given node.
   * @r eturns {WCNode} - Associated template from given node.
   */
  _getTemplate(node) {
    const { tagName } = node;
    const isPage = tagName.toLowerCase().endsWith("-page");
    return isPage ? this._getTemplateFromPage(node) || node : node;
  }
  /**
   * Returns the first element from shadowRoot child nodes that matches 'cells-template'.
   *
   * @private
   * @param {TemplateNode} node - First level component that contains cells-template inside
   *   shadowRoot childNodes.
   * @returns {TemplateNode | undefined} - Cells template.
   * @r eturns {WCNode | undefined} - Cells template.
   */
  _getTemplateFromPage(node) {
    const list = node.shadowRoot && node.shadowRoot.childNodes ? node.shadowRoot.childNodes : node.children;
    const listOfTemplates = Array.from(list).filter((el) => el instanceof HTMLElement);
    return listOfTemplates.find(
      (el) => el.tagName && (el.tagName.toLowerCase().indexOf("cells-template") !== -1 || el.getAttribute("data-cells-type") === "template")
    );
  }
  /**
   * Configures the Template with the provided configuration.
   *
   * @param {TemplateConfig} config - The configuration object for the Template.
   */
  config(config2) {
    const {
      name,
      template: { id: templateId, name: templateName }
    } = config2;
    this.name = name;
    this.node.id = templateId;
    this.node.name = templateName;
  }
};

// node_modules/@open-cells/core/src/manager/template.js
var { externalEventsCodes: externalEventsCodes4 } = Constants;
var TemplateManager = class {
  /**
   * Creates a new instance of the TemplateManager class.
   *
   * @param {TemplateManagerConfig} config - The configuration options.
   */
  constructor(config2 = {}) {
    /**
     * The template cache.
     *
     * @type {{ [key: string]: Template }}
     */
    __publicField(this, "cache", {});
    /**
     * The templates collection.
     *
     * @type {{ [key: string]: TemplateNode }}
     */
    __publicField(this, "templates", {});
    /**
     * The name of the currently selected template.
     *
     * @type {string}
     */
    __publicField(this, "selected", "");
    /**
     * The list of template locations.
     *
     * @type {string[]}
     */
    __publicField(this, "locations", []);
    /**
     * The number of templates stored in the cache.
     *
     * @type {number}
     */
    __publicField(this, "size", 0);
    /**
     * The list of fixed templates.
     *
     * @type {string[]}
     */
    __publicField(this, "fixedTemplates", ["__cross"]);
    const persistentPages = config2.persistentPages || [];
    this.viewLimit = config2.viewLimit && config2.viewLimit >= 1 ? config2.viewLimit : 3;
    this.fixedTemplates = this.fixedTemplates.concat(persistentPages);
    this.maxSize = this.viewLimit + this.fixedTemplates.length;
  }
  /**
   * Creates a template with the specified name and spec.
   *
   * @param {string} name - The name of the template.
   * @param {TemplateSpec} spec - The template spec. is `false`
   * @returns {Template} The created template.
   */
  createTemplate(name, spec) {
    let template = this.get(name);
    if (!template) {
      template = this._createTemplate(name, spec);
      this._storeTemplate(name, template);
    }
    return template;
  }
  /**
   * Creates a CellsTemplate instance.
   *
   * @private
   * @param {string} name - The name of the template.
   * @param {TemplateSpec} spec - The template spec.
   * @returns {Template} The created CellsTemplate instance.
   */
  _createTemplate(name, spec) {
    const cellsTemplate = new Template(spec);
    const cellsTemplateConfig = this._createTemplateConfig(name);
    cellsTemplate.config(cellsTemplateConfig);
    return cellsTemplate;
  }
  /**
   * Creates a CellsTemplateConfig object.
   *
   * @private
   * @param {string} name - The name of the template.
   * @returns {TemplateConfig} The created CellsTemplateConfig object.
   */
  _createTemplateConfig(name) {
    return {
      name,
      template: {
        id: this.computeTemplateId(name),
        name
      }
    };
  }
  /**
   * Stores a template in memory.
   *
   * @private
   * @param {string} name - The name of the template.
   * @param {Template} template - The template object.
   */
  _storeTemplate(name, template) {
    const { node } = template;
    if (this.size >= this.maxSize) {
      const olderTemplateToDeallocate = this._getOlderRemovableTemplate();
      if (olderTemplateToDeallocate) {
        this.removeTemplate(olderTemplateToDeallocate);
      } else {
        console.warn("No space left in template cache for template ", name);
      }
    }
    this.locations.push(name);
    this.cache[name] = template;
    this.templates[name] = node;
    this.size++;
  }
  /**
   * Gets the older removable template.
   *
   * @private
   * @returns {string | undefined} The name of the older removable template.
   */
  _getOlderRemovableTemplate() {
    let found = false;
    let olderRemovableTemplate;
    for (let i = 0; !found && i < this.locations.length; i++) {
      const isNotPersistantPage = this.fixedTemplates.indexOf(this.locations[i]) == -1;
      if (isNotPersistantPage) {
        olderRemovableTemplate = this.locations[i];
        found = true;
      }
    }
    return olderRemovableTemplate;
  }
  /**
   * Gets a template by name.
   *
   * @param {string} name - The name of the template.
   * @returns {Template} The template with the specified name.
   */
  get(name) {
    return this.cache[name];
  }
  /**
   * Gets the node of a template by name.
   *
   * @param {string} name - The name of the template.
   * @returns {TemplateNode} The node of the template with the specified name.
   */
  getNode(name) {
    return this.templates[name];
  }
  /**
   * Parses a template name.
   *
   * @param {string} name - The template name.
   * @returns {string} The parsed template name.
   */
  parseTemplateName(name) {
    return name;
  }
  /**
   * Computes the template ID.
   *
   * @param {string} name - The template name.
   * @returns {string} The computed template ID.
   */
  computeTemplateId(name) {
    return "cells-template-" + name.replace(/\./g, "-");
  }
  /**
   * Selects a template.
   *
   * @fires template-transition-end
   * @param {string} name - The name of the template.
   */
  select(name) {
    const { TEMPLATE_TRANSITION_END } = externalEventsCodes4;
    const template = this.get(name);
    const cache = this.cache;
    let oldPageName;
    for (let tplName in cache) {
      if (cache.hasOwnProperty(tplName)) {
        if (tplName === this.selected) {
          oldPageName = tplName;
          cache[tplName].deactivate();
        } else if (name !== tplName) {
          cache[tplName].cache();
        }
      }
    }
    this.selected = name;
    template.activate();
    eventManager.emit(TEMPLATE_TRANSITION_END, template);
  }
  /**
   * Removes a template by name.
   *
   * @param {string} templateName - The name of the template to remove.
   */
  removeTemplate(templateName) {
    if (this.templates[templateName]) {
      const node = document.querySelector("#" + this.templates[templateName].id);
      if (!node) {
        throw new Error(`Template ${templateName} node not found`);
      }
      const pos = this.locations.indexOf(templateName);
      this.locations.splice(pos, 1);
      if (!node.parentNode) {
        throw new Error(`Template ${templateName} has no parent node`);
      }
      node.parentNode.removeChild(node);
      delete this.templates[templateName];
      delete this.cache[templateName];
      this.size--;
    }
  }
  /**
   * Removes all templates except the initial one and the cross component one.
   *
   * @param {string} initialTemplate - The name of the initial template.
   * @param {string} crossContainerId - The name of the cross component template.
   */
  removeTemplates(initialTemplate2, crossContainerId) {
    for (let templateName in this.templates) {
      if (this.templates.hasOwnProperty(templateName)) {
        if (templateName !== initialTemplate2 && templateName !== crossContainerId) {
          this.removeTemplate(templateName);
        }
      }
    }
  }
  /**
   * Removes all children of a template.
   *
   * @param {string} templateName - The name of the template.
   */
  removeTemplateChildrens(templateName) {
    const template = this.templates[templateName];
    if (template) {
      while (template.firstChild) {
        template.removeChild(template.firstChild);
      }
    }
  }
};

// node_modules/@open-cells/core/src/manager/bridge-channels.js
var BridgeChannelManager = class {
  /**
   * Creates a new instance of BridgeChannelManager.
   *
   * @param {Bridge} bridge - The bridge instance.
   */
  constructor(bridge) {
    this.componentConnector = bridge.ComponentConnector;
    this.privateChannels = /* @__PURE__ */ new Set();
  }
  /**
   * Returns the name of the application context channel.
   *
   * @returns {string} The application context channel name.
   */
  getAppContextChannelName() {
    return `${BRIDGE_CHANNEL_PREFIX}_app`;
  }
  /**
   * Returns the name of the channel that has cancellations of back navigations.
   *
   * @returns {string} The cancelled back navigation channel name.
   */
  getCancelledBackNavigationChannelName() {
    return `${BRIDGE_CHANNEL_PREFIX}_cancelled_back_navigation`;
  }
  /**
   * Returns the name of the channel that has intercepted navigations.
   *
   * @returns {string} The intercepted navigation channel name.
   */
  getInterceptedNavigationChannelName() {
    return `${BRIDGE_CHANNEL_PREFIX}_intercepted_navigation`;
  }
  /**
   * Returns the prefix for private channels.
   *
   * @returns {string} The private channel prefix.
   */
  getPrivateChannelPrefix() {
    return `${BRIDGE_CHANNEL_PREFIX}_page_`;
  }
  /**
   * Returns the prefix for event channels.
   *
   * @returns {string} The event channel prefix.
   */
  getEventChannelPrefix() {
    return `${BRIDGE_CHANNEL_PREFIX}_evt_`;
  }
  /**
   * Returns the prefix for generic channels.
   *
   * @returns {string} The bridge channel prefix.
   */
  getBridgeChannelPrefix() {
    return `${BRIDGE_CHANNEL_PREFIX}_ch_`;
  }
  /**
   * Returns the prefix for post message channels.
   *
   * @returns {string} The post message channel prefix.
   */
  getPostMessageChannelPrefix() {
    return `${BRIDGE_CHANNEL_PREFIX}_post_message_`;
  }
  /**
   * Gets a bridge channel. If the channel doesn't exist, it creates one.
   *
   * @param {string} channelName - The name of the channel to retrieve/create.
   * @returns {Channel} The bridge channel.
   */
  getBridgeChannel(channelName) {
    return this.componentConnector.getChannel(this.getBridgeChannelPrefix() + channelName);
  }
  // /**
  //  * Gets the idle callback channel.
  //  *
  //  * @returns {Observable<boolean>} The idle callback channel.
  //  */
  // getIdleCallbackChannel() {
  //   const idleChannel$ = new Observable(observer => observer.next(true));
  //   return idleChannel$.pipe(first());
  // }
  /**
   * Gets the application context channel.
   *
   * @returns {Channel} The application context channel.
   */
  getAppContextChannel() {
    return this.componentConnector.getChannel(this.getAppContextChannelName());
  }
  /**
   * Gets the cancelled back navigations channel.
   *
   * @returns {Channel} The cancelled back navigation channel.
   */
  getCancelledBackNavigationChannel() {
    return this.componentConnector.getChannel(this.getCancelledBackNavigationChannelName());
  }
  /**
   * Gets the intercepted navigations channel.
   *
   * @returns {Channel} The intercepted navigation channel.
   */
  getInterceptedNavigationChannel() {
    return this.componentConnector.getChannel(this.getInterceptedNavigationChannelName());
  }
  /**
   * Gets the private channel that corresponds to a page.
   *
   * @param {string} pageName - The name of the page.
   * @returns {Channel} The private channel.
   */
  getPrivate(pageName) {
    const newName = this.getPrivateChannelPrefix() + pageName;
    const channel = this.componentConnector.getChannel(newName);
    this.privateChannels.add(newName);
    return channel;
  }
  /**
   * Gets the post message channel for the given event name.
   *
   * @param {string} eventName - The name of the event.
   * @returns {Channel} The post message channel.
   */
  getPostMessageChannel(eventName) {
    const newName = this.getPostMessageChannelPrefix() + eventName;
    return this.componentConnector.getChannel(newName);
  }
  /** Initializes the application context channel. */
  initAppContextChannel() {
    this.getAppContextChannel();
  }
  /** Initializes the cancelled back navigation channel. */
  initCancelledBackNavigationChannel() {
    this.getCancelledBackNavigationChannel();
  }
  /**
   * Initializes the private channel for the given page.
   *
   * @param {string | undefined} oldPageName - The name of the old page.
   * @param {string} newPageName - The name of the new page.
   */
  initPrivateChannel(oldPageName, newPageName) {
    this.publishPrivatePageStatus(newPageName, true);
    if (oldPageName) {
      this.publishPrivatePageStatus(oldPageName, false);
    }
  }
  /**
   * Publishes the status of a page in its private channel.
   *
   * @param {string} pageName - The name of the page.
   * @param {boolean} status - The status of the page.
   */
  publishPrivatePageStatus(pageName, status) {
    const channel = this.getPrivate(pageName);
    const evt = eventManager.createEvent("page-load", status);
    channel.next(evt);
  }
  /**
   * Updates the application context.
   *
   * @param {string | undefined} oldPage - The previous current page.
   * @param {string} newPage - The new current page.
   * @param {Object} appContext - The application context.
   * @param {RouteData} currentRoute - The details about the route.
   */
  updateAppContext(oldPage, newPage, appContext, currentRoute) {
    const evt = eventManager.createEvent("app-context", {
      currentPage: newPage,
      fromPage: oldPage,
      interceptorContext: appContext,
      currentRoute
    });
    this.getAppContextChannel().next(evt);
  }
  /**
   * Updates the bridge channels.
   *
   * @param {string | undefined} oldPage - The previous current page.
   * @param {string} newPage - The new current page.
   * @param {Object} appContext - The application context.
   * @param {RouteData} currentRoute - The details about the route.
   */
  updateBridgeChannels(oldPage, newPage, appContext, currentRoute) {
    this.updateAppContext(oldPage, newPage, appContext, currentRoute);
    this.initPrivateChannel(oldPage, newPage);
  }
  /**
   * Publishes the cancelled back navigation event.
   *
   * @param {Navigation} navigation - The navigation details.
   */
  publishCancelledBackNavigation(navigation) {
    const evt = eventManager.createEvent("back-nav-cancelled", navigation);
    this.getCancelledBackNavigationChannel().next(evt);
  }
  /**
   * Publishes the intercepted navigation event.
   *
   * @param {Navigation} navigation - The navigation details.
   */
  publishInterceptedNavigation(navigation) {
    const evt = eventManager.createEvent("intercepted-navigation", navigation);
    this.getInterceptedNavigationChannel().next(evt);
  }
  /**
   * Checks if the given name matches a private channel's name.
   *
   * @param {string} name - The name to check.
   * @returns {boolean} True if the name matches a private channel's name, false otherwise.
   */
  isPrivateChannel(name) {
    return name.indexOf(this.getPrivateChannelPrefix()) === 0;
  }
  /**
   * Checks if there's an active private channel with the given name.
   *
   * @param {string} name - The name to check.
   * @returns {boolean} True if there's an active private channel with the given name, false
   *   otherwise.
   */
  isActivePrivateChannel(name) {
    return this.privateChannels.has(name);
  }
  /**
   * Resets all channels, including the private channels. It removes all observers and publications.
   *
   * @param {WCNode} mainNode - The main node.
   * @param {boolean} cleanPrivateChannels - Whether to clean private channels or not.
   */
  resetBridgeChannels(mainNode, cleanPrivateChannels) {
    const bridgeChannels = Object.keys(this.componentConnector.getChannels());
    bridgeChannels.forEach((chnlName) => {
      let chnl = this.componentConnector.getChannel(chnlName);
      chnl.clean();
      chnl.unsubscribe();
    });
    this.componentConnector.unregisterComponent(mainNode, cleanPrivateChannels);
    this.componentConnector.unregisterAllSubscriptors(cleanPrivateChannels);
    this.componentConnector.cleanAllChannels();
  }
  /**
   * Gets the cross-container and main node connections.
   *
   * @param {string} crossContainerId - The ID of the cross-container.
   * @param {string} mainNodeId - The ID of the main node.
   * @returns {CCSubscriptions} The cross-container and main node connections.
   */
  getCCSubscriptions(crossContainerId, mainNodeId) {
    const crossComponents = Array.from(this.componentConnector.subscriptors.values()).filter(
      (c) => {
        var _a, _b;
        return (
          // @ts-ignore
          ((_a = c.node.parentNode) == null ? void 0 : _a.id) === crossContainerId || // @ts-ignore
          ((_b = c.node.parentNode) == null ? void 0 : _b.id) === mainNodeId || c.node.id === mainNodeId
        );
      }
    );
    const outConnections = crossComponents.map(
      (c) => {
        var _a, _b;
        return (
          /** @type {WCSubscription[]} */
          (_b = (_a = c.publications) == null ? void 0 : _a._subscriptions) == null ? void 0 : _b.map((s) => {
            return {
              channel: s.channelName || "",
              bind: s.eventName || "",
              component: c.node,
              //options: s.options,
              options: void 0
            };
          })
        );
      }
    ).filter((c) => c !== void 0).reduce((acc, cnxs) => acc == null ? void 0 : acc.concat(cnxs || []), []) || [];
    let inConnections = crossComponents.map(
      /** @type {Subscriptor} */
      (c) => {
        var _a;
        return (_a = c.subscriptions) == null ? void 0 : _a.map((s) => {
          return {
            channel: s.channel.name,
            bind: s.bind,
            component: c.node
          };
        });
      }
    ).filter((c) => c !== void 0).reduce(
      (acc, cnxs) => acc.concat(cnxs),
      []
    );
    return { inConnections, outConnections };
  }
  /**
   * Initializes the event channels.
   *
   * @param {Node} node - The node to listen for events.
   * @param {string[]} externalEvents - The names of the external events.
   */
  initEventChannels(node, externalEvents3) {
    externalEvents3.forEach((eventName) => {
      const prefix = this.getEventChannelPrefix();
      const channelName = prefix + eventName;
      const channel = this.componentConnector.getChannel(channelName);
      const source = fromEvent(node, eventName);
      source.subscribe((event) => channel.next(event));
    });
  }
  /**
   * Subscribes to an event channel.
   *
   * @param {HTMLElement} node - The node to subscribe.
   * @param {string} eventName - The name of the event.
   * @param {Function} callback - The callback function.
   */
  subscribeToEvent(node, eventName, callback) {
    const prefix = this.getEventChannelPrefix();
    const channelName = prefix + eventName;
    const subscriptor = this.componentConnector.getSubscriptor(node);
    const channel = this.componentConnector.getChannel(channelName);
    const augmentedCallback = callback;
    Object.defineProperty(
      augmentedCallback,
      /** @type {WCNode} */
      "node",
      {
        writable: true,
        configurable: true,
        enumerable: true
      }
    );
    subscriptor.subscribe(channel, augmentedCallback, false, "");
  }
};

// node_modules/@open-cells/core/src/manager/action-channels.js
var { externalEventsCodes: externalEventsCodes5 } = Constants;
var ActionChannelManager = class {
  /**
   * Create an Action Channel Manager.
   *
   * @class
   * @param {Bridge} bridge - The bridge object.
   */
  constructor(bridge) {
    this.bridge = bridge;
    this.ChannelManager = bridge.BridgeChannelManager;
    this.TemplateManager = bridge.TemplateManager;
  }
  /** Subscribe to all action channels. */
  subscribeAll() {
    this.ChannelManager.getBridgeChannel("config").subscribe(
      (evt) => this._configSubscriptor(evt)
    );
    this.ChannelManager.getBridgeChannel("locales").subscribe(
      (evt) => this._localesSubscriptor(evt)
    );
    this.ChannelManager.getBridgeChannel("logout").subscribe(
      (evt) => this._logoutSubscriptor()
    );
    this.ChannelManager.getBridgeChannel("interceptor_context").subscribe(
      (evt) => this._appContextSubscriptor(evt)
    );
  }
  /**
   * Update a property of the bridge object.
   *
   * @param {string} prop - The property to update.
   * @param {any} value - The new value for the property.
   */
  updateProperty(prop, value) {
    if (this.isAllowedProperty(prop)) {
      this.bridge[prop] = value;
      window.AppConfig && (window.AppConfig[prop] = value);
    }
  }
  /**
   * Check if a property is allowed to be updated.
   *
   * @param {string} prop - The property to check.
   * @returns {boolean} - True if the property is allowed, false otherwise.
   */
  isAllowedProperty(prop) {
    return typeof this.bridge[prop] !== "function";
  }
  /**
   * Event handler for the 'config' action channel.
   *
   * @private
   * @param {WCEvent} evt - The event object.
   */
  _configSubscriptor(evt) {
    const { TEMPLATE_REGISTERED } = externalEventsCodes5;
    const selected = this.TemplateManager.selected;
    if (evt.detail) {
      for (let prop in evt.detail) {
        if (evt.detail.hasOwnProperty(prop)) {
          this.updateProperty(prop, evt.detail[prop]);
        }
      }
      if (evt.detail.app || evt.detail.pagesPath) {
        this.TemplateManager.removeTemplates(selected, this.bridge.crossContainerId);
        eventManager.once(TEMPLATE_REGISTERED, () => this.TemplateManager.removeTemplate(selected));
      }
    }
  }
  /**
   * Event handler for the 'locales' action channel.
   *
   * @private
   * @param {WCEvent} evt - The event object.
   */
  _localesSubscriptor(evt) {
    if (window.I18nMsg && evt.detail && evt.detail.lang) {
      window.I18nMsg.lang = evt.detail.lang;
    }
  }
  /**
   * Event handler for the 'logout' action channel.
   *
   * @private
   */
  _logoutSubscriptor() {
    this.bridge.logout();
  }
  /**
   * Event handler for the 'interceptor_context' action channel.
   *
   * @private
   * @param {WCEvent} evt - The event object.
   */
  _appContextSubscriptor(evt) {
    const appContext = evt.detail;
    this.bridge.setInterceptorContext(appContext);
  }
};

// node_modules/@open-cells/core/src/manager/post-message.js
var PostMessageManager = class {
  /** @param {Bridge} bridge - The bridge instance. */
  constructor(bridge) {
    this.enabled = false;
    this.postMessageTargetOrigin = "";
    if (!bridge.postMessageTargetOrigin) {
      this.enabled = false;
    } else {
      if (bridge.postMessageTargetOrigin === "*") {
        this.enabled = false;
        console.warn(
          "For security reasons postMessageTargetOrigin can't be the wildcard '*'. See docs for more info. "
        );
      } else {
        this.enabled = true;
        this.postMessageTargetOrigin = bridge.postMessageTargetOrigin;
      }
    }
    this.componentConnector = bridge.ComponentConnector;
    this.bridgeChannelManager = bridge.BridgeChannelManager;
  }
  /**
   * Handles the postMessage events sent to this window from its parent. It transforms them into
   * channels [BRIDGE_CHANNEL_PREFIX]_post_message_{your-event-name} including the payload, to do so
   * the postMessage must be: { "event" : "your-event-name", "detail" : <any> } Creates and listens
   * to the private channel [BRIDGE_CHANNEL_PREFIX]_ch_send_post_message to send postMessages to
   * parent window.
   */
  setupPostMessages() {
    if (this.enabled) {
      window.addEventListener("message", ({ data }) => {
        if (data.event) {
          const channel = this.bridgeChannelManager.getPostMessageChannel(data.event);
          const evt = this.componentConnector.createEvent(data.event, data.detail);
          channel.next(evt);
        }
      });
      this._sendPostMessage({ event: `${BRIDGE_CHANNEL_PREFIX}-ready` });
      this.bridgeChannelManager.getBridgeChannel("send_post_message").subscribe((evt) => this._sendPostMessage(evt.detail));
    }
  }
  /**
   * Sends a postMessage to the parent window.
   *
   * @private
   * @param {PostMessageEvent} evt - The event to be sent.
   */
  _sendPostMessage(evt) {
    window.parent && window.parent.postMessage(
      { eventName: evt.event, eventDetail: evt.detail },
      this.postMessageTargetOrigin
    );
  }
};

// node_modules/@open-cells/core/src/manager/storage.js
var InMemmoryStorage = class {
  constructor() {
    /**
     * The dictionary object that stores the key-value pairs.
     *
     * @type {Dictionary}
     */
    __publicField(this, "dictionary", {});
  }
  /**
   * Retrieves the value associated with the specified key.
   *
   * @param {string} key - The key to retrieve the value for.
   * @returns {any} The value associated with the key, or null if the key does not exist.
   */
  getItem(key) {
    return this.dictionary[key] || null;
  }
  /**
   * Sets the value for the specified key.
   *
   * @param {string} key - The key to set the value for.
   * @param {any} value - The value to be set.
   */
  setItem(key, value) {
    this.dictionary[key] = value;
  }
  /**
   * Removes the value for the specified key.
   *
   * @param {string} key - The key to set the value for.
   */
  removeItem(key) {
    delete this.dictionary[key];
  }
};
var CellsStorage = class {
  /**
   * Creates an instance of CellsStorage.
   *
   * @param {Object} options - The options for the storage.
   */
  constructor(options) {
    /**
     * The prefix for the storage keys.
     *
     * @type {string}
     */
    __publicField(this, "prefix", "");
    /**
     * Indicates whether the storage is persistent or not.
     *
     * @type {boolean}
     */
    __publicField(this, "persistent", false);
    /**
     * The internal storage used when persistent storage is not available.
     *
     * @type {InMemmoryStorage}
     */
    __publicField(this, "internalStorage", new InMemmoryStorage());
    Object.assign(this, options);
    if (this.persistent) {
      this.clear();
    }
  }
  /**
   * Gets the storage object.
   *
   * @type {Storage | InMemmoryStorage}
   */
  get storage() {
    let store;
    try {
      store = this.persistent ? window.localStorage : window.sessionStorage;
      store.setItem("_$_", JSON.stringify({}));
    } catch (error) {
      store = this.internalStorage;
    }
    return store;
  }
  /**
   * Gets the value associated with the specified key.
   *
   * @param {string} key - The key to retrieve the value for.
   * @returns {any | null} The value associated with the key.
   */
  getItem(key) {
    return JSON.parse(this.storage.getItem(this.prefix + key));
  }
  /**
   * Sets the value associated with the specified key.
   *
   * @param {string} key - The key to set the value for.
   * @param {any} value - The value to set.
   */
  setItem(key, value) {
    this.storage.setItem(this.prefix + key, JSON.stringify(value));
  }
  /** Clears all the storage items with keys that match the prefix. */
  clear() {
    var pattern = new RegExp("^(" + this.prefix + ")");
    for (let key in this.storage) {
      if (this.storage.hasOwnProperty(key)) {
        if (pattern.test(key)) {
          this.storage.removeItem(key);
        }
      }
    }
  }
};

// node_modules/@open-cells/core/src/manager/application-config.js
var CONFIG_STORAGE_PREFIX = "__app_";
var CONFIG_STORAGE_KEY = "config";
var ApplicationConfigManager = class {
  /**
   * Constructs a new ApplicationConfigManager instance.
   *
   * @class
   * @param {Object} options - The options for the ApplicationConfigManager.
   * @param {ActionChannelManager} options.ActionChannelManager - The ActionChannelManager instance.
   */
  constructor({ ActionChannelManager: ActionChannelManager2 }) {
    this.ActionChannelManager = ActionChannelManager2;
    this.storage = this._getAppConfigStorage();
  }
  /**
   * Returns a new CellsStorage instance for storing the application configuration.
   *
   * @private
   * @returns {CellsStorage} - The CellsStorage instance.
   */
  _getAppConfigStorage() {
    return new CellsStorage({
      prefix: CONFIG_STORAGE_PREFIX,
      persistent: false
    });
  }
  /**
   * Saves the application configuration.
   *
   * @param {{ [kwy: string]: any }} config - The configuration object to be saved.
   */
  saveAppConfig(config2) {
    const store = {};
    for (let prop in config2) {
      if (config2.hasOwnProperty(prop) && this.ActionChannelManager.isAllowedProperty(prop)) {
        store[prop] = config2[prop];
      }
    }
    if (Object.keys(store).length > 0) {
      this.storage.setItem(CONFIG_STORAGE_KEY, store);
    }
  }
  /** Loads the application configuration. */
  loadAppConfig() {
    const config2 = this.storage.getItem(CONFIG_STORAGE_KEY);
    for (let prop in config2) {
      config2.hasOwnProperty(prop) && this.ActionChannelManager.updateProperty(prop, config2[prop]);
    }
  }
};

// node_modules/@open-cells/core/src/manager/application-state.js
var CONFIG_STORAGE_PREFIX2 = "__app_";
var CONFIG_STORAGE_KEY2 = "state";
var ApplicationStateManager = class {
  /**
   * @param {object} config - The configuration object.
   * @param {ComponentConnector} config.ComponentConnector - The component connector instance.
   */
  constructor({ ComponentConnector: ComponentConnector2 }) {
    this.ComponentConnector = ComponentConnector2;
    this.storage = this._getAppStateStorage();
  }
  /**
   * Returns the application state storage.
   *
   * @private
   * @returns {CellsStorage} The application state storage.
   */
  _getAppStateStorage() {
    return new CellsStorage({
      prefix: CONFIG_STORAGE_PREFIX2,
      persistent: false
    });
  }
  /**
   * Saves the application state for a specific channel.
   *
   * @param {string} channelName - The name of the channel.
   * @param {any} value - The value to be saved.
   */
  saveAppState(channelName, value) {
    const state = this.storage.getItem(CONFIG_STORAGE_KEY2);
    if (state) {
      state[channelName] = value;
      this.storage.setItem(CONFIG_STORAGE_KEY2, state);
    }
  }
  /** Loads the application state from storage and publishes it to the corresponding channels. */
  loadAppState() {
    const state = this.storage.getItem(CONFIG_STORAGE_KEY2);
    for (let channel in state) {
      this.ComponentConnector.publish(channel, state[channel]);
    }
  }
};

// node_modules/@open-cells/core/src/bridge.js
var { dasherize: dasherize2 } = Utils;
var $bridge = null;
var $queueCommands = [];
var $config;
var startApp = function(config2) {
  if (!$bridge) {
    $config = config2;
    new Bridge(config2);
  }
  return $bridge;
};
var getConfig = function() {
  return $config;
};
var enqueueCommand = function(command, parameters) {
  $queueCommands.push({ command, parameters });
};
function __callBridge(...args) {
  const [command, ...parameters] = args;
  let result;
  if ($bridge) {
    if (!$bridge[command]) {
      throw new Error(`WARNING: Invalid cells bridge command execution: ${command}.`);
    }
    result = $bridge[command](...parameters);
    return result;
  }
  enqueueCommand(command, parameters);
  return result;
}
function subscribe(channelName, node, callback) {
  __callBridge("registerInConnection", channelName, node, callback);
}
function unsubscribe(channels, node) {
  __callBridge("unsubscribe", channels, node);
}
function publish(channelName, value, options = {}) {
  __callBridge("publish", channelName, value, options);
}
function publishOn(channelName, htmlElement, eventName) {
  __callBridge("registerOutConnection", channelName, htmlElement, eventName);
}
function navigate(page, params) {
  __callBridge("navigate", page, params);
}
function updateInterceptorContext(ctx) {
  __callBridge("updateInterceptorContext", ctx);
}
function resetInterceptorContext() {
  __callBridge("resetInterceptorContext");
}
function getInterceptorContext() {
  return __callBridge("getInterceptorContext");
}
function setInterceptorContext(ctx) {
  __callBridge("setInterceptorContext", ctx);
}
function getCurrentRoute() {
  return __callBridge("getCurrentRoute");
}
function updateSubroute(subroute) {
  __callBridge("updateSubroute", subroute);
}
function backStep() {
  __callBridge("backStep");
}
var {
  externalEvents: externalEvents2,
  externalEventsCodes: externalEventsCodes6,
  initialTemplate: DEFAULT_INITIAL_TEMPLATE,
  pagesPath: DEFAULT_PAGES_PATH,
  renderEngines: renderEngines2
} = Constants;
var globalChannel = {};
var Bridge = class {
  /** @param {CellsConfig} config */
  constructor(config2) {
    /**
     * Pages Cache
     *
     * Saves page definitions into localstorage.
     *
     * @type {Boolean}
     */
    __publicField(this, "cache", true);
    /**
     * PubSub Context
     *
     * 'global' => Notifies all components of all bridge instances. 'local' => Notifies components
     * created by the current bridge instance.
     *
     * @type {String}
     */
    __publicField(this, "channel", "global");
    /**
     * Cross container node Id
     *
     * @type {String}
     */
    __publicField(this, "crossContainerId", "__cross");
    /**
     * Prints debug info
     *
     * @type {Boolean}
     */
    __publicField(this, "debug", true);
    /**
     * Proactive Cache. Loads future pages definition.
     *
     * @type {Boolean}
     */
    __publicField(this, "preCache", false);
    /**
     * Prefix for LocalStorage keys
     *
     * @type {String}
     */
    __publicField(this, "storagePrefix", `${BRIDGE_CHANNEL_PREFIX}-`);
    /**
     * Lib version.
     *
     * @type {string}
     */
    __publicField(this, "version", "__VERSION__");
    /**
     * Max number of views
     *
     * Keeps this number of template alive.
     *
     * @type {Number}
     */
    __publicField(this, "viewLimit", 1e3);
    /**
     * The name of the initial template that gets rendered
     *
     * @type {String}
     */
    __publicField(this, "initialTemplate", DEFAULT_INITIAL_TEMPLATE);
    /**
     * The node where the template will be rendered
     *
     * @type {WCNode | null}
     */
    __publicField(this, "__mainNodeElement", null);
    /**
     * The node's id where the template will be rendered.
     *
     * @type {String}
     */
    __publicField(this, "mainNode");
    /**
     * Events to expose
     *
     * @type {string[]}
     */
    __publicField(this, "externalEvents", externalEvents2);
    /**
     * The path to the folder that contains the components that renders a route.
     *
     * @type {String}
     */
    __publicField(this, "pagesPath", DEFAULT_PAGES_PATH);
    /**
     * Listener for navigation requests.
     *
     * @type {(info: any) => void}
     */
    __publicField(this, "navRequestListener");
    /** @type {ComponentConnector} */
    __publicField(this, "ComponentConnector");
    /** @type {TemplateManager} */
    __publicField(this, "TemplateManager");
    /** @type {Router} */
    __publicField(this, "Router");
    /** @type {BridgeChannelManager} */
    __publicField(this, "BridgeChannelManager");
    /** @type {ActionChannelManager} */
    __publicField(this, "ActionChannelManager");
    /** @type {PostMessageManager} */
    __publicField(this, "PostMessageManager");
    /** @type {ApplicationConfigManager} */
    __publicField(this, "ApplicationConfigManager");
    /** @type {ApplicationStateManager} */
    __publicField(this, "ApplicationStateManager");
    /** @type {InterceptorFunction} */
    __publicField(this, "interceptor");
    /** @type {Navigation[]} */
    __publicField(this, "skipNavigations");
    /** @type {EventSubscription[]} */
    __publicField(this, "eventSubscriptions");
    /** @type {string} */
    __publicField(this, "postMessageTargetOrigin");
    /** @type {string[]} */
    __publicField(this, "commonPages");
    if (config2 && typeof config2 == "object") {
      Object.assign(this, config2);
    }
    if (!this.mainNode) {
      console.warn("You should indicate the main node of your app");
    }
    this._initializeManagers();
    this._initializeDebug();
    this._initializeRouter();
    this._initializeBridgeStatus();
    this._initializeEventListeners();
    this.PostMessageManager.setupPostMessages();
    this._initCrossComponents();
    this._plugExternalEvents();
    this._lazyLoadPages(this.commonPages || []);
  }
  /** Initialize managers and conectors */
  _initializeManagers() {
    this.ComponentConnector = new ComponentConnector();
    this.TemplateManager = new TemplateManager(this);
    this.Router = new Router();
    this.BridgeChannelManager = new BridgeChannelManager(this);
    this.ActionChannelManager = new ActionChannelManager(this);
    this.PostMessageManager = new PostMessageManager(this);
    this.ApplicationConfigManager = new ApplicationConfigManager(this);
    this.ApplicationStateManager = new ApplicationStateManager(this);
    if (this.channel === "global") {
      this.ComponentConnector.setChannels(globalChannel);
    }
  }
  /** Initialize debug mode * */
  _initializeDebug() {
    if (this.debug) {
      $bridge = this;
      window.$bridge = $bridge;
    } else {
      $bridge = {
        // bridge
        logout: () => this.logout(),
        subscribeToEvent: (eventName, callback) => this.subscribeToEvent(eventName, callback),
        registerInConnection: (channel, node, callback) => this.registerInConnection(channel, node, callback),
        unsubscribe: (channels, node) => this.unsubscribe(channels, node),
        registerOutConnection: (channel, node, bindName, options) => this.registerOutConnection(channel, node, bindName, options),
        publish: (channel, value, options) => this.publish(channel, value, options),
        updateSubroute: (subroute) => this.updateSubroute(subroute),
        getCurrentRoute: () => this.getCurrentRoute(),
        navigate: (page, params) => this.navigate(page, params),
        updateApplicationConfig: (config2, options) => this.updateApplicationConfig(config2, options),
        // router interceptor
        updateInterceptorContext: (ctx) => this.updateInterceptorContext(ctx),
        resetInterceptorContext: () => this.resetInterceptorContext(),
        getInterceptorContext: () => this.getInterceptorContext(),
        setInterceptorContext: (ctx) => this.setInterceptorContext(ctx)
      };
    }
  }
  /** Initializate route * */
  _initializeRouter() {
    if (this.interceptor && typeof this.interceptor === "function") {
      this.Router.channelManager = this.BridgeChannelManager;
      this.Router.interceptor = this.interceptor;
    }
    this.Router.handler = () => this.routeHandler();
    if (Array.isArray(this.routes)) {
      this.routes = this._parseRoutes(this.routes);
    }
    this.Router.addRoutes(this.routes);
    if (this.skipNavigations && this.skipNavigations.length > 0) {
      for (let i = 0; i < this.skipNavigations.length; i++) {
        this.skipNavigations[i].skipHistory = true;
      }
      this.Router.addSkipNavigations(this.skipNavigations);
    }
    this.Router.start();
  }
  /** Initializate state and context * */
  _initializeBridgeStatus() {
    this.BridgeChannelManager.initAppContextChannel();
    this.BridgeChannelManager.getCancelledBackNavigationChannel();
    this.BridgeChannelManager.getInterceptedNavigationChannel();
    this.ActionChannelManager.subscribeAll();
    this._executePendingBridgeQueue();
    this.ApplicationConfigManager.loadAppConfig();
    this.ApplicationStateManager.loadAppState();
  }
  /** Initialize listeners * */
  _initializeEventListeners() {
    const { NAV_REQUEST, ROUTER_BACKSTEP } = externalEventsCodes6;
    this.navRequestListener = (info) => {
      if (this.Router.hashIsDirty) {
        window.location.hash = "#!";
      }
      const { event, detail: navigationDetail } = info;
      let { page, params, skipHistory, cleanUntil, replace = false, paramPage } = navigationDetail;
      let p = {};
      if (!page && paramPage && event.detail) {
        page = event.detail[paramPage];
      }
      if (event.detail && params) {
        for (let param in params) {
          if (event.detail.hasOwnProperty(param)) {
            p[params[param]] = event.detail[param];
          }
        }
      }
      if (cleanUntil) {
        this.Router.clearStackUntil(cleanUntil);
      }
      this.Router.go(page, p, replace, skipHistory);
    };
    eventManager.on(NAV_REQUEST, this.navRequestListener);
    eventManager.on(ROUTER_BACKSTEP, this.handleBack.bind(this));
  }
  /**
   * Updates the interceptor context.
   *
   * @param {Object} ctx - The interceptor context.
   */
  updateInterceptorContext(ctx) {
    this.Router.updateInterceptorContext(ctx);
  }
  /** Resets the interceptor context by setting it to an empty object. */
  resetInterceptorContext() {
    this.Router.setInterceptorContext({});
  }
  /**
   * Returns the interceptor context.
   *
   * @returns {Object} The interceptor context.
   */
  getInterceptorContext() {
    return this.Router.getInterceptorContext();
  }
  /**
   * Sets the interceptor context.
   *
   * @param {Object} ctx - The interceptor context.
   */
  setInterceptorContext(ctx) {
    this.Router.setInterceptorContext(ctx);
  }
  /**
   * Performs the go back action. This method is overriden by the CellsNativeBridge
   *
   * @returns {NavigationWithParams} The executed navigation, an object with properties:
   */
  goBack() {
    return this.Router.back();
  }
  /**
   * This method is executed when the event router-backstep is fired. It calls the hook method for
   * handling backward navigations and if that method allows the continuation, it does the
   * navegation. Otherwise it will cancel the navigation and publish the response in the channel
   * [BRIDGE_CHANNEL_PREFIX]_cancelled_back_navigation.
   */
  handleBack() {
    this.goBack();
  }
  /**
   * Execute queued bridge commands due to delayed instance of bridge and premature execution of
   * commands.
   */
  _executePendingBridgeQueue() {
    let cellsBridgeQueue;
    cellsBridgeQueue = $queueCommands;
    if (Array.isArray(cellsBridgeQueue)) {
      cellsBridgeQueue.forEach(({ command, parameters }) => {
        const queuedCommand = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), command);
        if (!queuedCommand) {
          console.log(`WARNING: Invalid cells bridge command execution: ${command} (QUEUE).`);
          return;
        }
        const queuedCommandFunction = queuedCommand.value;
        console.log(`Executing queued command ${command}.`);
        queuedCommandFunction.apply(this, parameters);
      });
      $queueCommands = [];
    }
  }
  /**
   * Dispatches a custom event with the given name and payload.
   *
   * @param {string} name - The name of the event.
   * @param {any} payload - The payload to be attached to the event.
   * @throws {Error} If the defined main node does not exist.
   */
  _dispatchEvent(name, payload) {
    const mainNode = this.getMainNode();
    if (!mainNode) {
      throw new Error("The defined main node does not exist");
    }
    const event = payload ? new CustomEvent(name, { detail: payload }) : new CustomEvent(name);
    mainNode.dispatchEvent(event);
  }
  /** Plugs external events to the main node. */
  _plugExternalEvents() {
    let len = this.externalEvents.length;
    let mainNode = this.getMainNode();
    if (mainNode) {
      for (let i = 0; i < len; i++) {
        const eventName = this.externalEvents[i];
        eventManager.on(eventName, (data) => {
          this._dispatchEvent(eventName, data);
        });
      }
      this._initEventChannels();
    } else {
      console.warn("The defined main node does not exist");
    }
  }
  /** Initializes the event channels for the bridge. */
  _initEventChannels() {
    let mainNode = this.getMainNode();
    this.BridgeChannelManager.initEventChannels(mainNode, this.externalEvents);
    this._addInitialSubscribersToEvents();
  }
  /** Adds initial subscribers to events. If there are event subscriptions, it subscribes to them. */
  _addInitialSubscribersToEvents() {
    if (this.eventSubscriptions && this.eventSubscriptions.length > 0) {
      this._subscribeToEvents(this.eventSubscriptions);
    }
  }
  /**
   * Subscribes to multiple events.
   *
   * @param {Object[]} eventSubscriptions - An array of event subscriptions.
   * @param {string} eventSubscriptions[].event - The event to subscribe to.
   * @param {Function} eventSubscriptions[].callback - The callback function to be executed when the
   *   event is triggered.
   */
  _subscribeToEvents(eventSubscriptions) {
    eventSubscriptions.forEach((subscription) => {
      const { event, callback } = subscription;
      this.subscribeToEvent(event, callback);
    });
  }
  /**
   * Initialization of cross components container. Check if cross component container exists.
   * Otherwise, it will be created.
   */
  _initCrossComponents() {
    const crossContainerTemplateId = this.TemplateManager.computeTemplateId(this.crossContainerId);
    let crossContainer = this.TemplateManager.get(crossContainerTemplateId);
    const crossContainerElement = document.getElementById(crossContainerTemplateId);
    if (!crossContainer) {
      if (!crossContainerElement) {
        crossContainer = this.TemplateManager.createTemplate(this.crossContainerId, {
          tagName: "div"
        });
        document.body.appendChild(crossContainer.node);
      } else {
        this.usingDeclarativeCrossContainer = true;
        this.TemplateManager.createTemplate(this.crossContainerId, {
          node: crossContainerElement
        });
      }
    }
  }
  /**
   * Determines if the given zone is inside a layout.
   *
   * @param {string} zone - The zone to check.
   * @returns {boolean} - True if the zone is inside a layout, false otherwise.
   */
  _insideLayout(zone) {
    return zone != void 0 && zone.split(".").length === 2;
  }
  /**
   * Creates a page from a web component.
   *
   * @param {string} name - The name of the route.
   * @param {string | undefined} componentRoute - The name of the web component.
   * @returns {Promise<void>} A promise that resolves when the page is created.
   */
  createPageFromWebComponent(name, componentRoute) {
    const componentName = componentRoute || `${name}-page`;
    const component = this.TemplateManager.getNode(componentName);
    this.BridgeChannelManager.getPrivate(name);
    const isUnresolved = (node) => {
      const isCustomElement = node.tagName.includes("-");
      const resolved2 = !!window.customElements.get(node.tagName.toLowerCase());
      return isCustomElement && !resolved2;
    };
    if (!component) {
      const template = this.TemplateManager.createTemplate(name, {
        tagName: componentName
      });
      if (isUnresolved(template.node)) {
        if (this.loadCellsPage) {
          return this.loadCellsPage(name);
        }
      }
    }
    return Promise.resolve();
  }
  /**
   * Id for template node
   *
   * @param {String} name Template name
   * @returns {String}
   */
  computeTemplateId(name) {
    return "cells-template-" + name.replace(/\./g, "-");
  }
  /** Prints debug information about the bridge. */
  printDebugInfo() {
    const getColor = function(option, color) {
      const hexColor = option ? color : "#b0bec5";
      return `background:${hexColor}; color:#fff; padding:2px 4px; margin-right: 5px;`;
    };
    console.log(
      `%cbridge version: ${this.version} %ccache: ${this.cache}`,
      getColor(this.version, "#003f8d"),
      getColor(this.cache, "#0093e2")
    );
  }
  /** Handles the routing logic and updates the page accordingly. */
  routeHandler() {
    const { PARSE_ROUTE } = externalEventsCodes6;
    const route = this.Router.currentRoute;
    eventManager.emit(PARSE_ROUTE, route);
    this._handleRouteLoading(route);
    for (let param in route.params) {
      const evt = eventManager.createEvent(dasherize2(param) + "-changed", route.params[param]);
      this.ComponentConnector.getChannel(param).next(evt);
    }
  }
  /**
   * Handles the loading of a route.
   *
   * @param {Route} route - The route object.
   */
  _handleRouteLoading(route) {
    this.createPageFromWebComponent(route.name, route.component).then(
      () => this.selectPage(route.name, route.params)
    );
  }
  // this function MAY BE OVERRIDDEN by native bridge - not required due to internal router updating the context
  /**
   * Updates the bridge channels based on the previous and current templates.
   *
   * @param {Template} previousTemplate - The previous template object.
   * @param {Template} currentTemplate - The current template object.
   */
  _updateChannels(previousTemplate, currentTemplate) {
    if (this.BridgeChannelManager) {
      const oldName = previousTemplate ? previousTemplate.name : void 0;
      const ctx = this.getInterceptorContext();
      const currentRoute = this.getCurrentRoute();
      this.BridgeChannelManager.updateBridgeChannels(
        oldName,
        currentTemplate.name,
        ctx,
        currentRoute
      );
    }
  }
  /**
   * Registers a connection in the bridge.
   *
   * @param {string} channelName - The name of the channel.
   * @param {WCNode} node - The node to be connected.
   * @param {Binding} callback - The callback function to be executed when a message is received on
   *   the channel.
   */
  registerInConnection(channelName, node, callback) {
    this.ComponentConnector.addSubscription(channelName, node, callback);
  }
  /**
   * Registers an outgoing connection.
   *
   * @param {string} channelName - The name of the channel.
   * @param {WCNode} htmlElement - The HTML element to bind the connection to.
   * @param {string} bindName - The name of the binding.
   * @param {Connection | undefined} extraParameters - Any extra parameters to pass to the
   *   connection.
   */
  registerOutConnection(channelName, htmlElement, bindName, extraParameters) {
    this.ComponentConnector.addPublication(channelName, htmlElement, bindName, extraParameters);
  }
  /**
   * Unsubscribes a node from the specified channels.
   *
   * @param {string | string[]} channels - The channels to unsubscribe from.
   * @param {WCNode} node - The node to unsubscribe.
   */
  unsubscribe(channels, node) {
    this.ComponentConnector.unsubscribe(channels, node);
  }
  /**
   * Publishes a value to a channel.
   *
   * @param {string} channelName - The name of the channel.
   * @param {any} value - The value to be published.
   * @param {Object} options - Optional parameters.
   * @param {boolean} options.sessionStorage - Indicates whether to save the app state in session
   *   storage.
   */
  publish(channelName, value, { sessionStorage } = { sessionStorage: false }) {
    this.ComponentConnector.publish(channelName, value);
    if (sessionStorage === true) {
      this.ApplicationStateManager.saveAppState(channelName, value);
    }
  }
  /**
   * Updates the application configuration and optionally saves it to session storage.
   *
   * @param {object} config - The new application configuration.
   * @param {object} [options] - Optional parameters.
   * @param {boolean} [options.sessionStorage] - Indicates whether to save the configuration to
   *   session storage.
   */
  updateApplicationConfig(config2, { sessionStorage } = {}) {
    const CONFIG_CHANNEL_NAME = `${BRIDGE_CHANNEL_PREFIX}_ch_config`;
    this.publish(CONFIG_CHANNEL_NAME, config2);
    if (sessionStorage === true) {
      this.ApplicationConfigManager.saveAppConfig(config2);
    }
  }
  /**
   * Updates the subroute in the browser.
   *
   * @param {string} subroute - The new subroute to update.
   */
  updateSubroute(subroute) {
    this.Router.updateSubrouteInBrowser(subroute);
  }
  /**
   * Returns the current route information.
   *
   * @returns {RouteData} The current route object containing the name, params, query, subroute, and
   *   hashPath.
   */
  getCurrentRoute() {
    const { name, params, query, subroute } = this.Router.currentRoute;
    return {
      name,
      params,
      query,
      subroute,
      hashPath: this.Router._getHashPath()
    };
  }
  /**
   * Navigate to a specific page.
   *
   * @param {string} page - La página a la que se desea navegar.
   * @param {QueryParams} params - Los parámetros opcionales para la página.
   */
  navigate(page, params) {
    this.Router.go(page, params);
  }
  /** Performs a back step in the router. */
  backStep() {
    const { ROUTER_BACKSTEP } = externalEventsCodes6;
    eventManager.emit(ROUTER_BACKSTEP, {
      event: {},
      detail: {}
    });
  }
  /**
   * Waits for the rendering of the template to complete.
   *
   * @param {Template} template - The template to wait for rendering completion.
   * @returns {Promise<boolean>} - A promise that resolves when the rendering is complete.
   */
  _waitRenderComplete(template) {
    return template.node.updateComplete || Promise.resolve(true);
  }
  /**
   * Selects a page and performs necessary operations.
   *
   * @param {string} name - The name of the page to select.
   * @param {QueryParams} params - The parameters to pass to the selected page.
   * @returns {void}
   */
  selectPage(name, params) {
    const { TEMPLATE_REGISTERED } = externalEventsCodes6;
    const template = this.TemplateManager.get(name);
    const currentTemplate = this.TemplateManager.get(this.TemplateManager.selected);
    const oldTemplateName = currentTemplate ? currentTemplate.name : void 0;
    if (this.onRender) {
      this.onRender(template.node);
    }
    (async () => {
      await this._waitRenderComplete(template);
      this._handleParams(template.node, params);
      const ctx = this.getInterceptorContext();
      const currentRoute = this.getCurrentRoute();
      this.TemplateManager.select(name);
      if (this.BridgeChannelManager) {
        this.BridgeChannelManager.updateBridgeChannels(oldTemplateName, name, ctx, currentRoute);
      }
      eventManager.emit(TEMPLATE_REGISTERED, { template: name });
    })();
  }
  /**
   * Handles the parameters for a given node.
   *
   * @param {IndexableHTMLElement} node - The node to handle the parameters for.
   * @param {QueryParams} params - The parameters to bind to the node.
   */
  _handleParams(node, params) {
    const shouldBindParams = node["params"] && Object.keys(params).length > 0;
    if (shouldBindParams) {
      node["params"] = params;
    }
  }
  /**
   * It subscribe the main node to an event channel.
   *
   * @param {string} eventName Is the name of the event to subscribe
   * @param {Function} callback Is the function to call when the event channel is activated with a
   *   new value
   */
  subscribeToEvent(eventName, callback) {
    if (this.externalEvents.indexOf(eventName) < 0) {
      console.warn("Trying to subscribe to a non existing event: ", eventName);
      return;
    }
    if (typeof callback !== "function") {
      console.warn("You must provide a function callback to subscribe to the event: ", eventName);
      return;
    }
    let mainNode = this.getMainNode();
    this.BridgeChannelManager.subscribeToEvent(mainNode, eventName, callback);
  }
  /**
   * Retrieves the main node element.
   *
   * @returns {WCNode} The main node element.
   */
  getMainNode() {
    if (!this.__mainNodeElement) {
      this.__mainNodeElement = document.querySelector("#" + this.mainNode);
    }
    if (!this.__mainNodeElement) {
      throw new Error("The defined main node does not exist");
    }
    return this.__mainNodeElement;
  }
  /**
   * Disconnects cross components by unregistering the components from the ComponentConnector.
   *
   * @param {{ inConnections: InConnection[]; outConnections: OutConnection[] }} connections - The
   *   connections object containing inConnections and outConnections.
   * @param {boolean} cleanPrivateChannels - Indicates whether to clean private channels during
   *   unregistering.
   */
  _disconnectCrossComponents({ inConnections, outConnections }, cleanPrivateChannels) {
    inConnections == null ? void 0 : inConnections.forEach((cnx) => {
      this.ComponentConnector.unregisterComponent(cnx.component, cleanPrivateChannels);
    });
    outConnections == null ? void 0 : outConnections.forEach((cnx) => {
      this.ComponentConnector.unregisterComponent(cnx.component, cleanPrivateChannels);
    });
  }
  /**
   * Reconnects the cross components by registering the input and output connections.
   *
   * @param {{ inConnections: InConnection[]; outConnections: OutConnection[] }} connections - The
   *   connections object containing the input and output connections.
   */
  _reconnectCrossComponents({ inConnections, outConnections }) {
    inConnections == null ? void 0 : inConnections.forEach((cnx) => {
      this.registerInConnection(cnx.channel, cnx.component, cnx.bind);
    });
    outConnections == null ? void 0 : outConnections.forEach((cnx) => {
      this.registerOutConnection(cnx.channel, cnx.component, cnx.bind, cnx.options);
    });
  }
  /** Cleans up the dynamic cross components by removing them from the DOM and clearing the register. */
  _cleanDynamicCrossComponents() {
  }
  /** Resets the bridge channels and performs necessary cleanup operations. */
  _resetBridgeChannels() {
    const cleanPrivateChannels = true;
    const crossContainerTemplateId = this.TemplateManager.computeTemplateId(this.crossContainerId);
    const crossComponentsConnections = this.BridgeChannelManager.getCCSubscriptions(
      crossContainerTemplateId,
      this.getMainNode().id
    ) || {};
    this._disconnectCrossComponents(crossComponentsConnections, cleanPrivateChannels);
    this.BridgeChannelManager.resetBridgeChannels(this.getMainNode(), cleanPrivateChannels);
    this._cleanDynamicCrossComponents();
    this._reconnectCrossComponents(crossComponentsConnections);
  }
  /**
   * Performs a logout action. It resets all channels, removes templates from DOM and redirects to
   * the initial page
   */
  logout() {
    if (this.TemplateManager.selected === this.initialTemplate) {
      return;
    }
    this.BridgeChannelManager.publishPrivatePageStatus(this.TemplateManager.selected, false);
    this._resetBridgeChannels();
    if (!this.usingDeclarativeCrossContainer) {
      this.TemplateManager.removeTemplateChildrens(this.crossContainerId);
    }
    this.TemplateManager.removeTemplates("", this.crossContainerId);
    this.ActionChannelManager.subscribeAll();
    this._addInitialSubscribersToEvents();
    this.resetInterceptorContext();
    this.Router.init();
    this.Router.go(this.initialTemplate);
  }
  /**
   * Renders the template and appends it to the main node. If fixed is provided, it appends the
   * fixed components to their respective zones.
   *
   * @param {WCNode} template - The template to be rendered.
   */
  onRender(template) {
    var _a;
    if (!template.parentNode && this.mainNode) {
      (_a = document.getElementById(this.mainNode)) == null ? void 0 : _a.appendChild(template);
      const componentsInTemplateLoaded = new CustomEvent("componentsInTemplateLoaded");
      document.body.dispatchEvent(componentsInTemplateLoaded);
    }
  }
  /**
   * Loads the specified cells page.
   *
   * @param {string} page - The page to load.
   * @returns {any} - The result of the page action.
   */
  loadCellsPage(page) {
    const route = this.Router.routes[page];
    return route.action();
  }
  /**
   * Parses an array of routes and returns an object with route names as keys and corresponding path
   * and action as values.
   *
   * @param {RouteDefinition[]} routesArray - The array of routes to be parsed.
   * @returns {ParsedRoute} - The parsed routes object.
   */
  _parseRoutes(routesArray) {
    const routesObject = {};
    routesArray.forEach((route) => {
      const { name, path, action, notFound, component } = route;
      routesObject[name] = { path, action, notFound: Boolean(notFound), component };
    });
    return routesObject;
  }
  /**
   * Lazy loading of pages.
   *
   * @param {string[]} componentNames *
   */
  _lazyLoadPages(componentNames) {
    componentNames.forEach((componentName) => {
      this.loadCellsPage(componentName);
    });
  }
};

export {
  $bridge,
  startApp,
  getConfig,
  subscribe,
  unsubscribe,
  publish,
  publishOn,
  navigate,
  updateInterceptorContext,
  resetInterceptorContext,
  getInterceptorContext,
  setInterceptorContext,
  getCurrentRoute,
  updateSubroute,
  backStep,
  Bridge
};
//# sourceMappingURL=chunk-F7YLLEUV.js.map
