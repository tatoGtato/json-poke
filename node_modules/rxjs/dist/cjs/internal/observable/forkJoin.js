"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.forkJoin = void 0;
const Observable_1 = require("../Observable");
const argsArgArrayOrObject_1 = require("../util/argsArgArrayOrObject");
const from_1 = require("./from");
const args_1 = require("../util/args");
const Subscriber_1 = require("../Subscriber");
const mapOneOrManyArgs_1 = require("../util/mapOneOrManyArgs");
const createObject_1 = require("../util/createObject");
const EmptyError_1 = require("../util/EmptyError");
function forkJoin(...args) {
    const resultSelector = (0, args_1.popResultSelector)(args);
    const { args: sources, keys } = (0, argsArgArrayOrObject_1.argsArgArrayOrObject)(args);
    const result = new Observable_1.Observable((destination) => {
        const { length } = sources;
        if (!length) {
            destination.complete();
            return;
        }
        const values = new Array(length);
        let remainingCompletions = length;
        let remainingEmissions = length;
        for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {
            let hasValue = false;
            (0, from_1.from)(sources[sourceIndex]).subscribe((0, Subscriber_1.operate)({
                destination,
                next: (value) => {
                    if (!hasValue) {
                        hasValue = true;
                        remainingEmissions--;
                    }
                    values[sourceIndex] = value;
                },
                complete: () => remainingCompletions--,
                finalize: () => {
                    if (!remainingCompletions || !hasValue) {
                        if (remainingEmissions === 0) {
                            destination.next(keys ? (0, createObject_1.createObject)(keys, values) : values);
                            destination.complete();
                        }
                        else {
                            destination.error(new EmptyError_1.EmptyError());
                        }
                    }
                },
            }));
        }
    });
    return resultSelector ? result.pipe((0, mapOneOrManyArgs_1.mapOneOrManyArgs)(resultSelector)) : result;
}
exports.forkJoin = forkJoin;
//# sourceMappingURL=forkJoin.js.map