"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.operate = exports.Subscriber = void 0;
const isFunction_1 = require("./util/isFunction");
const Subscription_1 = require("./Subscription");
const config_1 = require("./config");
const reportUnhandledError_1 = require("./util/reportUnhandledError");
const NotificationFactories_1 = require("./NotificationFactories");
const timeoutProvider_1 = require("./scheduler/timeoutProvider");
class Subscriber extends Subscription_1.Subscription {
    isStopped = false;
    destination;
    _nextOverride = null;
    _errorOverride = null;
    _completeOverride = null;
    _onFinalize = null;
    constructor(destination, overrides) {
        super();
        this.destination = destination instanceof Subscriber ? destination : createSafeObserver(destination);
        this._nextOverride = overrides?.next ?? null;
        this._errorOverride = overrides?.error ?? null;
        this._completeOverride = overrides?.complete ?? null;
        this._onFinalize = overrides?.finalize ?? null;
        this._next = this._nextOverride ? overrideNext : this._next;
        this._error = this._errorOverride ? overrideError : this._error;
        this._complete = this._completeOverride ? overrideComplete : this._complete;
        if (hasAddAndUnsubscribe(destination)) {
            destination.add(this);
        }
    }
    next(value) {
        if (this.isStopped) {
            handleStoppedNotification((0, NotificationFactories_1.nextNotification)(value), this);
        }
        else {
            this._next(value);
        }
    }
    error(err) {
        if (this.isStopped) {
            handleStoppedNotification((0, NotificationFactories_1.errorNotification)(err), this);
        }
        else {
            this.isStopped = true;
            this._error(err);
        }
    }
    complete() {
        if (this.isStopped) {
            handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        }
        else {
            this.isStopped = true;
            this._complete();
        }
    }
    unsubscribe() {
        if (!this.closed) {
            this.isStopped = true;
            super.unsubscribe();
            this._onFinalize?.();
        }
    }
    _next(value) {
        this.destination.next(value);
    }
    _error(err) {
        try {
            this.destination.error(err);
        }
        finally {
            this.unsubscribe();
        }
    }
    _complete() {
        try {
            this.destination.complete();
        }
        finally {
            this.unsubscribe();
        }
    }
}
exports.Subscriber = Subscriber;
function overrideNext(value) {
    try {
        this._nextOverride(value);
    }
    catch (error) {
        this.destination.error(error);
    }
}
function overrideError(err) {
    try {
        this._errorOverride(err);
    }
    catch (error) {
        this.destination.error(error);
    }
    finally {
        this.unsubscribe();
    }
}
function overrideComplete() {
    try {
        this._completeOverride();
    }
    catch (error) {
        this.destination.error(error);
    }
    finally {
        this.unsubscribe();
    }
}
class ConsumerObserver {
    partialObserver;
    constructor(partialObserver) {
        this.partialObserver = partialObserver;
    }
    next(value) {
        const { partialObserver } = this;
        if (partialObserver.next) {
            try {
                partialObserver.next(value);
            }
            catch (error) {
                (0, reportUnhandledError_1.reportUnhandledError)(error);
            }
        }
    }
    error(err) {
        const { partialObserver } = this;
        if (partialObserver.error) {
            try {
                partialObserver.error(err);
            }
            catch (error) {
                (0, reportUnhandledError_1.reportUnhandledError)(error);
            }
        }
        else {
            (0, reportUnhandledError_1.reportUnhandledError)(err);
        }
    }
    complete() {
        const { partialObserver } = this;
        if (partialObserver.complete) {
            try {
                partialObserver.complete();
            }
            catch (error) {
                (0, reportUnhandledError_1.reportUnhandledError)(error);
            }
        }
    }
}
function createSafeObserver(observerOrNext) {
    return new ConsumerObserver(!observerOrNext || (0, isFunction_1.isFunction)(observerOrNext) ? { next: observerOrNext ?? undefined } : observerOrNext);
}
function handleStoppedNotification(notification, subscriber) {
    const { onStoppedNotification } = config_1.config;
    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
}
function hasAddAndUnsubscribe(value) {
    return value && (0, isFunction_1.isFunction)(value.unsubscribe) && (0, isFunction_1.isFunction)(value.add);
}
function operate({ destination, ...subscriberOverrides }) {
    return new Subscriber(destination, subscriberOverrides);
}
exports.operate = operate;
//# sourceMappingURL=Subscriber.js.map