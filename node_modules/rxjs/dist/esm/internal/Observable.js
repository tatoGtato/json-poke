import { Subscriber } from './Subscriber';
import { observable as Symbol_observable } from './symbol/observable';
import { pipeFromArray } from './util/pipe';
export class Observable {
    constructor(subscribe) {
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    subscribe(observerOrNext) {
        const subscriber = observerOrNext instanceof Subscriber ? observerOrNext : new Subscriber(observerOrNext);
        subscriber.add(this._trySubscribe(subscriber));
        return subscriber;
    }
    _trySubscribe(sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.error(err);
        }
    }
    forEach(next) {
        return new Promise((resolve, reject) => {
            const subscriber = new Subscriber({
                next: (value) => {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscriber.unsubscribe();
                    }
                },
                error: reject,
                complete: resolve,
            });
            this.subscribe(subscriber);
        });
    }
    _subscribe(_subscriber) {
        return;
    }
    [Symbol_observable]() {
        return this;
    }
    pipe(...operations) {
        return pipeFromArray(operations)(this);
    }
    [Symbol.asyncIterator]() {
        let subscription;
        let hasError = false;
        let error;
        let completed = false;
        const values = [];
        const deferreds = [];
        const handleError = (err) => {
            hasError = true;
            error = err;
            while (deferreds.length) {
                const [_, reject] = deferreds.shift();
                reject(err);
            }
        };
        const handleComplete = () => {
            completed = true;
            while (deferreds.length) {
                const [resolve] = deferreds.shift();
                resolve({ value: undefined, done: true });
            }
        };
        return {
            next: () => {
                if (!subscription) {
                    subscription = this.subscribe({
                        next: (value) => {
                            if (deferreds.length) {
                                const [resolve] = deferreds.shift();
                                resolve({ value, done: false });
                            }
                            else {
                                values.push(value);
                            }
                        },
                        error: handleError,
                        complete: handleComplete,
                    });
                }
                if (values.length) {
                    return Promise.resolve({ value: values.shift(), done: false });
                }
                if (completed) {
                    return Promise.resolve({ value: undefined, done: true });
                }
                if (hasError) {
                    return Promise.reject(error);
                }
                return new Promise((resolve, reject) => {
                    deferreds.push([resolve, reject]);
                });
            },
            throw: (err) => {
                subscription?.unsubscribe();
                handleError(err);
                return Promise.reject(err);
            },
            return: () => {
                subscription?.unsubscribe();
                handleComplete();
                return Promise.resolve({ value: undefined, done: true });
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}
//# sourceMappingURL=Observable.js.map