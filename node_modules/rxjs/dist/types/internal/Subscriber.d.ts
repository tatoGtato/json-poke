import { Observer } from './types';
import { Subscription } from './Subscription';
export interface SubscriberOverrides<T> {
    /**
     * If provided, this function will be called whenever the {@link Subscriber}'s
     * `next` method is called, with the value that was passed to that call. If
     * an error is thrown within this function, it will be handled and passed to
     * the destination's `error` method.
     * @param value The value that is being observed from the source.
     */
    next?: (value: T) => void;
    /**
     * If provided, this function will be called whenever the {@link Subscriber}'s
     * `error` method is called, with the error that was passed to that call. If
     * an error is thrown within this function, it will be handled and passed to
     * the destination's `error` method.
     * @param err An error that has been thrown by the source observable.
     */
    error?: (err: any) => void;
    /**
     * If provided, this function will be called whenever the {@link Subscriber}'s
     * `complete` method is called. If an error is thrown within this function, it
     * will be handled and passed to the destination's `error` method.
     */
    complete?: () => void;
    /**
     * If provided, this function will be called after all teardown has occurred
     * for this {@link Subscriber}. This is generally used for cleanup purposes
     * during operator development.
     */
    finalize?: () => void;
}
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 */
export declare class Subscriber<T> extends Subscription implements Observer<T> {
    /**
     * @deprecated Do not create instances of `Subscriber` directly. Use {@link operate} instead.
     */
    constructor(destination?: Subscriber<T> | Partial<Observer<T>> | ((value: T) => void) | null);
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param value The `next` value.
     */
    next(value: T): void;
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached `Error`. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param err The `error` exception.
     */
    error(err?: any): void;
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     */
    complete(): void;
    unsubscribe(): void;
    protected _next(value: T): void;
    protected _error(err: any): void;
    protected _complete(): void;
}
export interface OperateConfig<In, Out> extends SubscriberOverrides<In> {
    /**
     * The destination subscriber to forward notifications to. This is also the
     * subscriber that will receive unhandled errors if your `next`, `error`, or `complete`
     * overrides throw.
     */
    destination: Subscriber<Out>;
}
/**
 * Creates a new {@link Subscriber} instance that passes notifications on to the
 * supplied `destination`. The overrides provided in the `config` argument for
 * `next`, `error`, and `complete` will be called in such a way that any
 * errors are caught and forwarded to the destination's `error` handler. The returned
 * `Subscriber` will be "chained" to the `destination` such that when `unsubscribe` is
 * called on the `destination`, the returned `Subscriber` will also be unsubscribed.
 *
 * Advanced: This ensures that subscriptions are properly wired up prior to starting the
 * subcription logic. This prevents "synchronous firehose" scenarios where an
 * inner observable from a flattening operation cannot be stopped by a downstream
 * terminal operator like `take`.
 *
 * This is a utility designed to be used to create new operators for observables.
 *
 * For examples, please see our code base.
 *
 * @param config The configuration for creating a new subscriber for an operator.
 * @returns A new subscriber that is chained to the destination.
 */
export declare function operate<In, Out>({ destination, ...subscriberOverrides }: OperateConfig<In, Out>): Subscriber<In>;
//# sourceMappingURL=Subscriber.d.ts.map